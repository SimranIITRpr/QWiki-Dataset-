PAGE RANK: HOW DOES GOOGLE WORK? 01
We are now going to discus one of the most celebrated ideas in computer science. I will say it is one of the most celebrated ideas heavily applied idea in whole of mankind, I get to say this because simplicities of the idea yet it has tremendous applications you will soon get to know what I am going to talk about but before which let us start our lesson with a small activity. The activity comprises of a bunch of students trying to talk to each other and then they make a note of who all they were impressed with for example, a person will go and talk to twenty others and make a note of list of people that she was impressed with and every single person does the same. All twenty people do this, write down the names of people there are impressed with and they give it to us. Now we create what is called the impression network, who likes whom? It looks like this on twenty nodes and now we ask this question. This impression is more like voting I like him, I like here based on this can we pick a leader amongst this twenty people. First question, how do you pick a leader? Second question, why is it important for us to even ask this question, why is this the most celebrated idea of all times? You will soon get to know after watching this activity.
PAGE RANK: HOW DOES GOOGLE WORK? 02
So now you just saw a group of people were just asked to choose their leader, each of each one of them was asked to select around five people to whom they wanted to be their leader and now have the leader of the group here, congratulations virender you have been selected as the leader of the group. Thank you so much it would be a proud privilege for me, how did you convince these many people to vote for you? Actually convincing them is not a big task what I feel personally, yeah the thing is that first of all I introduced myself that what type of problems they are facing actually whether they are from research side, whether they are from graduation side that what type of problem they are facing in their hostel life and their carrier life so by asking all this and giving some good suggestions so I think I have been connecting them very properly. Yeah to that reason yeah so due to them actually I feel that they choose me as maximum as possible, oh good so can you guess how many votes did u get? Definitely many, ok you got many votes but let me tell you one thing it’s not only the number of votes that made you the leader but it also the people who voted for you. I didn’t get you, it’s the number of votes that server as the deciding factor in every election but how this? Let me explain you page rank algorithm. So take an example suppose you and your friend are applying for a promotion both of you are working in a company so many of your colleagues have refer to your friend for the promotion but your manager and group has referred you who has high chances to de promote it? I think me, ok now you see the number of people who are refereeing doesn’t matter it also matters who is referring to you so this is the page rank algorithm and a Google also works on this very simple algorithm. That’s really cool, yeah. So in Google we have a underline web graph where the nodes are the wrap pages ok and the links are the hyper links, meaning one page is referring to another page through a hyper link we will connect it through the edged ok and then Google page rank algorithm to find out the top most. That’s really cool yeah I really like this thing yeah. So congratulation again thank you so much and we have a small gift for you, thank you so much winning the election.
PAGE RANK: HOW DOES GOOGLE WORK? 03
You know what I am going to do with this data. I now have a what is called a network and my network look like this do you see the nodes here and the edges, look at this arrow from this node to this node it just represent that this person found this person impressive. If A finds B impressive B may not find A impressive correct? Now my question is how so you find the most impressive person here in this network and obvious answer that we will have is ok at that person who has a lot of arrows coming in by that we mean many people found him impressive a number of people finding someone impressive should not be an indication of how impressive a person is. For example assume hundred friends of mine says I am a nice person that is different from the prime minister of India saying “I am a nice person” in one of his speeches. Right there is a huge difference so what do you infer? It is not how many people who elect who vote for you it’s about who are those people who vote for you, maybe we should consider that right? So now on this network I would like to ask this question who is the most impressive person? And I am going to give you a technique to find it. You may not even see why exactly we are using this technique to find the most impressive person but with time it will be very clear. Here goes my algorithm, here goes my technique what I will do is on this graph that you are seeing the network I will start from some node and take what is called a drunkards’ walk also called the random walk the point is you start from the node let’s say this node you have so many lines going from this node forget about what this network represents I am going to play around this network. I am going to jump to one of the lines and land at the other end of this line the point whatever you are seeing I am going to land there but I have so many choices to take I will pick one of them randomly then I jump there once I jump there I mark one here saying that I have seen it already and from here I will jump to another node again from here there are many lines going out I will choice one of them randomly and jump there and call it I have visited it once I keep doing this I keep doing this if I visited node more than once I will make a note of it I will call it I visited this node twice and so on and finally I will do this lets say a million times may if I am not happy I will do it a couple of million times or even more than that and after doing this a million times I will see what is the points collected by individual nodes. And I will look at that node which has collected the maximum number of points and I will declare that node as the winner. Why do I do this? What does this signify? You will get to know very soon.
PAGE RANK: HOW DOES GOOGLE WORK? 04
Now we had a bunch of people and we ask them to take part in an activity and then we drew a network from them and did what is called Radom walking on the network I asked you to do it right will show you how to do it right now but one should do this random walk and then see the points accumulated per node and then look at that node with the highest point and call that fellow a leader. Now you know what? This is precisely how the Google search engine works and this algorithm is called the page rank algorithm. So what is the connection? Look at this, look at this network and take a random walk on it. Which what are those nodes which will have highest number of visits, it’s going to be those nodes which are easily reachable when you are taking random walks. How do you reach a node? It should be easy to reach their neighbours. How can you reach their neighbours? It should be easy to reach their neighbours neighbours the most popular person’s neighbours neighbours so if there is a easy in coming way to a node then that node have a very high weight so intuitively speaking a person is important if important people point to him. A node will get a lot of weight if it is adjacent to a few nodes and these few nodes are all important, by important we mean they are adjacent to a lot more nodes, a node is adjacent to many nodes and these nodes are adjacent to many nodes and so on. Correct? So we are just giving you a very toned down version of page rank because it’s a first course in programming we don’t want to bother you with the lot of details but if you are interested you can take a look at our course on NPTEL called the SOCIAL NETWORKS course there we describe in detail one entire week we discuss on how page rank works. So getting back we have now told you how to take a random walk on a network increment the points individually on the nodes and look at the top nodes thus obtained they are the most important nodes now how does Google work based on this idea. It’s very simple what Google does is as you can see in this animation it takes a website and on that website as you know given a website it will have a lot of hyper links to another website by hyper links we mean a place where you go and you click and it takes you to another page you see that’s called the hyper link ok so I will take all possible web pages in the world that one can think of and I will put an arrow from a web page to another web page if there is a link from this web page to this web page and I will create this huge network by the way this is how the network of internet looks like where a line between two node where nodes represent that sides and the line between two represent that there is a link from this side to that side this was the snapshot of the internet long long back off course it has grown a bigger right now it looks even more complicated right now but just for completeness sake we are flashing the network of the internet this is called the world wide web network so now here what Google does is it takes all these pages of the world and runs a random walk on it. It’s a huge network you see it takes a long time to run random walk off course with sophisticated computers you can do this. A huge network on billions of node you run random walk and you make an note of how many times you visit a node as you are taking random walk, as we are talking, as we are listening to this video Google actually is doing this. It is taking all the websites of the world and then taking random walks on it. Ok you would have heard of crawlers this is precisely what I mean by crawlers. There is a program which crawls the web like this and makes a note of how many times I visited the what node and ranks all the nodes based on the visits to the node ok when you type the word Mysore city right it will look at all
 
those websites which has the word Mysore and then it will realise that there are ten thousand websites that has Mysore in it but it will show you the top few sites that have accumulated top points due to this random walk. You may want to get that straight let me repeat so when type Mysore there are ten thousand hits ten thousand sites which has Mysore in it but then Google will fetch the top few sites to you how does it know what are the top few sites, top few sites based on the points accumulated because of random walk that’s it this single idea has lead to a five hundred billion dollar industry today. Google has it stand tall mainly started of this algorithm which till date is the best possible searching technology off course there are several other parameters in search engine users but the basic heart the nucleus of the idea is whatever we are whatever we taught you so far. Now let us go head and look at the integrities of how to take a random walk and then how to crawl on a network.
PAGE RANK: HOW DOES GOOGLE WORK? 05
Hello all, welcome to the programming screen cast of page rank I hope it is now clear to all of you what is page rank. Page rank is basically an algorithm that is used to wrap notes in a given graph. In this particular programming screen cast I will be telling you how can you find out page rank from random walk method using random walk method so first of all let me tell you what is random walk method. As the name suggests when you have to traverse the graph randomly it’s called the random walk. You pick any node from the graph randomly and look for its out links and traverse one of its out links randomly. Then you look for the out links of the present node and then traverse one of this out links randomly. In this way you traverse the whole graph if it is connected obviously so I will be giving you an example and it will become clear to you what is random walk so as you can see we have been given a graph here in which we have ABCDEF and G as the set of nodes. So first of all I will initialise the counter of each of the nodes so I have initialise the counter of each node as zero then I will pick a node randomly from the given set of nodes so I picked A here and I incremented its counter two then I look for neighbours of A, what are the neighbours of A? We have B we have F and we have G we have to pick a node randomly from the neighbours of A so we will pick the node randomly and we have selected F and we have implemented its counter two then we will look for the neighbours of F. What are the neighbours of F? We have G, we have E so we will pick a node randomly from the set of neighbours of F and increment its counter too we have picked E and we have incremented its counted too then what are the neighbours of E we have A, we have C, we have D now we have to pick a node randomly from this particular set, what is the set here? Set is A C and D will pick a node randomly and we have picked A and incremented its counter so now we have A two B zero C zero D zero E one F one G zero so what do you think here? Is this the final page rank? The values that we have mentioned here, no we have to keep iterating it this random walk method. We have keep re iterating it as many numbers of times as we can and at the end our page rank values will be same as the actual page rank values. so next we will look for the neighbours of A, so what are the neighbours of A we have again G we have F and we have B so we will pick a node randomly from this set so we have picked B and we have incremented it counter too then what are the neighbours of B we have only C as the neighbour as B so we will traverse C and increment its counter so we have traverse C and we have incremented its counter too then as you can see C is sink care what do I mean by sink? C has a sink care it has no outgoing edges so what we can do here? If we encounter sink in graph we will pick a node randomly from the given set of nodes so we will pick a node randomly from the given set of nodes. What is the set here ABCDEFG you can pick any node from the nodes of the graph so next we picked D here so D we picked D and we incremented its counter too then we will look for the neighbours for D. What are the neighbours? We only have C has neighbours of D so we will pick C and we increment its counter we picked C and we incremented its counter then we again came to C and it is a sink it has no outgoing edges so next we need to pick a node randomly from the set ABCDEFG so we picked F and we incremented its counter then we will look for the neighbour of F so what are the neighbours of F? We have E and we have G so next we picked G as the node and we incremented its counter too so in this way you keep on traversing the graph for many number of iterations and at the end the values we have
 
shown here will reflect the page rank values yes so how can you be sure of this method? Well will be simulating it will be implementing this and will be showing you that this random walk method actually reflects the right page rank values so let us move towards the programming screen cast of this page rank implementation and you will be getting the clear idea of how this method works in practice. Thank you.
PAGE RANK: HOW DOES GOOGLE WORK? 06
Before we move to the programming screen cast of page rank I will be telling you how can you draw graph using networkx. I hope you are familiar with the networkx library we have simulated in the joy sixth degrees of separation so if you haven’t gone through the videos of networkx I will recommend you to go through the videos of networkx first. So first of all let me show you how can you draw graph using networkx. As and always we will be importing the concerned library we will be importing networkx here so I will write import networkx as nx next I will showing you carious graphs that are available in networkx so first of all is the barbell graph so I will write nx dot barbell graph and in this you need to supply two parameters apply four and two we will be getting to know why I am supplying these two parameters here then I will write nx I should initialise the g variable here as this so that I can draw it barbell underscore graph and the two parameters now I will draw this graph nx dot draw G as you can see we have the two communities here we have two communities as which comprises of four nodes so in this particular community we have four nodes and in this particular community we have four nodes so next if I write four and three then what happens see, see we have four nodes here four nodes here and in between we have three nodes in this particular graph we wrote two and we had two nodes in between the two communities, so what does the first parameter represents here, it represents the number of nodes in the particular community and the second parameter represents the number of nodes in between the two communities so we will draw it again so you will get the clear idea of what is happening here so this time I will draw I will write five and three and then draw it so five nodes here five nodes here and in between we have three nodes and this is how barbell graphs works. Next I will be telling you some more graphs next will be drawing a complete graph so I will write G is equal to nx dot complete underscore graph and in this particular thing you need to supply what are the number of nodes so I will just supply four here let me draw it nx dot draw and G so I have a complete graph and it comprises of four nodes so those who don’t know what is the complete graph, in complete graph we have each node that is connected to its n minus one node for example if I pick this particular node it should be connected to rest of the three nodes so here I pick this node and it is connected to rest of the three nodes so basically it is connected to the rest of the node except the node itself that graph is called complete graph. So next basically it has every possible edge that can be present in the graph except the parallel edges and the self loads next we need to do I will show you how can you draw a cycle graph. I will write nx dot cycle graph and in this also I need to supply what are the what is the number of nodes here so I will write five let me show you next you write nx dot draw G. So we have a cycle of five nodes so what next there is another graph available in networkx that is ladder graph so I will write nx dot ladder underscore graph and you supply one parameter here and let us see what does this parameter do and nx dot draw capital G so we supplied five and we have five nodes on each of its parallel edges we have five nodes here and five nodes here in this way you can draw a ladder graph next is path graph so I will write G is equal to nx dot path underscore graph and supply the number of nodes present in this path graph I will say six nx dot draw capital G so you have a simple path comprising of six nodes then I will draw a star graph so what we will do? Will do nx dot star underscore graph and then I supplied a parameter here let us find out what does this parameter do. And then let
 
me draw this particular graph so since we supplied five here we have five nodes as the sink nodes I hope you know the what is sink, it doesn’t have any outgoing edge so there is a hub node at this centre of this star graph and we have five nodes as the outer sinks we as the outer nodes we have one two three four and five as the outer nodes and we have one sink so whatever parameter you supply here that becomes the outer nodes and there is one hub node so in this particular graph there will be n plus one there will be parameter plus one number of nodes so if I supply four here then there will be five nodes in the graph one will be hub node and the four node and there will be four outer nodes so let me draw it again so we have four outer nodes and we have one hub node here so what next we need to do here is, next is we can draw wheel graph also so I will just write G is equal to nx dot wheel underscore graph and you supply one parameter here again so you will draw this graph so we have wheel sort if thing it is basically four node graph and it looks like a complete graph also so it is a complete graph so we will do it five nodes and let us see what happens so in this particular thing we also have five nodes one two three four and five and we have one two three four five six seven and eight number of edges here so you can see that it basically doesn’t correspond to a complete graph it has a central node and it is connected to each of its nodes so let me do it for six graph or six node graph. So here also we have a central node and it is connected to its n minus one node so this is how wheel graph works then we also have some random graphs present networkx so let me show you one instance of random graph and will be using this random graph for our implementation in page rank so I will just write g is equal to gnp underscore random underscore graph and here I have first parameter as the total number of nodes for example I wrote five and then there is a parameter that is the probability of edge creation next parameter is the probability of edge creation I just wrote point five so with probability point five it will make an edge between two nodes and with probability point five it will not make edge between two nodes so the probability is equal. So next sorry I didn’t write nx here that’s why it is showing an error. So next I need to draw this particular graph so you can see we have five nodes here and it has drawn their edges randomly so let me draw it again it will show different graph because this is a random graph and it is making edges randomly so let me draw it again see now we have a completely different graph. So we will be using this particular graph for our implementation of random walk method in page rank. Thank you.
PAGE RANK: HOW DOES GOOGLE WORK? 07
Welcome again, all of you we have now come to the implementation part of random walk method so let us start. First of all as and always we will be importing some libraries so first of all let me import networkx import networkx as nx then will be importing random library we will also be importing matplotlib I order to visualise the graph so I will write import matplotlib dot pyplot as plt so I think now we are done with the importing libraries. So as and our previous programming screen cast I showed you how can you draw random graphs using networkx, so will be drawing that particular graph here so I will just write g is equal to nx dot gnp underscore random underscore graph and first parameter is number of nodes so I will take ten nodes here and I will also take the second parameter the second parameter is the probability of edge creation so I will take it has point five and then we also need a directed graph in page rank yes in very first video I explained that we need a directed graph for page rank so I will just write directed is equal to true since we need a directed graph. So next what you need to do, I will draw it and show you whether we are getting a directed graph or not. So nx dot draw g and plt dot show so let me run it. I will write random underscore walk dot py. As you can see we have a directed graph here we have a directed graph here we can see the arrows here but what I want more is I also want the labels of nodes to be visible so I just write with underscore labels is equal to true so that I can also get the labels on the particular node so let me run it again. So now we have labels visible also we have zero one till nine we have zero one till nine since we only passed ten has a parameter here. So ten is the total number of nodes here, so now we are done with drawing the graph here next what we need to do? As with the random walk method we will pick a node randomly from this set of nodes from zero to nine we will pick a node randomly so I will just take a variable here I will say x is equal to random dot choice. I hope that you know what random dot choice do it will pick a element randomly from a list so I need to pass the list here so I will write I for I in range what is the range here? G dot number of nodes, g dot number of nodes so this is the range here so we will pick a node randomly so I will just write a comment here x is the random source node since we have picked x here we also need to increment it counter but how will we store the counter? We will store the counter in a dictionary so what we need to do here? We need to initialise the dictionary here, I will use dict underscore counter is equal to curly braces this represent dictionary here. I also initialise the values of dictionary to zero so I will write for I in range g dot number number of nodes dict underscore counter I is equal to zero. Here what you need to do, g dot number of nodes in dict counter is equal to zero here. Since this is the method you need to pass you need to pass the round braces too. So I also need to implement the counter of source node so what is the source node here? We have x here dict counter x is equal to dict counter x plus one so we have incremented the counter too we have initialise the counter of each node as zero too. So for next what we need to do here, we need to look for the neighbours of x and then we need to traverse all of the graph this way. So I will be taking many numbers of iterations here so I will have a loop that will represent the iterations here so I will start with example for this graph and then what we need to do, we need to look for the neighbours of x. So I will just write I will take a list here list underscore n is equal to list of g dot neighbours of x. Now we need to check we also need to check here whether x is the sink or not here. If x is a sink then we need to select a node randomly from the given sets of nodes
 
from the given set of nodes present in the graph otherwise we need to otherwise we need to select a node randomly from the neighbours of x. I repeat if the given node is the same we need to select a node randomly from the nodes present in the graph otherwise we need to select a node randomly from the list of neighbours of x. So I will just write if length of list underscore n is equal to is equal to zero here then that means this is the sink here it has no neighbours. So I will write then x will be random dot choice again we have to select the neighbours we have to select x from g dot number of nodes. I write I for I in range g dot number of nodes. So we are also done with it, we have handled the case if x is the sink else what we will do? Will select a node randomly from the list of n so will say x is equal to random dot choice list of n list underscore n. Then we also increment the counter of the particular node so I will write dict of counter of x is equal to dict of counter x plus one. I also increment the counter here too dict of counter of x is equal to dict of counter of x plus one so I think we have ended all the cases, I will just write some comments here if x is a sink choose a node randomly from neighbours of x so I repeat this loop this particular loop first of all we are looking for the neighbours of the source node, our source node is x here if it has no source node that means if it is a sink then we will choose a node randomly from the given set of nodes of present in the graph. Otherwise we will choose a node randomly from the list of neighbours of given node ok so we have handled the cases here and we have also incremented the counter of our particular node if that particular node is traversed in the random walk method so now we are done with it so you must be thinking how can you verify that this particular random walk method reflects the exact page rank values well we have networkx to our rescue, we have a built in function in networkx that tells us what are the page rank values so I will be using that particular function and we will be verifying that the values returned by a networkx function and a values returned by our random walk method are same or not? So let us do that, what is the method used here? Page rank so I will just use p is equal to nx dot page rank this is the method that will be using and we will be passing our g graph here. So nx dot page rank is the method that will tell us the exact page rank values and I will print p here and I will also print the dict of counter here so I have to verify whether this values same or not. So I think we are done with it, done with the program let me run it. So we have the values here we have zero as the first node, yes zero then one then two then three four five let me see we have we haven’t sorted this values, we must sort this values so that we can get the clear idea the ranking of node given by the random walk method as well as the page rank method are same or not. This will be difficult for us for looking at these values so I will just sort this values here so I will just write, I will sort this dictionaries the dictionary p as well as the dictionary dict count. How can you sort the dictionaries based on the values it is very much do able in python so I will take two list two dictionaries here first one sorted p that is equal to sorted I will write p dot items and key is equal to item operator dot item getter one if oyu pass one here it will sort based on the values if you pass zero here and it will sort on the basis of the items on the basis of keys as we know in dict we have a key we have a value so it is your choice whether you want to sort the dictionary on the basis of the keys or on the basis of values since we have to sort the dictionary based on the page rank values so we will be passing one here and then again I will write sorted random walk is equal to sorted here we have dict counter as the dictionary dict counter dot items and we also will write key is equal to operator item getter one. Here I will print sorted p and here I will print sorted underscore

rw sorted underscore rw since we are using the operator library here we need to import operator two so I will just write import operator I hope we are now done with it and let me try to run it. We have the values here we have zero here and we have two here we have one here we have zero here so as you can see these values are not matching with the exact values so what you can do here is? We can always increase the number of iterations let me increase the number of iterations suppose I increased it to ten thousand let me run it again let me see we have two here by then we have eight here then we have one here we have one and eight here, here it is two eight one nine here it is two one eight nine and there are some discrepancies in these values also so let me again increase the counter suppose I increase it one lack, let me run it again so we have four here four here one here one here then again we have eight six here we have six eight here then we have two here then we have seven here three five zero nine three five zero nine so these values are matching to the exact values but there is still a discrepancy we have encountered that is here we have eight six here we have six eight so I will again increase the counter let me increase one zero here again so let me run it again so we have five nine eight we have five nine eight then four then six then three then one then zero seven two perfect! We have exact page rank values so you can see random walk method is effective to find the page rank values but you have to re iterate it many number of times so it depends on the size of the graph too you have to re iterate it again and again in order to get the exact page rank values the correct page rank values. So I hope that this method was correct to you guys I will explain you this method again. So first of all what we did we took a random graph a gnp random graph to start with and then we choose a node randomly we choose the source node randomly from the given set of nodes where we called it as x then we also initialise the counter of each node to zero and we incremented the counter of x since this is the source node and then we took a for loop in which we will re iterate many number of times this random walk method. First of all I took n in which we have the neighbours of x, list of n represents the neighbour of x and then we checked whether it is a sink or not? If it is a sink then we need to choose a node randomly from the nodes of the graph otherwise we need to choose a node randomly from the neighbours of x and side by side we are also incrementing the counter of the particular node if we traverse that particular node so increment the counter here of this node x and here also. So every time the node x is changing and this particular loop is iterating for many number of times and then we took the page rank method given by networkx so as to check whether page rank values given by the random walk method and the exact page rank values are same or not. And we sorted these two dictionaries based on the values so that we can get a clear idea what is happening here then we printing these two dictionaries so in this way you can find page rank using the random walk method. So my only suggestion is to iterate this method many number of times only then you can get the correct page rank values. I hope this programming screen cast was useful to you all, Happy learning.
PAGE RANK: HOW DOES GOOGLE WORK? 08
Hello guys, welcome to this programming screen cast on page rank using points distribution method so before getting into the points distribution method actually we will revise it some concepts from the previous weeks as well as we will see some pre requisites that would help you understand the points distribution method better. So will get started first will go with the revision so we had seen a data structure called graphs when we had seen the concept of six degree of separation using the facebook data set we had analysed that between two people what is the distance you can reach we had analysed there we had taken a data structure called graph through which the facebook the friendship network is modelled so we had seen about it. So while explaining about graphs I had taken railway networks as an example so here is a network that we had taken so the graph is nothing but the set of points and lines points are technically called as nodes and lines are technically called as edges. So in this railway network we had the cities of the railway stations the stations as nodes and there is an edge there is a line between the two nodes if there is a direct train from this city to that city. That’s how we had taken we had modelled and we had created the network created the graph so this is graph so nodes and edges are the terminologies I would like you guys to recall and another thing we had seen is neighbours, neighbours are nothing but what are all the nodes a particular node is connected to using an edge that’s what we call as a neighbour. For example if you take this node Kolkata the neighbours are guwahati, bengaluru and Chennai the node Chennai has two neighbours bengaluru and Kolkata so this is what you call as neighbours and whatever you have this network is an undirected graph that is there is no direction the edges are by directional we assume that is if there is a train from Chennai to bengaluru there is a another train from bengaluru to Chennai as that is an assumption we have that’s how our Indian railway network in major cities is that’s an assumption we had made but its not the case always that this kind of representation is enough to represent any data sometimes you may need to consider the directions as well. So we will see an example of such networks in this lecture as a new concept so such graphs are what we call as the directed graphs so here is a directed graph where directions of edges that is from which node to which node is the connection present this direction information also important in directed graph an example form real world that we can take is as I have given in this slide its email communication network. So here the nodes are different email id’s the different people of their email id’s and there is an edge from one node to another node if this email id has sent a mail to another one that is see in this network there are let us take a very small group there are three email id’s we have taken A B and C and generally we keep them anonymously that’s why we take toy example A B and C lets say there are some three nodes so the from this mail there is a mail that is sent to this mail id A to B there is an edge so person A has sent a mail to person B but it’s not necessary that person B should reply so that’s why we don’t have the back edge an edge from B to A whereas the mail he has sent to C, C has replied so if you have sent mail form this person to that person you have a directed edge direction denotes who has received the mail so from A B has received so there is an arrow towards B this is how email network communication network can be constructed. So the point to note here is you have directed edges the direction of edges is very important in this directed graphs and some other example that we can considered is maybe from the academics, the academy year I can say fightation
 
network we have something called fightation network where the nodes are the research paper and if one paper is sighting or it is refereeing to another research paper there will be a directed edge and as you could understand its not necessary that edge has to be bI directional say for example you may sight a paper that has been written in say two thousand five it is not necessary that, that paper authors should sight you back in some other papers or in that same paper so directed edge right so you understand the concept of directed edges this is from academy year and another example of social network just like facebook something involving people that could be something like you could have people as nodes and if this person likes another person, if a person A likes person B there is a directed edge from A to B so this person has expressed a liking for this person this could be used in for example matrimonial sites you can used it you can make analysis of matrimonial sites and you can suggests better recommendation and there are lot of applications which can be easily solved if you model the data as a graph especially as a directed graph this is one thing an example of social networks may be another example you want to give I may give from the marketing domain the marketing domain we have something called as supply chain network so basically the different companies are the nodes here and if this company supplies some materials to this company there is a directed edge so basically let us see this company B in that case company B is acquiring some raw materials from company A and it is making some products and it is selling those products it is supplying those products to company C something like this. So for example if B lets say battery if this company is manufacturing batteries the raw materials needed the electrolytes the lithium rods all those such raw materials it will acquire from different companies so they will be the incoming edges so it is acquiring the raw materials from different companies and once it has manufacture the batteries, the batteries may be of different requirement one you used it for your television remote the one for your clock the one for your car everything the batteries are different so this may manufacture batteries using this raw materials and the manufacture products are sold to different other companies so the car batteries should be sold to the major car companies and the clock batteries to the clock manufacturers and so on so this is how you can form a network using the different companies and the transaction they have such a network is called the supply chain network this would be a directed graph and I don’t think there will be a bi directional edge in supply chain network although I am not marketing expert this is just a little knowledge that I have but may be if you feel that there are some examples where there can be bi directional edge in a supply chain network also please do let us know in the discussion form. Like this yeah the motto here is to make you understand that there would be directed edged and what is the what directed edges signify in different networks we had taken one example of email communication network it can be watsapp communication someone has messaged you on watsapp there is a directed edge from that person to you, if you reply back you will get a back edge, if you don’t reply you won’t get back edge so that can be watsapp communication network, mail communication network anything a communication network in general or in academy you have sightation network and in marketing domain we have the supply chain network in case of social network you can consider it sort of matrimonial networks like which person has contacted which person based on that whether the person has replied back to his profile something like that. You can construct it as a network and you can perform analytics. Once you have modelled your data in the form of a graph data structure analytics is

very easy further so that’s why there are many applications where this graph data structure the directed graph especially comes very useful so will get into some terminologies of directed graphs as well so the edges we have right so we will have other names as well nodes as I had said as points and edges are lines is the layman terms other technical names can also be present that is nodes can also be called as vertices and edges can also be called as links I am just telling because in lectures we may use those terms interchangeably or may be if you look up to some material online some research papers or some text books you look up any where these two terms may be changed interchangeably nodes are vertices and edges are links they may be used interchangeably and let us see some terminologies so links are the edges in case of undirected graph they are bi directional so we just say they are the edges but here its directed graph so the direction matters so we will say incoming links and outgoing links incoming edged and outgoing links outgoing edges so for node in this graph if you considered for node A the incoming edges from C to A that’s why we have a tupple C comma A and the outgoing edge is from A, A to B and from A to C like this you can say the outgoing links and incoming links so the representation is source comma target, source is the starting point and target is the destination or the end point of that edge, an edge is resent between two nodes the starting points are called the source that will be given as the first item here and the end point of the edge is the target that is given as the second item of the tupple so like this edges will be denoted by tupples. This is the representation regarding directed graphs alright so I have started off with directed graphs I would like that you guys think of any other applications where this directed graphs can come handy that would be the thing I would expect you guys as a result of watching this video, you must thinking that direction and you will see further pre requisites in the upcoming parts.
PAGE RANK: HOW DOES GOOGLE WORK? 09
Alright guys, so in the previous videos you had been to introduced to the new data structure of the direct graph that is variant of the graph data structure called the directed graph where the direction of edges matter so let us get into the networkx the package for graphs and let us see what are the support it provides to deal with directed graph data structure. So let’s get into the python syntax and other cases let’s get started. So as the first step the package that supports the graph data structure operations is networkx that will be importing will do that, import networkx as nx so this is just a short name given that the networkx is a lengthier name so I am using a shorter name nx so I have imported it. So how did you create a undirected graph? If you want to create a new undirected graph, you would say let me say in directed graph so let me say u, u is nothing but you create a nx dot graph this would create a undirected graph right this was used to create a undirected graph in case you want to create a directed graph how would we do that? Let’s see let me say G is my graph I will create a nx dot DI graph is the command see observe that d is in caps and g is in caps di graphs is another terminology use to say directed graph. Directed graph di graph is a sort of acronym if you consider it as. DI graph d and g has to be in caps please observe this DI graph so DI graph directed graph object has been created so if you would want to know what are the nodes present in the graph that’s let us see g dot nodes, nodes see its empty node view is abstract data type it is using but we are comfortable with the list representation so given that it is using a different representation in python two if you are following the output of g dot nodes will be a list data type but in python three they have a different representation so we need to convert this into list representation so that it is easier for our programming purposes. So currently it is empty so there are no nodes so let us add a few nodes something like this G dot add nodes from add nodes from you have a thing so you need to pass a list as a parameter so a list where you enter the list id’s. Ok for example abcd whatever you want you want to give it as a list let me use numbers itself for the nodes. I see I want to create some three nodes zero one and two so I can say zero one and two what if I want to do for hundred nodes? Thousand nodes? If I want to increase, is it possible for me to manually enter all the numbers, no right so in that case what we can do is we can use for loop here and we can do it to demonstrate that even for this case as well I will use a for all and demonstrate for I in range how many nodes you wanted you just need to give that. Let me say I want some five nodes so I have given five so this is there so I want to add node number I for I in range five that is you iterate over the number line till you reach five so from zero it starts zero one two three four it will stop so all those whatever is the values that I has been taking I had said zero one two three four you append that to the list that is what this particular line means. This is one line way by which you can add a collections of nodes if you want to name them in the numbered fashion only so you can added it this way so please observe this g dot add nodes from you need to pass a list given that I want to number it sequentially I can use a for loop and get it done instead of enumerating those numbers manually this is how you have added the nodes now let me see what are the nodes now. See as I have said zero one two three four has been added so as I have said this representation the tupple sort of representation has not very friendly for us. List is friendly for us we can iterate over the list easily so we will convert it into a list. List of G dot nodes so yes see it has been converted into a list format. Zero one two three four has
 
been converted list format so what are the edges present in the graph. G dot edges you would see out edge view it says so in an undirected graph you can just say edges but in a directed graph if you just say edges it by default is taking out edge that is the outgoing edges so we need to mention in edges and out edges G dot out edges there are no outgoing edges and G dot in edges for incoming edges there are no incoming edges and as this is the different data type we wanted to be in a list format so we will be typecasting it into list bit given that currently we don’t have any edges so let us add a few edges and again will do it. So let me say G dot add edge you need to give the source and the target source is the starting point of your edge and target is the end pint of your edge. So if I say one comma two and edge it is a directed edge from node one to node two will be created, will be added into a network. So now if I see G dot edges so one comma two is the only edge I have so if I say in edges it’s also one comma two in case of out edges its one comma two so basically it doesn’t matter if you just say edges where this in edges and out edges terminology matters is if you give a particular node and say what are the incoming edges to this node. Or what are the outgoing edges from this node in that case this thing actually matters so let me say G dot out edges of let me say one let me save this see one comma two where as if I give G dot in edges of one its empty because there is no incoming edge to node one currently this is how this works so let me add few more edges and let us see add edge from zero comma three let us say let us say two comma three, let us say that this be a bidirectional edge three comma two as well let us add three comma four, four comma one please note that the order matters. You are giving the source the starting point as the first element and the target as the end point as the second element this order matters. Please note this as like in undirected graph you cannot give in any order please note four comma doesn’t mean that one comma four is present that is if there is an edge form node four to node one node one to node four there is an edge that doesn’t, you cannot guarantee that there will be an edge. So this is the specially of the directed graph as you could see now if I say as I have said list will converted into list given that it is easier for us G dot out edges of any node say for example let me say node two so this is an outgoing edge, let me say node three these are the outgoing edges, so from node three there are two outgoing edges one towards node two and one towards node four there are two outgoing edges so you have a list of tupples an edge is denoted by a tupple. List of tupples this is how you have the output of this particular function out edges. Please note this, this will be used in our programming screen cast, this functionality out edges we will be using it also if you want to find the incoming edges you can say in edges these are the incoming edges from zero you have incoming edge towards three and from two you have an incoming edge towards three these are the incoming edges so this is how you can see the outgoing edges and incoming edges. We convert it into list format because that is easier for us. Alright guys so we have seen some pre requisites some functionalities that are provided in networkx package to work with directed graph and what is so important about directed graph is that you have to again and again keep in mind is edges are directed an edge from node A to node B doesn’t mean that you have path from node B to node A as well. That is direct edge from node B to node A as well exist this is not guarantee that is if there is an edge from node A to node B there is no guarantee that you will have an edge from node B to node A this is key point from directed graph please do keep this in mind and will see about the algorithm of points distribution

method how do we do that and what is the procedure to be followed will see that in the upcoming parts.
PAGE RANK: HOW DOES GOOGLE WORK? 10
Alright guys, so in the previous videos we had seen about what is called the directed graphs and few terminologies and we have seen how we can use networkx package to work with directed graph so now in this lecture will get started with what is the points distribution method as the title says what is that actually is? What are we going to do? For this example let us take the same graph the same very simple graph with just three nodes for demonstration purposes while programming may be we take complex network as well. We can do that also will take a simple graph for demonstration purpose just this graph having three nodes will be taking this for demonstration and while programming we van have the complex network as well we can take that as an example. So let’s gets started so before starting I would just assume ask you to assume just ask you to assume that this is a network social network as you can say of people liking each other. So you can considered this as probably I have collected a data about your family and friends so this are your family members or friends the nodes are the people and this person likes this person the person A likes the person B in that case will have a directed edge from A to B this is how the network as been constructed. If you by if you would assume this way it would be easier for you if I explain the points distribution method so assume that this is our network a simple network, simple network having just three nodes just assume the network is there is a node between two people if person A likes person B there is a directed edge from person A to B so for demonstration purpose will be taking this simple network containing just three nodes while we are actually programming we can construct a complex network as well having many nodes and edges you can construct any network and you can run your algorithm on in. For demonstration purpose will take a very simple network so just assume that these nodes are people and there is a directed edge from person A to person B if person A likes person B something like that. So will gets started with the points distribution method. So initially all the nodes are given equal points so points you can also consider it as some gift items or gold coins anything some item is given to all the three people something equally has been given and they have been ask to play a sort of a game something like that the rule of this game is whatever you are having you should share it equally with all your out edges so we had collected the data of who all you like right so out edge is who all this A likes person B and person C person B likes just person C, person C just likes person A so this is the data right so you are suppose to share whatever you have to equally to all you like so that is the rule so you have to play the game. So initially they have equal number of points but due to this exchange of the points the next iteration the points may not be equal to all the three, the one thing is guarantee is the sum of points will be the same the initially let us say we have given some x points to each person so three x is the sum right? So the same three x the sum three x would be maintain throughout but the individual values each person is having will differ. So let us see, let us see node A node A has got two neighbours, by neighbours I mean those people to whom there is a outward edge that is person A lies these two people, person B and C so there are these are the neighbours. So given that there are two people you should divided into one by two since there are two people that’s why it’s one by two if there are three people it will be one by three if there are k people it will be one by k. You should partition your total points into that many fragments and you should be giving it too all those people, that is the rule for node A let us see for node B is
 
having you should give entirely to node C one by one so it’s one so you should give entirely to node C node and node C if you considered he just has one neighbours he just likes one person node A so whatever he is having he should give entirely to node A so I guess do you sense something that we have started with equal points each but even after just one exchange in this passion obeying this rule there is more points will be acquired by node C given that node A will also give something to him node C node B will also give something to him even that two people are giving he will acquire more something like that one node will acquire more one node will acquire less but the sum of the points will be the same that is the if you add up the points with A B and C initially whatever was the sum we started with equal number of points let us say x points to node A node B node C the sum is the addition of all these three values are three x same three x will be maintain after all this iteration like this you have to repeat this process for multiple number of times. So this is how you have to give so now a day’s giving to someone as well as getting to someone right so will see the getting details now. So node A will get something so that will be his new points initially if I give a equal number of points let us say hundred number of points for simplicity they were given hundred points each node A hundred node B had hundred and node C has got hundred so three hundred points total in the system so node each node has hundred points initially so following that rule they had to share their points along with their neighbour who the node when have to give it to his neighbours as well as get some points from someone who likes him, for example let’s say node B he like node C so he would give his points to node C as well as node A likes node B right so he will also give so node B will be getting something as well so each node will be giving something as well as getting something. So we will see what if gets that’s what I mean by new points initially everything was equal following this exchange rule they had exchanged their points and what is the new points. Node A will get everything from node C right so whatever was the old points of C that will entirely come to A that is the new points then for node B he will get half from A because A likes B and C so he has to as per the rule he has to share it equally with both the people right so he will get half of it so do you see that? Initially there was hundred points now even that he is getting just half of it now B will be settled with fifty points after this one exchange. Same like that for node C the new points is he will get half from node A as well as from B entirely he will be getting. So this is how the game has to played game where initially all the nodes were given equal points say hundred points and the points has to be exchanged between the parties following this rule that how many ever outgoing edges you have, how many ever points you have you should share it equally among all the people. So that is the rule following that they should play the game but if you keep playing this game if you keep doing it so after one iteration as I have said we can say iteration one exchanged one round after one round as we had said node A had some hundred points, node B had some fifty points as you could see, node C will be having fifty points if our math you can work out and you will get to know that so this is the status after one exchange. Now with this state there are again following the same rule and node A had hundred points so he will divide into fifty fifty node B had fifty he will give that fifty entirely they follow the same rule and they play this what happens if you play this for say some thousand iterations or ten thousand iterations if you keep doing this what happens? Let us see that in the next part.
PAGE RANK: HOW DOES GOOGLE WORK? 11
Alright guys, so in the previous videos you were introduced to the concept of directed graphs. You have seen how you can work with directed graph using your networkx package as well as I had introduced you to this game of points distribution. So we had seen the concepts. So let us see as I had said one snap you had done the calculation what happens if we keep repeating this? So let us first try simulating this in excel that is the spread sheet we will try simulating it because we are doing it for some thousand times manually if you do there is a possibility that after some iterations you may get some fractions as well so you may have some errors if you do it manually so let us use this spread sheet software and let us see what happens. Let me open new sheet, I am opening the new spread sheet so let us say we are starting with ok let us say we are starting with hundred points per a node we have the nodes a b and c let us use the same columns for ease of understanding we start with hundred points so I have given hundred points to all three of them and I have asked them to exchange based on the rule and after exchange what happens we had seen. What will be the new points that will be accumulated we have seen let us refresh once new points of A is nothing but old points of C just it will retain that so what is the new value here this is the time one let us say at time t is equal to one this is the values they are initially equal values all hundred points each so at time two what happens? What are the old points of C is what A will have so let me say equal to C one old points and so what for B what is the new points of B is? Half of the old points of A so I will say equal to old points of A is A one here divided by two, half that’s why I am dividing it ok so for C what is the new points? Half of old points of A plus old points of B because C is liked by both this people so it will get more points so half of old points of A and old points of B we have to add them up. Let us fill that formula half of old points of A I will say A one by two plus what is it whole points of B so its B one ok so as I have said it is hundred, fifty and one fifty so this calculation we have done it. What happens if we repeat it for further iterations? So in excel if you drag it the formula will get copied automatically it will get adjusted that is nice feature available in this software so will drag it and see what happens see these are the values after some ten iterations so it is hundred, fifty, one fifty so that one fifty came here half of it comes here so some kind of jugluary happens and that every point as I have said the sum will be constant. The sum is equal to let me give the space so tha you can understand this is the points and this is the statistics we are calculating let us see we are calculating the sum equal to A one plus B one plus C one ok this is the sum so I need to copy the same formula here as well see the individual points the distribution differs but the sum of the three values remains constant so this is something similar to your law of conservation of energy in your physics, energy can neither be created nor be destroyed it will keep getting transferred from one form to another form right so something like that the points are neither created nor destroyed that keeps getting transferred from one party to other party in the system that’s what is happening in this game so we have done this for ten iterations right so let us further extend it let say for some twenty iterations what happens? So some values have occurred so let u stake this let us even see the sum see the sum remains constant with irrespective of whatever is the distribution here among the three items the sum remains constant factor twenty some sort of convergence that is occurring that is by convergence I mean between the previous one and the next one there is no much difference or it exactly
 
remains the same that is what I mean by convergence let us see what happens when do we get convergence let us now fast forward and let us I mean we had check by ten iterations right first we check for the first ten then we check for the twenty and we keep on checking like this know so let us check for lot of iterations so let us some ok so I have checked for some another fifteen iterations so it appears to converge but here its one nineteen point nine nine and one twenty point something fifty nine point nine nine nine one twenty it appear to converge. Ok let us further extend let us see what happens ok. Let us further extent let us see what happens. Let me say I am extending till one forty see here there is an exact convergence one twenty, one twenty, sixty, sixty, one twenty one twenty and it will remains the same irrespective here after how many ever times you repeat it remains the same let us see where this first convergence has occurred so at the sixty sixth iterations it was one twenty sixty six one twenty sort of a stable state has been reached, sixty seven the same sixty eight the same after that how many ever you repeat the same points distribution is preserved and of you want to see the sum let us extend and see let us extend and see here let us extend and see the sum alright so till here see the sum of three hundred from the beginning till the end and after sum the exchange of points keep happening to see we initially began hundred hundred hundred equally the three hundred points were equally distributed to the three parties they were asked to exchange as per the rules so the points after one exchange changed after another exchange there is further change in points in so that keep kept on shuffling the distribution kept on changing but irrespective of distribution sum always remain constant so you can see that the property that has to be observed and this convergence factor is used in your page rank algorithm so we had simulated this using the spread sheet so let us now get into the programming part and simulate it using our python programming skills. This will be done in the next part.
PAGE RANK: HOW DOES GOOGLE WORK? 12
Alright guys, so in the previous videos you had seen what are the directed graph? How can you work using networkx packages in python and how can you deal with directed graph in networkx also we have seen points distribution method, what is the procedure in which you play and how would you distribute your points, how would you share your points with your neighbours also we have seen a simulation in excel spread sheet that if you keep repeating for multiple iterations the values converge that is the difference between this iterations and previous operations will be either insignificant or there is no different at all that difference is highly negligible in that case we say the values converge. So we will now see simulation using python so will get started. The first step what you have to do is, you need to create a directed graph so let’s do that. So how would you create a directed graph? For that we need networkx package let us import that first import networkx as nx so we have imported it so let us now go ahead with creating the directed graph, how would we do that? G is the graph object is equal to nx dot DI graph DI graph this is how you create a directed graph. So we have created it this is the empty directed graph so the next step is you should add the nodes so let us do it G dot add nodes from yes so will have to pass the list so let us say we need some ten nodes we have taken a some small example of three node graph in a demonstration now let us take a slightly bigger graph ten node graph may be you can say hundred node, thousand node graph you can just keep extending the same thing to larger number of nodes with the complex graph you can keep doing that. So let me now give the demo with the ten node graph so I am going to insert ten node from zero one two three till nine so using a for loop single line way as we have seen in the pre requisites portion of this lecture series we will be doing that so it is nothing but it just a I for I in range how many number of nodes you wanted you just need to give, I am going to do with the ten node graph so let me do it ten oh ten nodes from zero till nine had been added to the graph so the nodes have created so now we need to add some edges so let me say add edges so I need to add edges and get back to new graph with edges that is rently we just have nodes and no edges so I need to add edges and get new structure as graph G let me say G would be my new graph I have to add edges that’s what I have to do. I have created a graph object I have added the nodes now I have to add the edges so undefined name add edges it says that means I have used this name but I have to define what this actually is so let me go ahead and do that let me say define add edges so first add edges what do you need? Between two nodes there will be an edge right so we need to get the list of we need to access the nodes frequently so will take the list of nodes so let me say nodes is equal to list of G dot nodes so we got the list of nodes now I need a source node let me say S for source for S from nodes and I need to pick a target node let me say T for target from nodes list I have picked it also I should see source and target must be two different nodes if it is a same node it will be a it will be like telling I like myself every one like them self so capturing this information is actually waste of space something like that so will not do that generally that’s what we call as loop in graph theoretical terms so we don’t prefer loops generally that’s what we call as a simple graph we are going to construct a simple graph where there is no loops so we need to see that if these are two different nodes so I am going to perform a check here if s if not equal to p only then I will think if I have to add and edge or not so if I just like that keep adding an edge what happens this loop will run
 
for all possible paths and what you get is a complete graph I don’t want a complete graph I want graph to be randomly generated so randomly generating I have to go ahead with this package random so let me import it import random so I have imported it so I am going to randomly add an edge so how could I randomly add an edge so I can simulate it with a coin toss so I may say that I just pick two nodes two different nodes if they are two different nodes what I will do? I have picked a node s I have picked a node t source and target so s and t I have picked two nodes if they are two different nodes what they have to do, I will toss a coin if I get a head I will put an edge otherwise I won’t put an edge if a toss an if you toss an coin what is the probability? What is the chance that you get the head? One by two right because head or tail right two possibilities one of the possibility is head which is your decided thing so one by two this is zero point five is the probability of your head so I am going to simulate the coin task if I get a head I will put an edge otherwise I won’t put an edge so let me say I am going to toss a coin that is nothing but I am going to generate a random number that’s what I am going to simulate so let me say r be my random number going to generate random dot random what does this do? It will generated a random number in the range zero and one so let me take zero point five that is the probability for my head right so I will say if this random number r is within zero point five I consider that I have got a head otherwise I will say I have got a tail this is how I am going to simulate the coin task process so if this r is within point five less than or equal to zero point five what do I do? I consider it as a head, so if there is a head yes I have to add an edge right so I will add an edge g got add an edge from source to target so I have added an edge so I will do this for all possible pair of nodes and whatever is the resulting graph I am returning the resulting graph I will return graph G after adding the edges based on coin toss so coin toss is a random process if you toss a coin you get a head or you get a tail so based on that if you draw an edge you will get an random graph every time so you can experiment what happens instead of having the faced structure you get a different structure every time and you experiment what happens whether there is convergence with or any structure you an experiment it and there will be convergence you need to run for sufficient iterations may be ten node graph so I suppose maximum some ten thousand iterations definitely there will be convergence so why do I say this concretely because there are some mathematical results which say that there will be convergence in any structure so just a intuition that I could give you is just a hint is same probability is a hint you can del deep into it if you are interested there are mathematical results there are proofs which states that definitely there will be convergence if you keep repeating this procedure so you can simulate it so for example I had taken as hundred hundred hundred each right initially all nodes where having hundred points that is how I had taken so I can instead of giving hundred points if there are some k people I can give one by k each the sum turns out to be one so this is one thing in probability right the individual probability is may be anything but the sum of all the probability will be sum up to one right so you consider it like that and you can think of it has probabilistic model and you can prove that its slightly rigorous the mathematical part but its not very difficult actually you can understand it all that you need to know is some amount of probability if you are good with probability you can look up to what the mathematical proof is and you will get to know that definitely whatever be the graph structure whatever be the initial configuration initial we are starting with equal even if you start with unequal configuration it will converge probably the number of iteration it takes to

converge may differ but it will definitely converge so that is the mathematical result so you can experimentally verify this with different random graph you run it once you will get a graph you can verify whether there is convergence similarly you can run it again again again you can run it in you will get different graph every time you can verify whether there is convergence as per that mathematical result there should be convergence let us see what happens ok. so we have added the edges we have added the nodes we have added the edges now what should you do we should visualise the graph visualise the graph to plot the graph and visualise it what do I need? I need this package matplotlib so let me import it import matplotlib dot plyplot as plt shorter form so let me say matplotlib pyplot I have imported so what should I do? We should first draw the network so I will say nx dot draw the graph G and anything have a labels, labels are nothing but the entries of the node that is this is node one this is node two this is node five so I need the labels so I will say with labels equal to true I will save this so you will get the graph draw with the labels and now I have to show the drawn graph I will say plt dot show ok done so what we have done till now we have created a directed graph we have added a few nodes added some edges we have added edges randomly simulating a coin task and we are going to visualise the graph that’s what we are done till now ok lets go ahead run this and see what happens. Let me run it see some graph got generated some network is there if I run some other one more time I will get another network another time get another network some other network some other network so every time you are getting a random network so on this you can run your distribution method and you can check whether there is convergence. As I have said there is a mathematical result its says there will be convergence irrespective of whatever is your initial distribution initially however you distribute the points and as well as how whatever is the structure for your graph irrespective of that you will have convergence there is a mathematical result let us verify that in the upcoming parts of the video. That’s why we are generating random graph so if you run this iteration you will have a different output some other iteration you may have different output so we are basically experimenting it so for different structures how is the behaviour we are basically experimenting that’s what we will be going to do. So will do this in the upcoming parts of the lecture.
PAGE RANK: HOW DOES GOOGLE WORK? 13
Alright guys, so in the previous videos we had seen what is a directed graph how can we work using networkx and what is point distribution method we had simulated that in an excel sheet with an small network with a small graph with just three nodes we juts simulated now we are proceeding towards checking what happens in a complex network having lots of nodes ad edges so the first step we had created directed graph we have added a few nodes and edges were added randomly simulating a coin task now we had visualise the graph as well this is what we done till now now will get started with the points distribution procedure so let me get started the first step is you have to assign initial point right initial points that is a first step that you have to do let so do it so let me say assign points let me call and once I assign the points I need to have a list of points right so this node zero has got these many points node one got these many points and so on I need a list of points so let me say let me call that as points so I will assign points so to assign points I need to assign it to for each node eight so I need the graph. From the graph I will keep each node and I will assign points to the nodes so I need this and you could see the warning undefined name so we need to define this is so let us define it here define assign points and we use the graph G and so we have assign the points so first as I have said for each node we need to assign it so let me first get the list of nodes nothing but list of G dot nodes so let me get the list of nodes and now I have to assign it assign the points so I need a array points let me say P I need a list so for each in nodes so for each node I have to append how many points? We have started with hundred initially right so let us do that same. Append hundred and once all the nodes has been assign the points you return this array P so we had assign the points so what have we done? We take the graph G and assign points to each nodes and we get back the points so we take the graph G we take the list of all nodes for each nodes we are assigning hundred points initially that’s what I am doing I am assigning hundred points hundred points I am assigning initially this is not the hardern part through that you have to assign hundred only you can experiment with different initial value this is the seed value you can say, you can experiment with different seed values as well we I have said you can model it as probability you can say one by number of nodes you initialise it you can see what happens you can try different things so let in this demonstration let us take hundred as the seed value. We have hundred nodes we can have different seed values with different seed values the final convergence values would be different but one thing would be the same for example we had taken in our demonstration we had done with our excel sheet we had taken hundred hundred hundred each for each node so three hundred at the end it convergence state it was one twenty sixty one twenty that I remember it may be something like this instead of having hundred initially I had taken ten the values may be different if I had taken twenty five the values may be different but one thing that is same is if you take the fraction one twenty divided by the total three hundred and sixty divided by three hundred, one twenty divided by three hundred that is point four point two point eight this is same something like that even if you take twenty five twenty five twenty five at the end if you take it the individual point divided by seventy five the total you will get the same thing point four, point two, point four that distribution is maintain so that is why I had given a hint you can modulate as a probability problem c the final sum is one if you model it if you getting the distribution is constant so you can modulate as a probability
 
problem and you can mathematically you can go rigorously and prove that definitely there will be convergence irrespective of whatever be the structure of the graph whatever be the initial stage you start with. It’s not necessary that you have to start with equal, equally hundred each that’s even not necessary you can even start with ten points for one node five hundred points for another node three hundred pints for some other node you can start with the any configuration. At the end you will reach the stable state, stable state there was one twenty sixty given that we started with hundred hundred hundred or in terms of scale down to one version that is point four point two point four that was the stability state. Something like that every graph has got a stability state that is the mathematical result so ok let us come back we have assigned the points and now the next step is we should keep distributing keep distributing the points so if you keep distributing the points you would get some final points let me call it as final points the converged points you can call it as the converged points you will be getting you will get the final points by keep on distributing distributing the points along the nodes of graph G so ok again I got a warning undefined name so I need to define it so let me define let me copy and define it here let me define it define this and let me say so I have to distribute the points among the nodes for that again I need the list of nodes let me say nodes is nothing but the list of G dot nodes I need to get the list of nodes I have got it now I have to kick so we have started with the definition of keep distributing functionality so I have to start keep on distributing as I said keep distributing so it is an infinite loop so let me start an infinite loop so if it is an infinite loop when will we stop it’s our wish right so excel even when we stimulate if I wanted I can drag it till one lack iterations you can drag it as you wish so I am going to give the control to the user when he decides to stop that will be the time he will stop. So I am going to give the control so till then it will be an infinite loop so what should I do? I will get I have to distribute the points to the nodes of the graphs from this intial points configuration initially we have equal points that’s the configuration we are starting with and we have to take that configuration and distribute as per our rule ok so if you distribute the points you will get a new set of points in the next iteration. So let me call that as new points it will be my new points so once I get my new points I need to print my new points what are my new points? I have printed so once this new points have been obtained you have to take this as your initial configuration and repeat the procedure the next procedure. How would I do that? I have to say my points will be nothing but my new points so basically what you will do? You get some initial configuration you distribute it as per your procedure after distribution you get some new configuration the new points oh! Take that as your base configuration I am repeating in iteration two iteration one values as your base values in iteration three you will take iterations two values as your base value right? so that’s what we are going to do so that’s why we are doing this assignment now you have to decide whether to stop or not so let me say stop I will say is nothing but I am going to get an input from the user let me say I will take some key from the key board press hash to stop or any other key to continue, you can have any key I have just taken hash randomly you can have percentage symbols but you can have anything you can have anything that’s not hard and fast thing you can have anything. So I say you have to press hash as long as user presses hash they have to continue if you want to continue you have to press some other key. If you want to stop you press hash that is the rule I am defining for the user so I will get the input now given that user has given the input I need to process it if these stop value is equal to hash then

what should I do? I should break; I should come out of the loop alright so once I have broken so user wanted to stop. Whatever is the value of new points that will be my final points so I need to return it so I will return new points right once I come out of the loop whatever is the values of new points I will return it back so I keep distributing it so what have we done here? We have assign equal points initially now plus another it has to be equal we had done equal you can try a different variable as well as I have said. You assign randomly some values then you see you can use a random generator again for example from one to five hundred you pick a random value and assign that as point to the node and you can try different things. We have started with the equal configuration. And after that after you have assign you keep distributing the points so in keep distributing what are we doing we have to we have to distribute the points and as a result of this distribution you will get a new configuration you will print that configuration and take that configuration as your base and repeat that you repeat that as long as the user doesn’t want to stop as long as the user wants keep repeating it, if he wants to stop he will stop in that place you return whatever is the new points whatever is the last configuration you have got so you return that ok. So here we have undefined name distribution points, yes we have to define it we see distribution point what is the procedure to distribute? Will have to define it, we will do it in the next part.
PAGE RANK: HOW DOES GOOGLE WORK? 14
Alright guys, so in the previous videos we had seen what is a directed graph how can we work in networkx and then we had seen what is points distribution method, we had simulated it with small network with just three nodes in excel sheet now we had started with the programming part. We had created a network we had visualised it we are creating a random network simulating coin tosses, we had visualised that network then we had initialised the points equally some seed values we had initialised all the nodes we are getting equal points first at the first stage then we have to keep distributing under keep distributing we need to now define how to distribute the points actually so we will do that now. So let me define it define distribute points on a given graph on a given point configuration so let me distribute so as and always we need the list of nodes to operate so let me get the list of nodes list of G dot nodes alright so before starting initially every node has given something to its neighbours so it will have nothing so let me say new points are initially zero right so I need to assign tit so let me say or I in range length of nodes that is how many number of nodes are present length of nodes in n o d e s ok so for that we need a list as well right so let me say new points so let me create a list new points let me say new points new points to append zero why zero? Because the node has given everything to his neighbours and it has nothing. That is the state then we will that’s how we had even introduced in the slides right so the node will give its to neighbours that’s it the next stage we considered what is it getting from? If everyone is giving, someone has to get so what is that it’s getting is the next consideration so first the giving part so this is the giving part so we have to keep appending the zero value because it has given everything it has nothing so this is your new point so now let us say for n, n for node let me say n in nodes I take a node n and say out for out edges so we have to see the out edges and we have to share it with the outward edges right so I am taking the list of out edges list of G dot out edges and you need to give the node id it is n basically so I gave it so how will this appear? List of tuppples an edges represented by a tupples source comma target something like that list of tupples we will get so if this is an empty list what happens, it need not share anything with anyone it will just keep getting whatever it was having previously so we will handle that case here if length of this list out is equal to zero meaning that it has no outgoing edges then it will just keep getting the same points what it had got in the previous iteration right so I should say the new points for this particular node n is nothing bit new points of that node n previously plus whatever is the points it had in the previous iteration previous value of points whatever was the initial configuration will again retain so it will it had got some for example say it had got some ten points again it will get some ten points it may not share with any one even that there is no outgoing edges if there are outgoing edges you need to share, if there are no outgoing edges it will again get some ten points, if ten iterations again ten points it keeps accumulating so that accusation thing we have handled here right? ok so if this is not the case its having some outgoing edges then it has to share some points so let me say share it has to share how much? How should it share? It has to share equally among all of its neighbours, how many neighbours are present? That is given by length of this out so how many outgoing edges? It has to share it equally so whatever is the points it has been having you have to divide it equally among all the outgoing edges so that is the procedure so we have got the value of share and so this is the value of share so this
 
much it has to give the whole it has to give, it has to give to the target nodes in the outgoing edges list right so that we will see so for the items in this outgoing list. What is formats of the items in the outgoing list? Source comma target right so this is of the format source comma target that is how the items in the outgoing list are for each of this in outgoing list your source will be the same list n right target differs so we will take the target value and we will work on it so the new points of target target is nothing but whatever it has earlier plus what is the share it is receiving from this node n so why do we having this new points plus share why do we have this? Because for example we had one node where it will half from I guess from node C half from node A and fully from node B so it had different shares so when you run the loop with node A you would have given half when you again run it with node B what happens is, if you just say it is equal to share the previous share whatever it has got from node A that value will get destroy. We need to retain that as well as this that is why we are adding it ok so this is how the new points calculated ok once everything is done what you do? You return your new points right so this is how the distributions occurs just let us see once this part so we get the list of nodes we have new points initially it is zero given that we have all given whatever they have nothing so given that they have given something has to be someone has to be there to get so each node will get some share as well so we are going to see the getting part now. What happens? We are taking a node n and then we are seeing the outgoing edges so to the outgoing edges only it would have shared so the outgoing edges the target nodes will get the share will get the new points if there is no outgoing edge what happens is? The nodes will keep accumulating the same points in this iterations as well, so that is why I am adding the same points again no if that is not the case there are outgoing edges it has to share it so it will equally share the points it ahs with all the neighbours so this share has to be given to the neighbours so it is of the form source and target that is how you get the list of edges so to all the target nodes you have to increase this share you have to give this share to the target nodes that is what we are doing the target nodes will get the value of share along with that whatever it has got and why we are doing this addition because a node may get different share from different nodes to account that we are doing this addition so once you have computed it for all the nodes you can reform the list of new points. So that is how single time distribution occurs so this is distributing just for one iteration. So in this keep distributing function you are repeatedly calling the distribution functionality and you keep repeating the process again and again till the user stops alright I hope you are now clear with the procedure may be you can take a pause and you can think what we have done in the previous parts what we have simulated in the excel sheets, what is the procedure we have explained, you think you give a pause you will understand it really well. So ok let me clear the screen here actually I will do it fresh ok so this screen is clear here so let me run it let me run so I have got some values initially it was hundred now I have got something hundred and thirty five, hundred and three nine, ninety eight something I have got it so it’s asking me if I have to stop or I have to continue, I want to continue so let me press some other key I prefer enter key it has continued continue continue continue continue continue continue like keep continuing after some time did you see here the values here as well as here there is no much difference I guess it has almost converged so there is convergence so I can up here lets press hash yeah it has stopped so as you could see we had some graph structure you can see some random graph structure is here so I had done distribution once and this is a result of

distribution once and it is asking me if I want to continue or stop I had continued for lot of iterations and at the end I found there is convergence right? see the values here its one thirty six point eight nine eight five, one thirty six point eight nine eight five there is no much difference so it has started converging so once it converges after that whatever be the number of times you repeat it the same values will remain so given that I had hit the convergence I stop that’s what I have done now so this is how we have checked the values of points after repeatedly distributing it now we have to run the nodes based on the points it has accumulated so for example forty five is the minimum value so this node gets the least rank and one thirty six is the highest value so this node gets the highest rank something like that so I have to rank the nodes so basically you can considered as marks so initially I am giving hundred marks to people and there are playing the game and distributing it and at the end whoever has got maximum marks whoever got minimum marks I have to sort the nodes I have to compare the result with the actual page rank procedure that is implemented in networkx I have to compare that result and so that we will be doing in the next part of the video.
PAGE RANK: HOW DOES GOOGLE WORK? 15
Alright guys, in the previous videos we had seen what is a directed graph. how can we work with networkx and directed graph and what is points distribution methods and how do we, we have simulated it with excel sheet and there was for a small network and now we had started off with the programming part complex network having lots of nodes and edges. We had created a random network we had visualised it we had initially given equal points to all the nodes and we had started the game and we had asked the nodes to distribute the points based on their outgoing edges based on structure they keep distributing and we decide when to stop this game. Just because in excel we have that flexibility we can drag the calculations as long as we want so something like that same like that I want to give the control to the user that’s why we had done it something like that but the user will decide when to stop, whenever the user stops just it will just say it is the final values something we had got it right so now what should we do once you get the final values you should wrap the nodes based on those values and next step would be compare it with the actual page rank values that is provided by the built in functionality in netwotkx we will do that so after they are done distributing we got the final points so I have to what should I do rank by points right I have to rank the nodes by points so let me say rank by points let me call it so to rank the nodes by points what do I need? I want to final points so I want this so I have to rank the nodes by points. Ok as you could see it undefined name see it is the warning message that is given so later define it let u define it ok define this thing and let me see how shall we start with it so we have decide this functionality rank by points so first thing is if you just like that we have points is nothing but list right so if we sort the list its simple and you just rank it that’s what you are saying but if you sort the list you will lose the information as to this point belongs to which node so here we need to keep track of two information which node has got how many points it’s not just about how many points it’s about which node has got how many points so we have to convert this list structure into a dictionary structure we have to convert the list structure into a dictionary structure and this dictionary structure will be applying the sort functionality that is defined on dictionaries and this will be using to display the rank of the nodes based o n the points they have accumulated alright so as I said I need a dictionary let me say d so I have to have the node the points are actually arranged in the same order know zero point is the zeroth element of this list node ones point is the first element of the list something like that, that’s how it has been arrange so let me it’s just enough for loop one for a loop over I in range length of points so whatever is the index that is the node ideas as well in our case length of final points basically final points or may be even we can call it as a points as well so there it was final points and even here you can call it as points so for I in range length of points that is I am going to iterate over the list I am going to convert it into a dictionary, dictionary with keyIthelistindexiswhatIamgoingtomakeitas keysothatissameasnodeidrightsoI am going to make it as a key is nothing the corresponding value of points at that index. So I have created the dictionary now I should sort this dictionary to sort the dictionary we have built in functionality sorted you need to pass the items of the dictionary and here dictionary has too things keys and value we need to sorted based on the value part right so for that you need to say key equal to lambda so key here is nothing but based on what value you need to do, what is the factor based on which you need to sort. That is what you call as key and
 
lambda is built in functionality in python basically it like for example alphabetical order ascending order attendance order or whatever you can call it as how would you do it? Based on the first letter you will sort the names A comes on the beginning then comes B then comes C so on. What if you have different demand? You want to sort it based on the last letter, so in that case you have to make use of custom function that you are actually going to write based on that function you have to sort on your requirement something like that if you have some other factor that you are defining and based on that factor you want sorting to happen you will use this kind of a syntax. And lambda because I am not going to define a new requirement that is not present in python this sort by value is a common requirement so python has defined it so it will say the upper f let me call it f nothing but at f at index one so key is at index zero and value is at index one so this lambda functionality sort of converts it into a tupple format and it will take the value at index one and it will sort based on it so this is the defined functionality that has been defined in python itself in case you want it an new requirement here you can say key equal to my function and based on that function it will sort so what is the factor I should considered for sorting that is what is denoted by this key ok so my factor is nothing but I wanted to be based on the first index value that is based on the value of points I want the sorting to take place the relationship between the node id and the points is also preferred and sorting also occurs so this is the specialty so if once it is sorted it will return a tupple of list of tupples basically so I need to print it so I will print this value so even that I have sorted and printed so the ranking part is done. So what should I do now? Once I have ranked let me compare it with the default networkx function I am going to use that and I am going to compare that results. So the default function of networkx is nx dot page rank and you have to pass the graph and it will return a dictionary basically. So that’s why we had also used a dictionary right we had why dictionary? Because you need reserve you have to actually preserve the fact that this node has this many points you have to preserve that fact. So let u say this is the result of your page rank result and dictionary nx dot page rank do G just you need to give the value of page rank these things maximum number of iterations how many iterations you want you can customise it you can do it as per your demands but even you don’t give there are some default values they would be taken and it would be calculated so we got the resultant that the dictionary and same like this I have to sort and print the sorted values. Right? So let me copy paste this lines so let me just copy and paste it so I will copy given that I have copied let me paste the line here and instead of B it is the name of my dictionary is result so I have taken a dictionary and based on the values I want the sorting to occur that is based on the points accumulated I want the sorting to occur so just a quick recap and then we proceed with running. So we had seen till distribution of points the output even is displayed here so before proceeding further I will clear the screen and I will run so the output is as well displayed here it gets converged to some specific distribution we have seen at till there and once we have got the convergence state we have to rank the node this is the points for the node zero this is for node one, node two and so on so we have to rank the nodes based on it just keep this is the list if you just apply sort on list the fact that this node had this points is lost that’s why we will convert it into dictionary as you could see here we are converting the list into dictionary preserving the fact that this node has this many points and we are applying this built in functionality sorted on dictionary and this is the functionality that take care of sorting based on a given parameter based on the pints

value we want to sort it so we are using that built in functionality just that to preserve the part of his node has these many points you are using the this many data structure you are converting the list into dictionary. Also we have done this for our method points distribution method and once it is done we are going to compare it with the default networkx functionality page rank that will also return the dictionary and we are applying the same sorting mechanism and we are displaying the sorted result we will see how is the result we get after the points distribution method and what is that built in result that is obtained will see how it is same or different or what is the thing that is the node that is ranked as number one here it is the same built in as well let us see all those things before running let me clear the screen and let me run for you let me run now so as I have got the some network some distribution will continue continue continue continue continue I keep continuing I keep continuing yes I guess I got a convergence see because I was saying these two values are failure there is convergence there is convergence here let me press hash to stop ok I have got convergence here ok so this is the value we have got based on the points distribution method node seven is the least rank node and node six is the highest rank node node seven and node six yeah same we are getting we are getting different values here because as I have said take a different seed value the final value will be different but as I have said if you take the this particular value by sum of all these values if you find the distribution will be same that is here if you take this particular value twelve point something by three hundred if you take the particular fraction if you take the fraction that will be same for both the things you can verify it this built in functionality is using some other methodology also I hope you have seen or you will be seeing another method of random walk to get the page rank values so it is using random walk and some other methodologies and some other seed values it is built in functionality is doing so the values may differ but the ranking if you see node seven is the least rank node node six is the highest rank node that I preserved not only that the ordering is exactly preserved as you could see, seven four zero eight seven four zero eight ok two nine one three five six two nine one three five six wow this is exactly matching so good it is but our method of point distribution the built in page rank method exactly matches as I say whatever be the network structure there is a convergence state there is a convergence configuration this is mathematical proof that you can take it as an advance material from this lecture. You can look it up some amount of probability is the pre requisite for the mathematical part you can look it up as an advance material from the its very required if you are interested and if you are key person and math oriented person highly enthuastic with maths you can look it up requisites are probability theory that’s it you can look it up and see to it, it will always converge there is a vigorous mathematical proof for it. Alright guys I hope you enjoyed this. Activity on page rank using point’s distribution method, thanks for watching have a nice day.
PAGE RANK: HOW DOES GOOGLE WORK? 16
Hello all, welcome again to yet another programming screen cast on page rank as you all saw in the previous videos we performed an activity in this particular activity people were asked to choose their leader so now we have their data with us we have the data in the form of edges as you all know we need a directed graph in order to calculate page rank so will be creating a directed graph out of this data. First of all let me explain this data, we have this data in the form of edges. If we have one two that is there is an edge from one to two, if we have one space three that means we have an edge form one to three in the same way we have the data in the form of edge list. You can see the rest of the edges so now out task is to make a graph out of this edges so how can you make a graph out of this using python where this is also very much possible and very very very easy in python so let me show you how can you create a graph out of this data. As an always you need to import networkx first so I will just import networkx as nx then you also need to import matplotlib library so I will just write matplotlib dot pylot as plt after that you need to write just one function in order to read the data, yes in order to read the data you just need to write a function of networkx what that function is? I will just write G is equal to nx dot read underscore edge list and in this particular bracket you need to pass the path of your data file so I have stored the data in the txt file in a dot txt file so I will just write the path of this file I will write it’s in users simran setia list of my file name is page underscore rank dot txt apart from the apart from the path that you need to supply here you also need to write r here apart from the path that you need to supply you also need to supply two more parameters here first is create underscore using it describes whether you directed graph simple graph so since we need the directed graph I will write nx dot DI graph and after this I need to node type node type is int here so I will just write node type is equal to int since we have anonymised the nodes here we had the data in the form of the names of the different people but we have anonimised the data now we have the detain the form of numbers, in the form of numbers we have one two three till around twenty five so we have read the graph from the txt file now we just need to draw this graph how can you draw the graph simple nx dot draw capital G and you also need to pass with labels is equal to true since we need to show the labels I just write with labels is equal to true and then we just write plt dot show so I think this is done let me run this program. So as you can see we have a graph here the graph that has been read from the txt file ok so this is fairly simple in python you can easily read the data and draw a graph out of that data so the functions that you need to use here is G is equal read underscore edge list what you need to write here is you have to initialised graph variable G is equal to nx dot read edge list first of all you need to supply the path of your particular txt file after that you need to supply whether you want to draw a directed graph or simple graph then you also need to supply the node type here and we had nodes in the form of one two three so we supply node type is equal to int here so when you run it you can easily see your graph so as you can see this is simply fair in python you can try that and I will now your task is you run page rank algorithm on this particular graph and tell us who was the leader of the group. So I hope that this programming screen cast was useful to all of you thank you.
COLLATZ CONJECTURE
So now you people have seen may questions many answers a lot of programming and now I am going to teach you one of the smallest programs ever taught to you in this course but one of the most complicated of all course in fact the world still doesn’t have an answer for this two line code it’s a smile while condition and a if condition that’s it. You will see that the code gets done in less than quarter page but the world still doesn’t know an answer to it. So what’s the question? The question is very simple, input any number n if the number n is even make it into half if the number is ten make it five ok if it’s even that is, if it’s even make it by two if it’s odd let say if it was eleven if it’s odd shoot that number up by three and plus one which is if an its eleven make it three into eleven thirty three plus one thirty four simple if it’s even reduce it by half, if it’s odd increase it by three times the number and add one to it that is the way we start with n equals seven so seven becomes into three twenty one plus one twenty two, twenty two is a is an even number so you should half it so twenty two becomes eleven, eleven becomes think about it into three plus one thirty four I will be slightly fast now, thirty four becomes seventeen why? You are halving it ok seventeen becomes three n plus one three times seventeen fifty one plus one fifty two, fifty two becomes twenty six twenty six becomes thirteen, thirteen becomes thirty nine plus one forty, forty becomes twenty, twenty is even it becomes ten, ten is even becomes five, five is odd becomes sixteen, sixteen becomes eight and then eight becomes four, four becomes two, two is even so half of that is one, one is odd so into three plus one is four again we saw four already so whenever you get four it becomes two, two becomes one and one again becomes four you see this is an infinite loop so what we do is we say while the number is greater than one you do this, do what? If the number is even make it become half the number is odd make it become three times that number plus one so seven had how many numbers? Count one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty steps right seven to twenty steps let us take some number big number like two fifty six how many steps it will take let us count. Two fifty six is even half of that is one twenty eight, one twenty eight is even half of that is sixty four even again thirty two even again sixteen wow even once again eight even again four even again two and that then becomes one, one is odd so one becomes four into three plus one four and four becomes two and two becomes one and you enter you stop here you see a small number like seven took a such a long number of steps a number of two fifty six how many steps did it take? Let me count one two three four five six seven eight nine steps as supposed to more than fifteen steps for seven correct so smaller the umber doesn’t mean smaller steps, bigger the number doesn’t mean bigger steps in fact this piece of code is so not understood given an n when will it stop? We still don’t know right this is famously called the three n plus one problem Google for it there is a lot of references for this three n plus one problem also called the Collatz conjecture in fact we don’t even know whether this will ever stop for some input it might keep going on and on it may never hit four two one four two one in both the cases you saw it four two one but it needed four two one you see Google for it read lot about it and know when someone comes and gives you long program and says he has done something very complicated give that person simple code like this and ask him to analyse what is happening that will be a big goggle for him will not really converge to a nice answer on what exactly happening here ok
 
that was fun looking at question that is smallest possessive we have given you very very very big programs that work and very very small program like this that even the world doesn’t know how to answer so programming world is very huge very interesting very fascinating sky is the limit I hope you people have enjoyed the lectures given to you so for so we are ending this course with a quick code on collatz conjecture.
COLLATZ CONJECTURE 02
HI guys, in this video will see the programming part of collatz conjecture this is the last screen cast of week twelve and last screen cast of me also so it has been a nice journey let’s see the last program it’s a very simple program of collatz conjecture. Let me review the conjecture once again so what you have to do so given a number n you have to every time you have to check whether if n is even number then you divide it by two that means that n becomes n by two and if it is an odd number then you have to do n is equal to three n plus one. so you repeat it every time until and unless until n becomes one and the point you have to check whether is it possible to make any number one using these methods so this was the conjecture actually we can see it through a program whether can we do it with a any number or not so I will create a definition in python and you can supply any number as an argument to this function and you can check whether we can achieve one or not. So let’s see this so I told you I will create a definition so let me write it here ok ok so my definition name will be check numb an argument is number numb let say ok I will check how many iterations I want so for that I will keep a variable iterations so as initially as one now what I have to check every time I have to do two operations one is if n is an even number then I have to reduce it divide it by two and if it is a odd number then I have to make it three n plus one until it becomes one so my check some should be check should be let me put the while loop while numb is not equal to one until it doesn’t become one I have to do this operations every time ok so until numb doesn’t become one is not equal to one I will check first if numb is a numb mode two is equal equal to zero which means that I am checking whether it fully divides this number fully divides by two or not if it fully divides then it means it is even number so what I have to do if it is an even number then numb my number becomes number I can write like this also numb divide by two and I just make it as an integer because you know when you divide a number it becomes a floating point number it doesn’t matter here but still ok and yeah since it is an even number it will divide by two and I will just make my iteration plus one iterations is plus equal to one and if it is not an even number then what I have to do numb is equal to numb into three plus one isn’t it and again I will I will increase my iterations value by one ok ok after this it means the loop has been executed successfully after that I will just print my number what is my numb after all these iterations and what are my how many iterations it took to become one off course it will print one just to take check if numb is becoming one or not and this iteration will tell me who many iteration it took to finally reach one of my definition is complete so I will just run it check numb let say twelve great let’s just run it. Ok you can see the output one and ten it becomes one it is becoming one after ten iterations let me put twenty let’s see it is becoming one after fight iterations see you can check various numbers and see whether yeah it is becoming one after eleven iterations so this is it this was the program there is nothing much to do it was the very basic program to show you how the conjecture behave actually you can read about the conjecture online and so this program was just to show you their limitation of computing also it has been a nice journey with you guys in joy of computing course we hope we will meet again in some other course lets see this thank you every one. Have a nice day.
 