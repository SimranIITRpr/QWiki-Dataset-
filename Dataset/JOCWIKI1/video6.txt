Substitution Cipher – The Science Of Secrecy
So this is what our next joy is all about, what happen? Didn’t get it! Now? Yes! Our next choice is about CIPHERS.
Substitution Cipher The science of secrecy 01
This is personally the most exciting idea throughout the course at least according to me, we are going to talk about the science of secrecy. If you know what that means let me illustrate this with an example. Assume Romeo and Juliet they want to communicate with each other secretly how would they go about communicating? Assume Romeo wants to send this long a letter to Juliet then he suspects someone in between, may probably tamper with the letter and then see what is written, he wants only Juliet to read it. In case someone else gets hold of the letter they can of course read it but it should not make sense to them. How would he ensure that he encrypts the letter? A very simple method goes as follows. So this is the letter Romeo wants to write for his sweetheart Juliet as you can see it’s a love letter, so what he does he firstly writes the letter and then shifts every single alphabet by five units so which means A becomes F, B becomes G and so on so from A to Z this is what happens to the letters and this particular letter that Romeo want to send to Juliet takes this form and now the letter finally looks something like this and Romeo sends it to his beloved Juliet and Juliet gets this and knows what exactly Romeo has done to his original letter basically they have communicated about this protocol before and what Juliet done has the following as you would have guessed obviously she shifts it back five units which means she makes F A G becomes B and so on and there you are she gets the original letter, you see the shift being five is the secret key here it can be five between Romeo Juliet and laila and majnu it can be fifteen now, what if someone gets to know that the method used by the lovers is simply shifting it by some units and mediator comes and catches hold of the letter communicated by this boy friend to his girl friend can he break his code? So this middle man comes and catches hold of the letter sent by our boy to his girl, he knows that the idea here is shifting every single letter by few units so what he does is try all possible shifts, he first tries one shift and tries to see if the text makes sense or not, so whatever you are seeing right now let us take this three lines text as the letter that the boy writes to his girl and then it is shifted by some units that the middle man doesn’t know but he wants to crack it. So he tries assigning A to B, B to C, C to D by that I mean he assumes it to be one shift and tries to see if the text that generated makes sense or not as you can see it is not making sense and he tries a two shift and then a three shift and then a four and then a five and then a six and than a seven and finally when he does eight he sees that the shift is actually making sense completely all the words are English words and hence he concludes that the shift this boy is using happens to be eight and there he is, he has deciphered the encrypted text with his little intelligence so what do you infer from this? Such a method is used between two people to communicate can be broken easily by a mediator a middle man, if he knows provided that the technique used is shifting but he doesn’t know by what units it being shifted so what he does? He tries all possible shifts; from shift one to shift twenty five twenty six and so on tight? One of them should give him valid English text once he gets the valid English text he concludes he has decrypted the secret. What we saw just now is called the popularly the Caesar cipher in the literature of cryptography. A very well know
  
technique which is not being used mainly because of its simplicity and the fact that anyone can break it, now I am going to teach you a technique which is a little more complicated rather a lot more complicated than what I explain just now the Caesar cipher I am going to tell something else which is lot more complicated, which appears as though nobody can break this. Here is a lot more complicated way of encrypting a given text and here is how it goes. You take every single English letter and assign a complicated symbol to it and a Romeo writes along a letter for his Juliet and simply takes every single letter, every single symbol and instead of using the English alphabet letters he uses the corresponding symbols that is agreed between Romeo and Juliet now according to what I just now illustrated A stand for this symbol, B stand for this symbol and so on up to Z and Romeo converts his letter his love letter to something as complicated looking as this, now its look like it going to be impossible for anybody to crack this isn’t it? Who on earth knows what letter is map to what letter right? This looks like a perfect way of communicating. Or is it, is there a way to break even this cipher? Let us take a break and let me tell you all a nice story, a story that looks completely unrelated to what we are talking but is very related. There was this mom who had ten sons all of different heights and one day the sons trying a prank on their mom they wore masks disguising themselves and they come in front of their mom and then challenge her to identify who is who? All ten sons they appear in front of her like this and say mom identify us, they say that in chorus and mom is perplexed because she cannot see the faces of her sons but then I told you something there are all of different heights, so do you think it will be difficult for the mom to identify who is who? All ten sons are masked and they appear in front of their mom and say mom identify us? Hoping that they are they will make the mom perplexed and that she will not able to identify them, little do they know that mom can identify her sons just by identifying their heights she knows that the shortest is this, the second shortest is this, third is this so on and the tallest who is this and she goes on in no time calling out their names, patting on their back one at a time she says athri, brugu, kuthra, vashista, gowthama, kashyapa, angerasa, rama, bheema, shaama over all ten names right? What exactly did she used to identify them, just their heights and what’s the moral? The moral is that despite the fact that sons concealed their identity with their mask, mother used some other parameter. So what’s the moral of the story, why the story am it’s are encryption decryption theory? Do you see a connection? Well there indeed is a connection and this is the connection. You can try to conceal the letters in the form of symbols but then you see English speaks out aloud, what do I mean by this? English has a very peculiar statistical property, sounds complicated? Nothing at all. It I just I just mean the following, the most frequently occurring word letter in English always happens to be this, isn’t this a beautiful idea? Its sounds as though it’s impossible for anyone to decode a substitution of the letters of the English alphabet with some random symbols, its look like it’s impossible to break this code but you see how English speaks out aloud and anybody can very easily decrypt the text. The seemingly looking seemingly complicated looking technique has a huge loop whole in fact it is as easy as a previous one that we discussed. So this subject is called cryptography where the idea is all about making ciphers and also breaking it, almost every single technique that has come about the history is broken and the ones that is currently in place I believe are just in the status of yet to be broken, so the science of secrecy is all about making and breaking the codes, it is reached than what I illustrated just now I invite you all to read more of it I will give you some

references to good books for the same you can go ahead and read more of what makes cryptography.
Substitution Cipher The science of secrecy 02
The professor just now explained a method to share your messages secretly, so let me try to show you how can you share your messages in a secret way. Hello every one before we start doing the programme for substitution cipher I would like to explain the concept in python name string. First of all what is a string? String is used to represent text in python; text may comprise of spaces, numbers and even alphabets. So how can you use string here, for that first of all you need to import a library called string. Now take a variable named x and I would initialised it to a string for example it is hello world, please note the fact that every time you initialise a string you have to close the string in double quotes, you have to close a string in double quotes. So here we have the string called “hello world” and if you want to excess a particular alphabet in the string x, what you can do here is, you can excess the particular alphabet in “hello world” by giving it a particular number. For example if I want to excess ‘H’ in “hello world” I would write print x of zero as you know the indexing start from zero in arrays as well as in strings so if I want to excess the alphabet H in “hello world” what will start from zero so ‘H’ is at zeroth position so I would write print ‘x’ of zero, so here we have h and for example if I want to excess the alphabet ‘O’ here, ‘O’ has two occurrences so if I want to excess the alphabet ‘O’ in the first position that is, how can you do it? ‘H’ is at zeroth position, ‘e’ is at first position, ‘n’ is at second, second l is at third position and that ‘O’ is at fourth position, since ‘O’ is at fourth position I will write x of four and now let us see what is the output, here we have ‘O’ so this is how you can excess the alphabets at particular position in a string ok. There are many other functions available in string for example if I want to excess the alphabets from second position to fifth position, how can you do that? You can actually do it in one go without even using for loop or any kind of loop so I will just say ‘x’ of two colon five and I will just print, it prints llo, this is how you can excess the alphabets in particular range of positions ok now if I want to know if I want to get the length of the string so for that you have a function what you need to do is, you will write Len and then Len and in bracket write the name of the string, here we have ‘x’ so we will write ‘x’ so let us print it so it is eleven, you can clearly see that the length of string ‘x’ is eleven, now if I want to convert the string in upper case there is straight away a function available in python what you can do here is, you just write the name of the string that is ‘x’ and then dot and then you have to write upper, upper is a function available in python used to convert the available string in upper case so now let us see what is the output, for that we should print it, print ‘x’ dot upper yes it converts the string or string “hello world” to upper world to upper case. So we are done with the strings now there is one more function available in python in fact there are many more functions but here I would like to explain you one more for example in “hello world” if I want to replace one alphabet by some other alphabet how can you do that? I will just write ‘x’ dot replace for example I have to replace ‘h’ with the ‘j’ so I will just write, replace ‘h’ in double quotes comma then ‘j’ in double quotes so now the output is “jello
  
world” instead of hello world so this is about strings in python now we will do the programme for substitution cipher and will use strings there.
Substitution Cipher The science of secrecy 03
So let us try to code substitution cipher here, for substitution cipher we have an input file here named ip underscore file, it has some text I need to convert this text in such a way so that it is not recognise by the third person for that I will be using substitution cipher so for that I need a string of alphabets in which I can substitute the letters, python provide with the string named string dot ascii underscore letters I will print it so I will write print string dot ascii underscore letters as you can see we have the letters in lower case as well as in the upper case so I will be substituting this string in such a way so that it is not recognise the text present in our input file is not recognise by the third person I will be using this particular string for that so in order to execute the substitution part I will write import string after that I will initialise a dictionary called dict, I hope that you are already familiar with dictionaries, strings as well as file handlings because will be using all three of them in this particular programme and if you are not familiar with these concepts I would suggest you to go though the previous videos, please go through the previous videos and then watch this programming screen cast. Now we have dictionary named dict is equal to dict is equal to curly braces this is how we initialise a dictionary, for converting this particular string to a substituted format I will write for I in range length string dot ascii underscore letters. In this particular dictionary if any letter is at ith position I will be substituting it by I minus one position, position letter it’s your choice by with which letter you want to substitute a particular letter here if I am substituting a letter given letter by its them by the previous letter so we will have here, ‘A’ will be substituted by ‘Z’, ‘B’ would be substituted by ‘A’, ‘C’ would be substituted by ‘B’, ‘B’ would be substituted by ‘C’. This is how our dictionary is going to work, so I will write string dot ascii letters, string dot ascii underscore letters at ith position will be substituted by string dot ascii underscore letters at I minus one position here I used minus one you can even use plus one, plus two, even minus two minus three it’s your wish I am substituting it my minus oneth letter so that you can tip your get idea of how our programming is working, it would be easy to observe this particular dictionary so I will just print dictionary here so that so you can get the idea of what is happening over here. So here we have the dictionary as you can see capital ‘z’ is ‘A’ substituted by capital ‘Z’, ‘B’ is substituted by ‘A’, ‘C’ is substituted by ‘B’, ‘D’ is substituted by ‘C’ this is how our substitution is working, so we have all the substitution in this particular dictionary named dict, now we will use this dictionary dict to convert our input file. For that first of all we need to open our input file named ip underscore file so I will write with open ip underscore file dot txt as f then I will write while true I need to read this file by character by character and I need to substitute a particular character according to the dictionary so I will take a variable here named ‘C’, ‘C’ is equal to f dot read now I need to check one or two things here first of all I will be checking whether we have encounter end of file or not, for that I will write if not ‘c’, if the if the file pointer hasn’t encounter any character that means it has reached end of file, so in this particular case we will print end of file and it will break out of this file loop and if ‘c’ if the file pointer has encounter a ‘c’ which
  
is already present in the dictionary, if ‘C’ in dict in that particular case I will take a string here name data, please initialise the string data here, how can you do that? You can initialise through double quotes so we have initialise our string data, data is equal to dict of ‘C’, if ‘C’ is present in dictionary in that particular case data will be equal to dict of ‘C’ and if ‘C’ is not present in the dictionary then we can’t do anything will just write data is equal to ‘C’ instead of dict of ‘C’, please note the fact that in our dictionary dict only alphabets are present, in lower case as well as upper case and if in our file some if in our file some integers zero to nine or some special symbols are present that will not be substituted so here is an exercise for you, if you encounter a file with some special symbols and integers how can you apply substitution factor on that particular file its an exercise to you, its left to you how can you do that? So here we have the string data which has the substituted file, which has a substituted data so I will just print it. I will just write print data let us try to print this. So now we have the data, but the data is exactly like the input file so there is some error in our programme, here if we are reading the file we need to supply a bullion value here so I will just supply one and try to read it here we have the substituted file so here is the mistake, when we are reading the file when we need to supply some bullion value here one here. So as you can see that it has substituted our input file and this is something we can’t read and we can’t recognise ok so what will I do here is, I will store this output in a file, you can get a clear cut idea of the substitution happening over here so I will take another file here named file is equal to open op underscore file dot txt and I will open this file in writing mode since we need to write it, and what next we need to do here is I need to write this particular string data in our file so I will just write here file dot write under curly braces we will write data ok after we are done with the writing part I will close this file I will write file dot close round braces so now let us try to run this programme again so here we have the substitute text let us open the file output file or op underscore op underscore file as you can see here we have the data in the substituted form this is something we can’t recognise we can’t figure out that this text was actually this and we have substituted it by using substitution cipher so now we are done with the programme, I will go through the program again. First of all there is a string present in python name string dot ascii underscore letters we use this string for the substitution part here we are substituting the letters present in the string by I minus oneth letter, here we have for that we are using dictionary we have initialise the dictionary here in dict after that we are executing the substitution part in this particular part we are writing dict string dot ascii underscore letters at ith position will be substituted by I minus oneth letter this is how we are doing the substitution please note that dict dictionary has dictionaries have keys and value in this particular dictionary keys are the letters present in the string and the values are the substitute letters I repeat keys are the values present in the string and values are the substitute letters, after that we are opening our file our input file and we are reading a character by character for that we need to supply a bullion variable here one as to read the file character by character then we are checking some conditions here first condition we are checking here is whether we have encounter the end of file or not, if we have encountered end of file in that particular case our programme will print end of file and it will break out of this loop and we are checking if the particular character present in the input file is actually present in our dictionary, if it is not present then it will then it will only write this ‘C’ in data otherwise if it is present it will write dict of ‘C’ the substituted letter in the data. At the end we are writing

this string data in output in an output file so that we can get the clear cut idea of how the substitution is working and then we are printing the data and finally we are closing the file. So as you can see here we have two files here this is the output file and this is the input file, here the in input file you can read the text but in output file the output file is converted to some other text using the substitution cipher which is not recognised which can’t be recognised by the third person until and unless he gets to know that the substitution cipher is used here so this is how you quote for substitution cipher and convert many more text, I hope this programming screen cast was useful to you guys. Happy learning.
TIC TAC TOE – DOWN THE MEMORY LANE
Do you remember this? Do you remember this? And this? Yes. And next choice is about TIC TAC TOE.
 TIC TAC TOE – DOWN THE MEMORY LANE 01
That was such a good time we used to play a lot of games in our childhood, I was just going through some of my old books, my rough note book would look like this when you scan it from back. I guess most of you are getting these nostalgic memories on seeing this, this is the famous game called tic tac toe which we all used to play in our childhood we love playing it such a enjoyable it’s such a good memories we are re living it this feels so great so in this lecture series I would take you down your memory lane you all shall re live your childhood days, the fun way through computing. That were good old memories we all had almost played this game in our childhood for those who want to re live those memorable days I would start with the rules of the game, the game is something like this, there is a three cross three board which is nothing but board containing three rows and three columns that is a total of nine cells. There are two players who are involved in this game each player is given a symbol, one is given a symbol ‘X’, one is given a symbol ‘O’ they are suppose to alternate their turns, during their turns the player is expected to occupy a vacant slot in the board, when they alternate their turns the one who is able to occupy three slots such that the three slots come in one single row or the three single slots come in one single column or they occur along this diagonal or this diagonal or one of the diagonal, the one who is able to do this first is considered the winner, this is how the game goes if no one is able to occupy their positions in such a manner then it is declare a draw no one wins, this is how the game goes, I hope most of you had gone back to your childhood days, if you would observe the rules of the game this is much more than you playing established your victory. This is much more than that the planning the thinking involved requires a lot of envision ability you need to envision what would be your move as well as what would be the move your opponent make given his next turn, you have to envision both, you would play such that, you increase your chances you maximise your chances of winning as well as the you minimise the chances that your opponent wins this is how the intelligent player would play this game, so when both players play intelligently the game would mostly be a draw. This particular strategy where you want to maximise the chances of your winning and minimise the chances of opponents winning is called the min max strategy this is min max strategy which is a very famous game strategy and all such min max games are too thrilling and given that this joy of computing course we would now see how we shall play this game in the fun way using computers.
Tic Tac Toe – Down The Memory Lane 02
Hello guys, welcome to the programming screen cast of tic tac toe, we had some discussion about the game which we played in our childhood namely the tic tac toe. It has the three cross three board that is nothing but the board consisting of three rows and three columns that is the nine cells, so according to us that is three rows that is row one row two row three, column one column two column three that is how we count but computers count in a different way, let me show you see this is how the index is done in a computer for a board sort of structure this is nothing but matrix basically this is a matrix for a computer that is 2d array that is the two dimensions, there are two dimensions namely the rows and the columns so it’s the 2d array this is how the computers represent the board has that is how they interpret the board as see the counting starts from zero, zero one two that is how it counts we count as one two three so please note that if we say second row second column then it is first row first column for the computers so that is whatever is our count you subtract one from it then you will get the count as per the computer perspective this is how we have to we have to take care of the perspectives of humans and computers, first I would like to tell you this regarding the indexing part ok now let’s get started with the game, basically let me just give you a brief overview here let me give you see this is three cross three board that is the board containing three rows and three columns so players there are two players in this game each players is given a symbol one is given a symbol ‘X’ one is given a symbol ‘O’, they have to initially the board is fully empty we have to place their symbols in one of this vacant positions in the board, this is how the game goes suppose player one places here next time player two cannot occupy the same position he has to occupy the vacant position something like that the game goes and if you would see the players who occupies consecutive three cells along any of the rows or any of these columns or along this diagonals or this diagonal is consider to be the winner. That is the player who is able to first occupy three consecutive cells in this manner is the winner, in case no one is able to do then it is a draw so here as I had discussed in the lecture the game is not just about your moves, it is about your ability to predict how your opponent will play so every player will play keeping in mind that he has to maximise his chances of winning and minimise the chances of opponents winning for example let me just give you overview it is better if you could have a pen and paper draw a board because for indexing purposes I have taken this particular image, but plane board be a beneficial but no problem you please take a paper and draw this kind of grid and follow my instructions and based on that you can understand so this is basically an empty board initially so the first player comes places his symbol here, why this place? Because along this diagonal or rows or columns any way at least one of this ways he has to occupy three consecutive positions only then he can win maximise his chances of winning this particular position one comma one for the computer and second row second column for humans this particular position is intersection of many of the winning possibilities, along this diagonal along this diagonal row this column along four of the winning possibilities there are three columns three rows two diagonals among eight winning possibilities on four of the wining possibilities, this particular cell is present so smart player would start playing this position to maximise his chances of
 
winning. So this will be the first players move so the second player when he gets the move in the next turn he would want to maximise his chances of winning also to block him from the winning that is to minimise his chances he wants to block him from winning so here if you have a ‘X’ so he would like to block one of the four wining possibilities for him so maybe he can place his coin somewhere here so that this row possibility has been block now given that this row possibility has been block in the next turn if the player ‘X’ places his coin here it is a waste so he would place his coin somewhere here so now if you have seen till now here you have ‘X’ here you have ‘O’ here you have ‘X’ so if somehow this is now ‘O’s turn if somehow in the next turn ‘X’ could be placed here ‘X’ would be the winner ‘O’ thinks in that way if I miss this particular location next time ‘X’ will place his coin here and he would be the winner so he would place his coin ‘O’ here to block his winning opportunity I guess now you have understood what the strategy the players would be using they would want to maximise their chance of winning as well as they would like to minimise the chance of the opponent winning if both the players are smart this try dry running some any sequence of run if try dry running just think that both the players are equally smart it would be a draw. In case if at some point of time the player losses the foresightedness he doesn’t think of his opponent in some point of time suppose assume that in this particular instance ‘O’ doesn’t place his coin here he places somewhere here the next turn when it for ‘X’, ‘X’ would place his coin here than thinking of blocking O it is beneficial for him to place his coin and win, so your aim will be both, more priority to your winning at the same time not a minimum priority to defeating your opponent, you have to minimise his chance of winning, you have to block him as much as possible as well as increase your chances of occupying three consecutive cells so that you can win so this is how the game goes as I have recommended if you had taken a blank sheet of paper and dry run how the game would go just play the game without using a computer, just try you would understand how the game is played, what kind of smartness is required from the player for the game and so on so this is how the game goes so let us now start coding now ok so as I had said it is a 2d array the board is the 2d array for the computer so that arrays has been defined in a package called num py let me import it import numpy, I had import it so let me call it as board that is the name easier for me so let me call it as board I would say numpy numpy dot array, array of we need an array of three rows and three columns, we need to give it as a list and within the list each row as to be a separate list so you have blanks initially so for blanks I am representing it as hyphens that it is a blank cell that is what I mean by hyphens here so I have three columns in each row so three hyphens I would be giving so all these three or blanks sorry for this first row has been given now the second row so let me give ok second row is over now the third row ok first column of the third row, second column of the third row then third column of the third row so all three rows has been defined ok now for player one the symbol I allocate is X I had told it is ‘X’ for player two I allocate the symbol O so that is what I had defined here player one symbol player one symbol for symbol I am using ‘X’ player one symbol is ‘X’ player two symbol is ‘O’ so now let me start the game let me say play. As we would have seen till now just saying play serve the purpose because it is something we are defining see you got a morning symbol it is an undefined name so we have to give the proper definition as to what as to be done when you say play so let me define it define play ok give colon here so here start the function definition. So every particular turn, turn has to be alternated the first turn if it is given for ‘X’

second turn must be given for ‘O’ so how many turns would be given totally? It is three cross three grid that is there are nine cells so there will be nine turns so let me say for I will use a for loop because I need to repeat it nine times turn I use intuitive name so that it is easier to understand turn in the range you would have seen this syntax till now this is how you use for loop for a pre defined number of times, I wanted nine times so let me say nine for turn till the range of nine what you do is, it start from zero till eight it will count so zero two four six all these turns should correspond to player ‘X’ that then one three five seven that is even turns is for player x and odd turns is for player ‘O’ so how do we capture this? Using the modulo operator let’s do that. So I will use if turn modulo two is equal to zero that is if it is an even turn you should say it is the turn of ‘X’ let me print ‘X’ turn so this is turn of ‘X’ ok so you should allow him to place his symbol on the board so let me call place player one symbol and then after he places his symbol initial two moves if you would have observed the winning possibility from the fifth move only but still this single loop will be running for all the turns so let us include this check here but it will not be used in the initial stages but in the subsequent stages it would be needed that is as soon as there is a winning move, that is if there is some vacant slot still not that is all nine slots have not been occupied but still there is there was a winning move then the game has to stop so for that let me say you have to if won let me use terminology like this if one if someone this player one symbol this person has won then break that is you should quit the game this is nothing but we are quitting the game else so this is for player ‘X’ we had done else that is the turn is odd turn so all these things we would copy we would do this for player two whose symbol is ‘O’ so I had used ‘O’ player two symbol and if player two symbol this particular thing has won we have to check that is why do we check this? As you would have seen in this dry run during the fifth turn there is a possibility that one player can win that is from fifth turn any turn anyone can win there are good amount of possibilities that there can be a winning move so if that particular move if he has placed it in some position and if that placement is a winning placement then you should quit the game that is why we are using this so far so good this are intuitiveness so I guess you can understand it that is you have to repeat this things nine times that is because of the nine cells present in the board, if for every even number turn this is for ‘X’ and odd numbered is for O allow the player to place his symbol into the into a vacant slot in the board check if that is a winning placement quit this is what we have done till now. Ok as you could see here, see these are undefined names place and won so let me defined that here now ok define place so we have used p one s p two s let me say symbol it is a common terminology player one symbol player two symbol whatever this is be the it is a symbol so I had said that ok so first what should I do? Print the board so since it is a matrix that is I have to display it in the rows and columns format for that we have a predefined functionality to convert it into this is in the list format we need to convert it into rows and columns format for this we have a predefined functionality let us use it numpy dot matrix there is a functionality here numpy dot matrix within in that you have to pass the name of the variable here it is board that is it will take the value of the board in list format convert it into the row and column format and print it that is a purpose of this functionality ok we will print the board then we have to say we have to get the input for in which particular row that is how does it, what does it signify if I is, you are saying that you should allow him to place his coin where would he place? In some particular cell that is identified by the row number and the column number so row get the value input

from the user row is an integer so let me type cast it initially its easier now ok, row I should get an input this is actually dependency on Mac system that’s it in Linux systems as much as I have used this particular type casting thing is needed these are all some trivial things depends on your operating systems in case you are using some other systems and there is some other requirement you can always Google it and get back the correct method as per your system this I am doing it with respect to the Mac system ok so I had type casted I am taking the input so I should say enter your rowth position enter row what are the values for rows that is allowed? One or two or three these are the allowed rows ok that is as per the humans perspective I told you counting that starts from zero why why is it that we are giving one two three here because this is as per the human perspective you are familiar with computers so you can understand this indexing mechanism but where as if you would ask this must be designed so that anyone can play the game so for human perspective the counting starts from one that’s why we are giving like this then adjust it in the upcoming steps so you get the input and copy paste ok column so I should say enter column column one or two or three so I had said that this is the value you have to input it but what if the person has inputted a row and column that is already occupied or what if by some type of mistake or something he has inputted a value that is out of range of the board we have to handle it, all these we are doing it to ensure that your programme is robots and fault tolerance that is whatever be the fault that may be occurring due to the users input it must be handle your programme, your programme must be able to handle it we should not say that it is your mistake we should be able to handle it as much as possible that is one of the principle in software engineering that you have to make your systems friendly and fault tolerant that is if user commit some mistake even your software may be able to handle it you must be able to display him some polite nice message that this is the reason why this cannot be accepted please try again with the valid thing something like that, that is courteously that is the practice followed generally so let us do that here so let me check if so if it is a valid input I have to say ok you can place it, how would I do that? In case if it is an invalid input I should repeat the process so I need to I need to use while loop here so let me use it while one because it has to turn infinitely till you get the correct input so correct input so if it is a correct input I have to break so what is the correct input? Row the value of row is greater than zero, one or two or three all are greater than zero right? and the value of row is less than four, one two three all are less than four and even column must be same like this column should be greater than zero and column is less than four and that must be a vacant column for vacant what are we using it? We are using a hyphen so I am going to check that one, board of should we use row column? Or row minus one column minus one? it is row minus one and column minus one, why do we use it? As I had shown you the indexing earlier computers start counting from zero where as humans start counting from one this we have taken the input in a human friendly manner but we have to convert it into a computer friendly manner that is why we are deducting one as I had shown you that time second row and second column of humans is nothing but one comma one for computers so you have to subtract from both the indices row as well as column this is how the computers works so if the humans says second row first column it is nothing but two minus one first row and one minus one zero, first row zeroth column for the computer so this is how the computer will inter crypt because why is this different? Because humans start counting from one, computers start counting from zero that is the reason so if this particular

thing is blank, blank is given by hyphen, if all these conditions are satisfied that is row and column are within this range one or two or three so it is greater than zero or less than four is nothing but one two or three and column is also the same and if the deserve vacant position then it is a valid input you can break here that is you can let him play yes broken from the loop so corresponding to this here you should let him place board of row minus one and column minus one is nothing but the symbol, whatever the symbol he wants to place this is how the place functionality works please check once again. It is you are displaying the board asking them for input to enter row and column value in case if they enter a faulty input or if that is not a vacant position you will repeat asking for inputs till they enter and if you again and again ask inputs they will get irritated so you should say if this particular this is for checking that whether the input is a valid input, if it is not a valid input you should print saying that invalid input invalid input please enter again some polite message only then they will understand that ok we had made a mistake and that is why you are asking the input again and again otherwise they may think that there is some fault in the system that’s why even though I gave an input it is asking again that is what people will think that is why we have to print a message in a way that they can understand easily this is important please note this, this is important so we will ask input as long as it is not valid once it is valid we break from this loop and place that particular players symbol here so see place players one symbol in even number turn player two symbol in odd number turn so whatever is the symbol being pass here that would be placed in that position so this is how it happens so place has been done so please see to the flow till now may be you can pause here for some time and then you can see it and yeah see we had missed one more thing, if player one has won we should say break, player two has won you should say break if no one has won at the end of nine turns that the all the cells have been occupied and still no one has won we should see we should tell that, that has to be included so let us include it if you should say if that is not won if that person has not won player one has not won see not is an operator that is predefined that is one will say if the person has won or not that is it is true or false? If it says true if you are applying not it would become false so it will invert the output of this particular thing, it will invert whatever is the truthfulness into it, that is what not does ok and not player two is also not won, not won of player two symbol if both haven’t won then you should print it is a draw ok so why did we do that? Because draw is also possible so that is why we had done this, this ok indentation is important it has to be at this particular position only column five because at the end of all turns only you have to check that is all nine cells have been occupied and still no one has won that means it is a draw, so we are checking it here fine let me change the indentation here too ok so this and this will be in the same level yeah nine and column nine fine ok please pass till here understand the flow of the programme and in the next video we will see how this functionality won, which has whether the person has won or not can be realised.
TIC TAC TOE-DOWN THE MEMORY LANE 03
Aright guys, in the previous video we had seen the outline of the game we have a play method and we had a place method; play method alternates the turn between the players ‘X’ and ‘O’. Even number turns is for ‘X’ and odd number turns is for ‘O’ and place method checks whether the position is a valid one and a vacant one it is so it allows the players to place it if not it asks for input again and again till he gives the valid position, so this is how game had gone till now so let us see this particular thing that has been undefined won so let us define that method now define won so won we have a same thing symbol as an argument we have been passing symbol so let us see so what should you check? Check rows, you should check for rows if any of the rows has been occupied or you should check for columns, if any of the columns has been occupied in a consecutive manner or check the diagonals, diagonals if any of the diagonals has been occupied so you have to check all these things and return the answer any of these things has been occupied then that person has won. So see check rows check columns check diagonals all these are intuitive to us we have to define it, let us define it one by one. check rows, define check rows we have pass the symbol ok, I need to check each of the three rows so I need to use a variable check this so let me call as row r let me call it as r, r in the range of there are zeros so let me say three, r in the range of three for each row I will have a counter count is initially zero that is we haven’t counter the occurrence of that symbol in the row so count is initially zero now let me iterate through every cell in the row for that let me use c column that is each row has three columns has a cell of three columns right? one cell belonging to each column we have it so we have to iterate over each of these cells for c for cell or column you can take anything for c in the range of three because each row has three cells, ‘c’ is in the range of three so let me call it I will say if board at the r and c index contains the symbol I will increment my counter, count equal to count plus one, why do I use the counter here? Because it may be the case that in some column or in some row ‘X’ ‘X’ and the third thing may be ‘O’, in that case it is not winning placement XXX is a winning placement so I need to count how many times I had seen the symbol ‘X’ so that is why I am using something called as counter, at the end of this loop where we had iterated over each cell I will check the value of the counter, if counter is equal to three because each row has three cells, if all three cells have the same symbol then it is a winning move I should print that it is a winning move so let me print this particular symbol has won let me say this person has won and I will return true here I am returning so this particular functionality comes to an end, in case if the first row doesn’t satisfy it the loop for r will be check once again and for the second loop same check would be done for the third row the same check would be done so once for all the rows this check has been done and none of the places this has been encounter that means there is no winning movement along the rows so in that case this check rows thing here that is winning is not due to occupying three consecutive cells or any row along any row the person has not occupied three consecutive cells so in that case you should say it is not a winning thing so I should return false that is the person has not occupied three consecutive cells along any row that is the meaning here I hope you can understand this check rows functionality otherwise no problem
 
you can pause the video here dry run the code and you will definitely understand it. So check rows is done check columns is pretty much similar so let me just copy paste it copy let me paste ok this is check columns just the name and some indices change because here a column value is fixed rows changed so let me change this as c and r so the rows change that is the column value is fixed rows change that’s the only change here otherwise it is pretty much the same I guess you can understand this we would let me show you see in check rows we fix up this row we check each cell we count in check columns we fix up the column in each of the row corresponding cell we count if you don’t understand please don’t worry dry running is the key here you sit think like a computer just have a index table something like this and dry run it you will definitely understand it, it is very easy for all that it requires is some amount of thinking that’s it it’s very easy please make sure that you understand till here ok check rows is done check columns is done now check diagonals so yeah I will show here wait ok see the diagonals zero comma zero one comma one two comma two the general format it is of the form I comma I so both the values are same along this diagonal and this diagonal differs so let us three cells so let us manually do it two comma zero one comma one zero comma two so please make a note of these values that’s it so for this I comma I general format you can use a loop something similar to what we are use in rows and columns just for that other case we need to use the thing manually let us do it now define check diagonals check diagonals for the symbol check it so for that diagonal let us do it if board of zero or maybe we can even manually do it no problem it is up to you, you can use a loop as well as you can do manually anything zero two is equal to board of one one that is allowed in maths but not in programming so we have to use and operator and we have to say board of one one is equal to board of two comma zero that is one of the diagonals and that particular thing is equal to this corresponding symbol only then this person has won so let me check it you can use any of the three values I am using one comma one that I equal to symbol in that case you say this particular symbol has won and you return true ok next is along the other diagonal here you are returning so in case if this diagonal has been satisfied this particular functionality would come to an end if this diagonal has not been satisfied only then the control would be transferred here you have to check this diagonal, board of zero comma zero is equal to board of one comma one and board of one comma one is equal to board of two comma two and board of one comma one is equal to symbol this can be return using the loop as well I will leave it as an exercise for you guys please do try using a loop to simplify this thing instead of using these many comparisons you can simplify it, alright if that is the case then this is pretty much the same so let me copy paste it copy paste ok in case if both the cases didn’t satisfy then it means along the diagonals there is no winning move in that case you have to return false so you had checked rows, checked columns, checked diagonals and see this won functionality is check rows or check columns or check diagonals if in one of the places or operator works in this manner if at least one of this values is true the final answer is true, if along the row or along the columns or along the diagonals there is a winning movement then you would return true that is that person has won, if all three places there is no winning movement only then it will return false that is this person has not won so this is how this functionality works ok let me save it ok so I hope you would have understood the code till now please do pause understand the flow of the code really well and then proceed towards running the code, you can try dry running it as I said dry running is the best way to

understand the computers perspective please do understand really well before proceeding further let us run this code and see what happens in the next video.
TIC TAC TOE – DOWN THE MEMORY LANE 04
Alright guys, in the previous video we had seen how to quote for this game so we had a play method which alternates the turn between the players, even number turns are for ‘X’, odd number turns for ‘O’. During his turn he has to place symbol in a vacant position so here we take care that his input is proper within the range as well as the position is vacant. So based on this, this functionality works and for checking the winning moves we have a functionality one, it checks the rows with their any of the rows three consecutive cells has been occupied by this player or along the columns or along the diagonals so since we are using or operator works in the fashion that if one of the value is true then final answer would be true so if all three ways the player has not occupied only then it will say it is false that is this person has not won, only then it will say something like this, this is how the functionalities works. I hope you had passed, i had asked you to dry runner i hope you had dry run and you have a clear idea of how the code works how the flow is, please do that make sure that you are very very clear in it then you run the code alright? I hope you are now very clear, let us proceed towards running the code. Ok, let me run it see it is extend and i have in a matrix format so it is asking me to enter the row, let as i had said two comma two is the smartest move because you have four winning possibilities in which that particular cell is intersecting so let me say two column is also two, see it has place the cell ‘X’ here let me now you could see initially the board was empty now i said two comma two has to be occupied so it has occupied. So now if i would give again two comma two see its saying invalid input because it is not a vacant position so let me give some other input one comma two so this position has been occupied, so this is ‘X’ turn so let me give some input two comma one this is x turn so for the player ‘O’ this is the optimal placement what if he chooses some other position, why this is an optimal thing because if he leaves this opportunity here in the next turn ‘X’ may win so he shouldn’t leave this so let me say if he didn’t predict the next move what could be and he has chosen something else he wants to maximise his winning chance now this is ‘X’ turn so he may win here, ‘X’ has won, it displays the message that ‘X’ has won so if as you would have as you would have seen it is important that both players are equally smart, try that variant as well, try playing in that way, you would definitely see a draw if both players are equally smart alright guys thanks for watching till now please do try different variant and also for tic tac toe there are many more variants you can browse online please do try a different kind of variant and discuss in the discussion form of what are the variants you have discussed, how did you implement? What are your strategies? What are the new things you came across? Please do discuss everything as clear learning is the best way to learn, please do discuss with your Ta’s and i wish you a happy leaning. Have a nice day.
TIC TAC TOE – DOWN THE MEMORY LANE 05
Alright, now we have seen one of the implementations of tic tac toe there are actually many such implementations possible, there are many other ways also there are some variants to the game as well you can look up to it and I would recommend you that try implementing some other variant which we haven’t discuss and please do discuss the strategies that you take up to implement those variants you explain those variants the strategies you take up please do discuss all those things in the discussion form happy leaning.
RECURSION
So we have a box here, there is another box inside this box and there is another box inside this box, there is another box inside this box, you must be wondering what I am doing? Then it is called recursion, so let us discuss about it.
Recursion 01
Sir, may I talk to you for five minutes? Yeah sure. Sir actually I would like to show you this comedy scene. I see that you are always obsessed with movies, when are you going to discuss with me something technical. Sir, actually you are sort of person who actually sees computing in every walk of life, this is something we generally use in computing, acha such a concept is there in this clip so I would like to show you. Sure sure show me. This clip is it? Yeah yes sir. Sir, did you just see what happened here? Isn't this the concept we use in computing namely the recursion? Very much, so that’s a good find vidya, this is a very interesting scene so I will do one thing I will try explaining what exactly is happening here huh? Concentrate look, there are several people right? There are some let’s say fifteen people, yes sir correct? And then this very person, first person asks a question to his neighbour right? And then he asks that question to his neighbour so this kind of a caste gate continuous you see and goes till the first person and some where here this fellow knows what is the answer, he tells him the answer and the caste gate comes back and hits the source and there you are bingo! You have the answer. Right? So this is exactly sort of how recursion works, you keep passing on the requirement was function inside a function and it goes inside and inside well within the last step and comes back and there you are with the answer that’s a very good observation vidya very nice, very creative of you. Thank you sir. Recursion is a very powerful tool in computer science and we are going to illustrate that with a standard example called computing factorial of a number.
Recursion 02
We all know factorial of a number, it’s a very easy thing to compute so fact of five is five into four into three into two into one, we all have been doing it from our school days right? Which is actually one twenty. So what is factorial? Let us take a look at it. Factorial of a number let’s say six is six times five times four times three times two times one, do you observe that fact of six is six times fact of five, what do I mean? I mean factorial of a number one can compute by computing factorial of a number one less than that multiplied by the number so fact of n is n times fact of n minus one. So let me thing of how one could write a program to compute factorial of a number. That’s going to be very easy, if the input is n I will just write a for loop and then for I equals one to n I will say answer is answer times I initializing answer to one, pretty straight forward right? The best thing about computer programming is that one can do the same thing in several ways. I told you how to compute factorial of a number, I will now tell you how to compute it in a way that is slightly complicated but I am going to introduce to you all a very important programming idea called the recursion. Remember, how I defined factorial of a number? We observed that factorial of n is n times factorial n minus one so how about this, I define fact function and then all that I do is written n times fact of n minus one whenever n is greater than one if it is any if n is equal to one I simply written one and that’s what this programme s doing now wait a minute I am I am defining a function and calling a functions name within the same function isn't that weird. There is actually nothing weird about it every programming language gives you this facility, the facility of calling the same function within itself and python also gives you this facility as you can see this programme will simply give you factorial of a number. Try to understand what is happening here, you are computing a function by giving as a input a number and the function is calling another instance of itself. I am sure my terminologies are sounding complicated but you will get used to it as you see more examples on recursion.
RECURSION 03
Hello guys, I hope you would have seen the concept of factorial of a number, let me just give you a brief over view of what it is. Factorial of a number is nothing but you keep repeatedly multiplying the number starting from one till you reach the given number and what is the answer you get is nothing but you call as a factorial of a number, let me give you an example. Let us take the number four, start with one, next number it is we have not reached four yet so take the next number two multiply it one into two is two, still we have not reached four so take the next number three multiply it two into three is six we have not reached four so take the next number it is four we have reached four so with this multiplication we need to stop so till now we got the six as the answer of multiplication and multiply four to it you get twenty four that is your answer so we say factorial of four is twenty four that is one into two into three into four is twenty four that is what you call as factorial of a number. You start from one and keep multiplying the next numbers until you reach the given number ‘n’ to get the factorial of the number ‘n’, if ‘n’ is the given number, in my case its four n is equal to four, so if the given number is n you start off with one two three and so on till you reach n keep multiplying and what is the final answer you get is what you call as ‘n’ factorial ok so how would we programme it? As you would have guessed from the procedure of calculation I had said we can do it using iteration let us do that so I said factorial, that is the functionality we need so let us define a functionality factorial for we need to find the factorial of given number ‘n’ so let me define n here ok so I need to start from one and go till I reach n so we can use for loop right? But for loop uses the function range to deal with numeric values and as you would have seen in your previous videos and till you practice you had till now range function would take if you ask for range of five it would start by default zero and it will count till four that if you would say five it will count one less than that, that is how it does. But we want it to start form one and we want it to count till n ok so we need to tweak in the range function to get this thing so we can define the start value for the range function if we don’t give a start value till now we had an given the start value for most of our programs so if we don’t give a start value the default start value is taken as zero but we can tweak in we can give some start values as well so let me do that in this program so I need to store the product so let me a variable call product so initially we have one as the product because with one of you multiply anything you will get the same number as the answer so you keep multiplying but from where will you start one into one into two into three into four into up to n this is how this has to been done right, so we have to start our multiplication from one let me define something called as product which carries the value one initially ok, so let me use the loop to iterate over the range that is to move over the range of numbers from one till n so I need to start from one so let me for I in range of I can give a start value as I had said start value one comma stop value, so whatever is the stop value it will stop one less than that, I want to stop at ten so what should I be giving here? N plus one a simple tweak so in this range that is from one to n plus one that is one two three it will count up to n so this is what we wanted we had taken that value as ‘i’ whatever is the new product after taking this ‘i’ will be whatever the product till now multiply with ‘i’ I hope you understand this that is if I want the factorial of three
 
whatever is the product how will I do? One, one into two is two till now my product is two, two into three is six this is how I take the factorial so whatever is the product we had computed till now that product into this particular value of ‘i’, this is how we compute the factorial. So at the end of the loop that is till you have reached ‘n’ whatever you keep multiplying, whatever is the product that is your answer so you have to return the product here so this particular functionality will take a number ‘n’ find its factorial and return the answer that is what it is doing. So let me, I have to use this functionality I have define the functionality now I am going to use this functionality so let me take an input sorry input, input generally takes in terms of strings in Mac so I need to type cast into int this is a Mac dependency that’s it, it may differ from operating system to operating system with practice you will get to know how your operating system expects your input syntax to be, based on that you please modify this I am doing this with correspondent to Mac so I am type casting it I am typing it the input let me say enter the number I will get a number but see factorial is defined only for positive numbers for negative numbers factorial is not defined, in mathematically factorial is only defined for positive numbers. If the number zero is given what is the case, if zero factorial has been defined as one that is the mathematical definition that is why see I had defined the product as one, in case if I given zero for I in range one comma one so it will not at all go inside the loop it will directly return the value of one here so this is like a dual advantage sort of thing, zero factorial is one also one is the number with which you multiply any number you will get back the same number so these are the research why we started off with the initial product value with one here. Ok you can start give zero but not any negative number I will enter a positive number so, let me give a clear message enter a positive number I am asking you to enter a positive number if the user still enters the negative number we should be smart enough and we should not allow this input so I should check it, if ‘n’ is less than zero that is it is a negative number I should display the message that factorial is not defined on negative numbers, on negative numbers see why we are doing this is this is what we call as fault tolerant major if the user has mistake given the some input which is actually incorrect we should not throw at him some random search and terrify him, we should give him a polite message so that he can understand what mistake he has done, he will not repeat it so this I one of the software engineering principle we are following, if ‘n’ is less than zero you that is it is a negative number say that factorial is not defined on negative numbers else let me say factorial so let me say f for factorial, I will get back the answer, I will call factorial of ‘n’ so I had called the factorial of ‘n’ so it will return an answer right that answer be captured in f so now I have to print it. So let me print it print let me say factorial of ‘n’ is f that is ‘n’ factorial is ‘f’ that is what we wanted to be printed. So let me save the code let me run it or maybe, I will give you a brief info, it will take an input it will check if it is a negative number, for negative numbers since mathematically factorial is not defined we display the message that it is not define, if it is a positive number it will start computing the factorial, how factorial is computer is? You start off from the number one and keep multiplying the consecutive numbers till you reach the given number n, at the end of this multiplication whatever is your answer is what you call as the factorial so you return that particular product and you print it here, factorial of n is this you are printing it this is how the working is let us execute the programme let me run it ok, it is asking me to enter a positive number let me show you let me enter a negative number see factorial is not defined on negative number so

this particular thing is fine ok so let me run again with the correct input positive input let me give a number six, ok factorial of six is seven two one into two into three into four into five into six is seven twenty that is what is displayed as the answer here fine? So our programme works fine this is not the only way to calculate factorial there is another way as well so you can understand that way for that please do observe the solution try, try enumerating running programme on different inputs, you will find some pattern if you are able to crack the pattern you will understand the alternative way of calculating the factorial. Thanks for watching till now have a nice day.
RECURSION 04
Alright guys, you had seen iterative version this version where we use the loop to find something is called the iterative version, the iterative version that is we are repeating something again and again this version is what you called as iterative version, so we have seen the iterative version of finding the factorial in the previous programming screen cast, I have told you to observe the solution you could find some patters, I hope you would have found some patterns, using that patterns we will solve the factorial problem here in yet another technique what we call as recursion, so recursion is nothing but a technique in which the programming languages allow a function to call itself again, it may sound confusing at the beginning but as you go it will be rally very easy so see as I had said if you want to compute the factorial of four, one into two the product is two ok then the next time when you approach three the product till now is two, two into three you compute is six, the product till now is six, six into four is twenty four that is how you got the answer right? and observe that you need four factorial you were making use of the values of three factorial that is one into two into three the values is six is being used to compute four factorial and you need three factorial you were using the values of two factorial so there is a dependency between these values so when you need larger values you are requiring a smaller value to compute the larger value so there were so dependency so the n factorial dependent on n minus one factorial this was the general pattern you could observe from the solutions mathematically also there is yet another definition of this is one definition of n factorial so one into two into three into till n another definition of n factorial is n into n minus one factorial so for n minus one factorial what would you do? N into n minus one into n minus two factorial so ultimately if you keep expanding where would you stop? As I had said zero factorial is one so that is where we stop, if you hit zero you will say I have reached the n so one is the answer here so till now whatever has been multiplied multiply one to it that is nothing but by multiplying one answer won’t change so we have reached the answer, so zero marks the end of this procedure here that is here we are depending on a smaller value for a larger value competition this process stops at the point zero right? so that place where we stop we call as the base case or the anchor case I would write it here probably base case here I will use the green colour because this appears ok so this is the multicolour command basically this appear in green colour it would be easier I guess base case or the anchor case, we can call it this is nothing but point where your recursion, recursion is nothing but your dependency on something of the same type that is factorial of n is a computation it depends on factorial of n minus one, how is that computtered? The same way. Again you apply the same formula n minus one into factorial of n minus two so you are basically doing the same thing but every time you do it again you are doing it on a smaller number so then you multiply one into two into three up to hundred if you multiply up to ten then use it to find eleven then use it to find twelve you are basically break it into smaller things and solving it so when you do that, that particular process where the bigger thing was depending on something similar smaller instance of it a bigger value of n depended on the similar kind of thing of a smaller value right? the similar factorial computation is similar three factorial depended on two factorial, two is a smaller value
 
compare to three so something like it n depends on n minus one, n minus one intern depends on n minus two this chain of dependency how this is being that this process is called as recursion. A function calling itself with a smaller instance is what you call as recursion. So if it keeps calling at some point it has to stop calling here, we have to say that ok we have hit the answer, we have arrived at the answer we have to say that. This particular point what you call as base case or the anchor case point where the recursion stops so this is what you call as the anchor case so let me modify this functionality this particular thing is not being used here this is the iterative version iterative version now let me start off with the recursive version recursive version as I had said that factorial of n can be represented as n into factorial of n minus one this is yet another way of defining the factorial function mathematically, so this particular way we are going to use here so where will it start? Factorial of zero is equal to one what if negative number occurs? They won’t occur because here we are taking care of it, if negative numbers have been given as an input we don’t even call the functionality we are calling it only on zero or greater than zero only so here we may not worry about handling negative numbers because in the actual calling part we had handled it so we are not worrying here ok this thing we are going to say so first the first step in recursion is always putting the base case base case, here base case was factorial of zero is one so I should say if we have passed the number as n, n is equal to zero I should return the product as such right so let me bring use this statement the product is initially set to one right? this is not needed actually I can even remove this I can directly say return one so I should return one so I had return one that is factorial of zero is one that is why id n is zero I returned one else what should I do? I should return n into n minus one factor n into n minus one factorial so I should call it as factorial of n minus one ok let me give you illustration before we actually run the code, so if I call factorial of three let suppose let start with a smaller value so that it is easier you can extend it for any value even factorial of hundred anything you can extend that’s not an issue ok so how it begins is it will first check if n is zero three it is not equal to zero so it will come to the else part it will see three into factorial of two, so value of factorial of three depends on the value of factorial of two, similar instance but the value inside is smaller ok so now this particular thing has to be called ok factorial of two gets called so again see factorial of two so two is passed here n is equal to zero no two is not equal to zero so its comes here it will say two into sorry two into factorial of one ok so now factorial of one gets called ok what is factorial of one gets called, so one is passed here if one equal equal to zero so false come back to else return one into factorial of n minus one so it will compute one into sorry factorial of one minus one is zero ok so now ok factorial of zero, zero is passed here n equal to zero, zero equal to zero its true so it will return one so this will return one so now your calculation will go in the upward direction ok let me show you the upward calculation ok so one is returned so it goes one level up, one level up so it will calculate one into one what is the answer one so that particular value is passed to one level up ok so two into what is the value being passed there one so that is being calculated so two into one is calculated two into one this one there is a passed from one level below for it there is passed from one level below so the computation breaks down into smaller numbers and once you get the number where you get the where you know the answers you trace back till you get the larger answer that is how we are working here ok so two into one is two ok let me now say let me now say so two has been passed here already it was having three, three into two, three into two ok what is the

answer? Six so this thing has found it so it will get the answer has six, so this answer will be passed on to the main function value we have called this so when you call factorial of three it will keep splitting the problems into smaller ones until it knows the answer and once you know the answer trace in the backward direction till you get the answer for the larger problem this is how recursion works ok this is the Woking of recursion let us start a new console and let us run it ok? before that I have to save this I will save ok let the console start ok so it has started so let me run the file enter a positive number the same negativity check all these are the same so I am not giving a negative number so let me give back as positive number let me say five, factorial of five is one twenty so in a similar fashion it will break down five will break down to four, four will break down to three, three to two, two to one, one to zero for zero you know the answer now use that answer trace in the backward direction and you will get the answer as one twenty. So this is how the recursive programme work, I hope you have understand the concept here or it’s not a difficult thing it’s a easier one all that you need is some practice that’s it take some examples you try thinking in this fashion, try breaking into smaller pieces then once you get the answer try constructing back the actual answer. So I hope you have been remembering the movie clip that has been shown at the beginning of the video, the person would ask answer for something to a person before him, the thing keeps on propagating till someone who knows the answer, once you get the answer you propagate in the backward direction to the person who has asked the question, in this case what is the factorial of three? That is the question asked by your main function that is question asked by your sir, so you cannot compute it directly so you try splitting it into a smaller instance so that is something analogue us to asking the person before him whether he knows so whether this thing can be calculated it checks even this cannot be calculated so again split this is can be calculated no so again split can this be calculated? Yes, calculate use the answer and propagate in the backward direction, I guess now you understand why we had shown the movie clip and also how the concept of recursion works, this is really a very powerful concept in computer science, it will make it institutive things be easier to code that is something will be intuitive for us we will have in mind that this is how things has to be done. But how you would translate it into a code? It may be difficult if only iteration value for rescue recursion is handy in many situation you would come across as you keep learning some advance stuff even in some stuff what you had learned till now you can have a recursive version for some problems please note that for this we had an iterative version as well as a recursive version so for every recursive version there is an equalent iterative version too, so you can use anything that is convenient for you and in some places recursion is highly intuitive and easy on minds so once such application will see in the next video. Thanks for watching, have a nice day.
RECURSION 05
Alright guys, hope you had learnt about the powerful technique of recursion, I hope you remember search algorithm that you had studied previously in your previous weeks namely the binary search, let me give you a very quick overview of what is does? It is basically how we search for in a dictionary or in a telephone directory something like that. Why did I take dictionary or telephone directory? Because the words or the contents in the directory are sorted or that is arranged in some ascending order they are arranged in the alphabetical order so that is why we can apply this technique so binary search basically calls for a sorted list, you want a list that is arranged in some specific order, either ascending or descending it calls for list arranged in their order and in that list you want to see whether a particular number is present in the list or not whether a particular item is present in the list or not, so what would you do? You would check the middle of the list, if that is your required item you are done else you check if it is less than your required number or greater than your required number, accordingly you will branch on to the left half of the list or the right half of the list. So this is how your binary search works you have seen a iterative version of binary search in your previous weeks I guess so that is easier but still an easier thing like how I had given you an intuitive version of binary search like you have to scan into the left half and you have to scan into the right half something like that I had given you an intuitive version so such a intuitive thing can be easily translated to code when you use this technique of recursion so let us see how we can use recursion through simplify the process of writing code for binary search. Let me say I will define binary search, binary search define binary search for this I need list or you can call it list l I need a list l, some element x which we want to find, you were processing it by sing the index values, you would have seen that till now you may be familiar but still I am telling you a very quick recap, indexes in computers starts from zero human start counting from one cut computers start counting from zero so the counting starts from zero so if your list has five elements the counting would be done as zero one two three four, zeroth element, first element, second element, third element, fourth element this is how your computer counts so you have to give the starting index and the ending index these are required for your binary search right, so initially your starting index is zero ending index is actual end of your list so that is entire list then as you scan the middle element you keep discarding one half of the list and just keep searching in the other half so that time it will change so these are the Para things you need to do binary search, you need a list you need the element x which you want to search you need a start and end index of the list where you want that is you won’t search the entire list all the time, you will search parts of list by discarding the unnecessary half this is how your binary search works so we needed this four parameters ok let me define as I had said recursion requires base case, what is the base case? When we have only one element left in our list, if just one element is left in our list then we have to see that particular element if that is the required element then you say yes required element has been found else you say element is not found ok so for element not found I am going to return value minus one I am going to assume that my list has all positive values and minus is not the value in my list also I am going to return the position of the element, I am not going to
 
return the element even if have negative element I don’t mind let’s find I am going to return the binary search basically here I am going to return the position in which the element is present at the list, so that is what I am going to return so position starts from zero right? so if the element is not found I will return minus one that is the element is found somewhere outside the list, that’s what basically I mean so I will return minus one in case if it is not found so base case is the base case is one element just one element in the list that is the base case so if there is just one element in the list how would you start and end, they would be equal, start and end will be the same value because there is only one element that is the start as well that is the end so I will start using the start and end indices, if start is equal to end I would check if l of start or end you can use anything inter change of it because they both are equal in this case, if that are equal to your required element x you return the start value, that is return that position hence there is just one element say suppose assume you have just one element ten in your list and what you want to search is fifty, fifty is not present in the list and it is having only one element then you have to say element not found so for that I said the code I am going to use encoding I am going to use is minus one so I will return ,minus one, element fifty is present in the minus oneth position meaning that it is not present ok, so I will return minus one in that case ok so this is the base case if the base case is not true then else that is there are more elements in a list, in that case you have to find the middle element and you have to discard the unnecessary half and search through the required half, you have to split the array into halves and search through the required half that is what you have to do right? so divide the divide the array into halves this thing we have to do for that we need to find the mid position, mid position is nothing but start plus end here I have to put up bracket because I need to calculate the sum first then I have to divide by two this is the midpoint right this is intuitive start and so here will be your start and here will be your end the midpoint will be start plus end divide by two this will be your midpoint when you divide there is a possibility that you can get some value that is floating point may be seven by two three point five, what is the meaning for position three point five? Either you have to take it to three or to four so for that we are using a functionality int so we are type casting it to integer because position is a integer we want it in a integer that is first position second position third position this is what we want, we don’t want three point five position so will use int so it will have its own conversion it will take it to three point five to three or four maybe we can run here and check int of three point five let me give three so it is taking to floor functionality, floor is nothing but the integer that is closest to it the greatest value of the integer that is closest to it if we take the number line three point five is somewhere here three is here and four is here it is going to the left side so int functionality is going to the left side and taking the greatest integer two one everything is present in the left but the greatest in the left the integer is three so three is returned as the answer. So that will be taken here let me start a new console better because for this program new console ok so this is the midpoint we have computed, we have to check mid element is the required element so if the if l of mid is equal to x that is the case we have done we have found the element return the mid element else I have to check if it is greater or less so I would say l of mid is greater than x means you have a sorted list and the middle element is greater than your required element so where should you search, definitely your element will not be in your right half you can discard the right half and you need to search the left half so your array would now shrink from the starting position to mid minus

one so mid position didn’t have the element also there is no chance that it will be after mid so it would be before mid so we need to shrink the array up till mid minus one position that is one position before the mid till that we need to shrink the array, that is we will do as return the result of binary search on the same list for the same element x start position is not change see because we are we have to check the left half of the array so the start position is the same but the end position is not the precious end position, previously we have the bigger list we want to split it so the end is mid minus one why mid minus one? Because at mid position we had checked, at mid position didn’t contain the element ‘x’ so an ‘x’ is the smaller value that is ‘x’ is l of mid is greater than x meaning that x is lesser than l of mid so ‘x’ being less than the mid value will be present in the left half so from starting position till one position before mid whatever is the array left search in that array and return the answer if what we mean, see it is really intuitive see this is the left half, this is the left half than using of iterative method recursion is easy you can translate your intuition into code very easily if you use the recursive ideology ok so this is the recursive way to call the left half of the array, call the procedure on the left half of the array search the left half else you have to search the right half, so for the right half end value is the same but starting point is different right? we had searched till mid we didn’t find it at the position mid and the value x is greater than the mid value so it would be present from one anywhere from one position after mid up till the actual end point right? so your start value will change or I would say return binary search result on l, x mid plus one and end, the modify starting point is mid plus one till mid position we had checked there was no element that is why we are checking the path after the midpoint, here we are checking the path after the midpoint, here we are checking the path before the midpoint that is the left half and the right half whatever we had it intuitively in our mind we are translating it to code very easily so this is the power of the recursion so it would recursively keep computing and we will get the answer so you can take any example, I had given you an example of how recursion works in the factorial screen cast similar to that you take a list you try applying binary search on it, you try how recursion works, you would have understood how recursion works so this particular search the bigger list depends on the value of searching on the smaller list so whatever the result you get after searching on smaller list will be translated back and will be returned as the result for searching on a bigger list this is how your binary search in the recursive manner so we had defined binary search now we have to used it, right? so let me give a random list you can also change it with your version you ask the user to input how many numbers he want to input, you input that many number of numbers or till he presses some keys you keep getting input you can by now I guess you all are familiar with the various conditional construes using that you can modify the code as you wish, now my motto is to demonstrate binary search so I would just give a smaller list twenty forty five sixty seventy ninety this is my list I have given please note that I have given a list in the sorted order, if it is not sorted you have to apply sorting first then after you get the sorted list then you have pass the sorted list to the binary search, binary search expects the sorted list so that is very important please make a note of it, so this is my list and I will input the x value from the user ok, let me input the value of ‘x’ from the user and I have to typecast the input in my Mac machine so I am type casting you please follow as per your machine dependency input enter search key search key I would say that is what number you want to search, I would input the search key from the user, that is my ‘x’ so binary search will return the index and so

let me store it as index is equal to binary search on the list l search key ‘x’ starting position is always zero for the bigger list initially we start with the entire list zero and the end position is zero to length minus one this is the five element list so it will be four so let me generalise it so let me say length of l this will give the length of the list that is how many elements are present in a list will be return by this length of the list minus one this is the ending index so you initially start of your search with this particular index this is the suppose my search key is eighty this will be the entire key is passed so it would find the mid value sixty it is righty is greater than sixty so this half is not needed this is neglected and this particular thing will be executed and seventy ninety this will be my new list in this list I will search for my key seventy and ninety this will be taken as the mid value as we have seen that floor value is taken so this value is taken as mid value, eighty is still greater than seventy so it will skip to the right half so here there is only one element ninety so this case would be executed ninety is not equal to eighty so it will return minus five so I will come to know that this thing is not present so something like that it works you can trace through it I hope now you are clear with how recursion works and you are clear with the binary search concept too so you can understand it you all that you need is take a pen and paper and trace through how some example work, that is what is required with that you can easily understand the concept ok so it will return the index where the element is present in the list, ok I have got the index so if I just say the index this is not enough for a normal user for us element sixty is present at the third position if I say two they will say what is this computers doesn’t know even this so we have to translate it into a human friendly format right, so basically what is that we have to do, we have to add one, one is represented as zero, the index in second position is index one, third position is index two so basically whatever is the index it returns add one to it and display it to the user and if it returns minus one, you should not say it is present in the zero you should say that element is not found, print appropriate message so first we will give a check that if index is equal to minus one in that case you should print x value not found ok x value is not found ok else you should print, that is minus one is the not the case that you should print that x value is found at found at position index plus one, computers counting system and the humans counting system differ by one that’s why we are adding one and display ok so this is how you have done, let me save the code I hope you are clear with it we have a list we input a search key this you can even modify it to getting the input for the list element is from the user, you have to sort the list please note that you have to send a sorted list for binary search to occur, so you have to sort that list input a search key then you apply binary search on it how it works? If there is just one element in the list it will check if that element is the required x element x, if it is the case it will return the index else it will return minus one so whenever the element is not found it will return minus one that is how we have encoded it. In case if the list have more than one element what it does is, it will find the mid element and based on the mid element since the array is sorted it will discard one of the halves if the element required is exactly the mid element we are done if it is less than the mid element you have to search the left half so it will discard the right half it will search only the left half if it is greater you have to search only the right half it will discard the left half so for this to understand this really well I would suggest that you take a twenty element list basically and you try tracing it on paper, basically to understand this clearly you should work out a lot on papers and less on computers, computers can do this in fraction of second but

humans to understand this strategy it requires some practice so please take a pen and paper take some twenty element list randomly you sort it maybe for that you can use the computers as well because sorting a twenty element list may take some time, so you can use the computer as well you sort it or you take the sorted list of the twenty elements you randomly give some search element you give some element which is present in the list as well as some element which is not present in the list try to understand how the various runs of the programs are and you will really understand the process very easily after practice all that need is needed is practice please do practice practice practice that’s it now let us run this program let me run it ok it is asking me to enter a search key let me enter eighty, eighty not found perfect! Ok now let me enter ninety, let me enter ninety, ninety is found at position five perfect. We got it when I entered eighty, eighty not found at this list so it’s says eighty not found and when you enter ninety, ninety is found here it is found at position five so it says ninety is found at position five so it works, I would recommend that please you take some pen and paper and work through the various example, work through list with large elements as well here just that I wanted to demonstrate the recursion technique I had taken a smaller list and already sorted list, you try different things unsorted list you sort it then apply binary search at huge list, a list where you get somewhere it is if it is a twenty element list try to find the sixth seventh element try to find the eighteenth element try to find something exactly near middle or near the middle something like that, you try various possibilities you will understand actually what is logic of binary search how it works, all that is needed is practice with pen and paper. Keep practicing thanks for watching have a nice day.
RECURSION 06
Alright guys, hope you had seen a few examples of our recursion work, this is yet another mathematical function or mathematical sequence I would say which can be easily computed using recursion. So this is what we call as the Fibonacci sequence let me give you some explanations in commands before we start off with the coding. So we are going to see what is called the Fibonacci sequence. I guess you guys are familiar with it, still let me give you a brief overview so the Fibonacci sequence starts with zero and one this is the zeroth Fibonacci sequence same like computers it here the counting starts from zero, zeroth Fibonacci sequence is zeroth Fibonacci number is zero let me write one by one that’s better, zeroth Fibonacci number is zero sorry I am sorry for this, zeroth Fibonacci number is zero the first Fibonacci number is one second Fibonacci number is nothing but now you have got two numbers let me put it ok, given that you have got two numbers you add this two numbers and you got the result has zero plus one is one so this is your second Fibonacci number. The third Fibonacci number is nothing but add the last two one plus one two, two is your answer, the fourth Fibonacci number is one plus two three, three is your answer, the fifth Fibonacci number is three plus two five this is your answer and so on and keeps going keeps on going it is a infinite sequence basically. The initial two values are nothing but the seed values they had given, these are the in our recursion terminology this is the base case or the anchor case, this is the base case or the anchor case for these two things we know the value we can directly written the value, you can directly say this is the value, they say I won the first Fibonacci number they can directly say first Fibonacci number is one if someone is asking you the tenth Fibonacci number something like that you don’t know you need to calculate it so using zero and one you find two, using one and two you find three, using two and three you find four so do you see a bigger value of the Fibonacci number that is the nth Fibonacci number depends on the value of n minus one Fibonacci number plus n minus two Fibonacci number so it depend on the previous two values right? so here we can apply recursion and we can easily find the nth Fibonacci number so our objective here is to find the nth Fibonacci number, Fibonacci number we can have the iteration of the code too but in this case I would leave the iterative version of the Fibonacci number as an exercise for you guys please do try it, it is not very easy it requires some amount of thinking but it’s not herculean task something like it it’s not rocket science it is do able so you need to invest some amount of time you invest some amount of thinking, if you do that you can find iterative way how to find the Fibonacci number, so that I would leave it as an exercise, I would demonstrate the recursive way for you. Ok so let us start off I need to define Fibonacci, I would say Fibonacci of n, nth Fibonacci number is what I want to find, I know the zeroth Fibonacci number and first Fibonacci number, zeroth Fibonacci number is zero, first number is one so in this case I need to return if given n is zero I need to return zero, if the given n is one I need to return one so if n is zero or one I need to return back n itself so that is my base case ok that is why I had given a space here as well this is the base case and maybe I will put a dash here this is the base case and this are derived from the base numbers ok so this is the base case so let me first put it, if n is less than two and similar to that the negative value of n Fibonacci is not defined
 
we need to check that in the main part where we are calling this functionality same as factorial how it is defined just for positive numbers and zero, zero and positive numbers Fibonacci is also defined only from zero for negative numbers it is not defined so let me say zero and one right so let me say n is less than two just return back that n, if it is zero return zero if it is one return one so like that n ok else if it is greater than or equal to two from two onwards we are dependent on the previous values so you should return back the Fibonacci of n minus one plus Fibonacci of n minus two maybe you want the second Fibonacci number you should return Fibonacci of two minus one that is Fibonacci of one plus Fibonacci of zero that is what we calculated, Fibonacci of one is one, Fibonacci of zero is zero so that is the first Fibonacci number is one, zeroth Fibonacci number is zero so zero plus one, one that is how we calculated right? so that is what we are doing you take the previous two Fibonacci numbers and add it is what you are doing, if you need the third one what you do is second plus first, first one you know the value so substitute one, Fibonacci number second Fibonacci number you don’t know so you calculate second Fibonacci number plus one for getting second Fibonacci number again you call it for second it is first plus zeroth so zeroth plus one is one, one plus one is two so you will get the third Fibonacci number so you can trace it on a paper and you will understand the working so this is how basically Fibonacci numbers work if it is less than two just return back the same value otherwise return back the sum of previous two values right? This is the intuitive way of explaining Fibonacci numbers see we have translated our institution we have translated the intuition into code very easily all thanks to recursion with this powerful technique we can really made this code very very easier but for iterative version you can write an iterative version I don’t say that with iterative version it is totally impossible you can write an iterative version but it requires some amount of thinking invested here ok so I have got the answer so I should take an input n is equal to integer input what I wanted so I will type cast for because of my machine dependency I type cast input enter the positive maybe, I can say or non negative that is because zero is also defined right! so I should say non even in factorial please make the correction there, it is non negative because zero factorial is one also defined so enter an non negative number, enter a non negative number is the input is the message I got so and from input I will get still I need to check in case that person has by mistake entered an negative number I shouldn’t throw at him some, some results that is incorrect so I should throw him I should tell him the suitable message properly so I will print undefined for negative numbers n is less than zero means that it is a negative number whatever input he has given what is undefined? Fibonacci number is undefined for negative numbers. Ok so I will say Fibonacci numbers are undefined for negative numbers ok so I had given it Fibonacci numbers are undefined for negative numbers else if it is not a negative number than I should print the nth nth Fibonacci nth is not correct because we gives first second I have to put st and nd here properly so that formatting is needed I would modify the message instead smartly Fibonacci number at position sorry it is position n is I should call Fibonacci of n alright? I hope you guys can understand this till now see I take a number input a non negative number zero or positive I agree if it is a negative number I will say it is not it is undefined I print this message else I call this functionality Fibonacci or n ok if I call this functionality Fibonacci or n if that number is less than two for zeroth Fibonacci number is zero first Fibonacci number is one so this is something defined as the base case for us so in that case I will return the value of n otherwise I will compute the

sum of previous two Fibonacci numbers right? so this will input the nth Fibonacci number so for first let me verify further let me enter five, if I enter five I should get five as the answer or maybe enter four I should get three as my answer let me verify it first then maybe I will find the other Fibonacci numbers ok let me run the file ok enter an non negative number I will enter so just for verification I enter minus seven Fibonacci numbers are undefined for negative numbers, yeah! I got the proper message ok now let me test it if I enter four, the fourth Fibonacci number is three, I should get three as my answer let me run it, enter a non negative number let me enter three, sorry four, fourth Fibonacci number is three, third Fibonacci number is two fine you can do it. Let me enter four Fibonacci number at position four is three yeah it is working so now let me find out the tenth Fibonacci number let me do tenth Fibonacci number, Fibonacci number at position ten is fifty five maybe you can list the numbers like this and you can verify but its correct so once its working here definitely it will work for many value so using this program you can find the Fibonacci number at the nth position in the sequence, in the Fibonacci sequence what is the number present at the nth position, so here nth is luckily this is one thing in mathematic which is very close to computer science counting starts from zero so nth number is nothing but for humans counting style n plus oneth number pleas have that in mind here counting starts from zero. I would recommended you guys invest some time thinking if you can do this in an iterative fashion it requires some amount of thinking to make it iterative it is possible it can be done but it is not straight forward it requires some amount of thinking so when you invest some time for thinking in the iterative style you would definitely appreciate the technique recursion because it’s lets you do something straight away from your intuition whatever you understand from someone explanation you can straight away try staring the code recursion allows that thing, that particular thing is difficult when you do it in the iterative way but still it’s not a rocket science it’s doable please do invest some amount of time try doing the iterative version and please do discuss in the discussion form of how you tried the iterative version what are the challenges you faced? Or if you can print the sequence Fibonacci sequence if they are asking the nth Fibonacci number, can you print the sequence starting from zero till the nth Fibonacci number, can you try that variation? You can do a lot of things pleased do explore and keep trying more examples so that you understand how recursion actually works. Thanks for watching, have a nice day.
