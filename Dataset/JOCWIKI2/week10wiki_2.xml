<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>JOCWiki</sitename>
    <dbname>Jocwiki_second</dbname>
    <base>http://sccilabs.org/jocwiki2/index.php/Main_Page</base>
    <generator>MediaWiki 1.30.0</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">JOCWiki</namespace>
      <namespace key="5" case="first-letter">JOCWiki talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
      <namespace key="2600" case="first-letter">Topic</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Lecture Notes:Week 10</title>
    <ns>0</ns>
    <id>872</id>
    <revision>
      <id>2511</id>
      <timestamp>2019-04-01T12:45:08Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <comment>Created page with &quot;==''' NumPy '''== NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mat...&quot;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1447">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of 
 ndarray.shape.
'''ndarray.dtype''' : describes the data type of the elements in the array.


== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of arr object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;</text>
      <sha1>kzs4g13nbj6v4q63txlbax426gc0avj</sha1>
    </revision>
    <revision>
      <id>2512</id>
      <parentid>2511</parentid>
      <timestamp>2019-04-01T12:45:49Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <comment>/* NumPy basic program */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1449">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of 
 ndarray.shape.
'''ndarray.dtype''' : describes the data type of the elements in the array.


== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;</text>
      <sha1>3x5vgt2j4hv0dg7gyx6onv6as9xuari</sha1>
    </revision>
    <revision>
      <id>2513</id>
      <parentid>2512</parentid>
      <timestamp>2019-04-01T13:22:08Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2222">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.
'''ndarray.dtype''' : describes the data type of the elements in the array.


== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;

== NumPy array creation ==
Following are the methods of array creation

'''array''' : to create simple array
'''zeros''' : creates array in which elements are only zeros
'''ones''' : creates array in which elements are only ones
'''arrange''' : creates array with elements in increasing order
'''empty''' : uninitialized array with random values

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # cretes [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;syntaxhighlight&gt;</text>
      <sha1>l5xkv445vpkoopxsvlsk0wlfmxd7tx8</sha1>
    </revision>
    <revision>
      <id>2514</id>
      <parentid>2513</parentid>
      <timestamp>2019-04-01T13:25:10Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <comment>/* NumPy array creation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2267">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.
'''ndarray.dtype''' : describes the data type of the elements in the array.


== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;


&lt;br/&gt;== NumPy array creation ==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;</text>
      <sha1>5vkptvwpbdierbssycwfw3ka4mlvozy</sha1>
    </revision>
    <revision>
      <id>2515</id>
      <parentid>2514</parentid>
      <timestamp>2019-04-01T13:25:59Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2272">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.
'''ndarray.dtype''' : describes the data type of the elements in the array.


== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation ==&lt;br/&gt;
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;</text>
      <sha1>90ybf9b0djagsk8go5zv5zj4rq534yd</sha1>
    </revision>
    <revision>
      <id>2516</id>
      <parentid>2515</parentid>
      <timestamp>2019-04-01T13:30:00Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2286">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation ==&lt;br/&gt;
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;</text>
      <sha1>p1rr75j1st39xsphztmr4muyvggqyjr</sha1>
    </revision>
    <revision>
      <id>2517</id>
      <parentid>2516</parentid>
      <timestamp>2019-04-01T13:31:13Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <comment>/* NumPy basic program */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2287">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;

== NumPy array creation ==  &lt;br/&gt;
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;</text>
      <sha1>lozzm4to95ayekxzejoma7ajyn6w3dq</sha1>
    </revision>
    <revision>
      <id>2518</id>
      <parentid>2517</parentid>
      <timestamp>2019-04-01T13:39:53Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2971">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;

== NumPy array creation ==  &lt;br/&gt;
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy == &lt;br/&gt;
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;</text>
      <sha1>ojhfxtzbf8i8hvqh4pr99ab48tnnk5j</sha1>
    </revision>
    <revision>
      <id>2519</id>
      <parentid>2518</parentid>
      <timestamp>2019-04-01T13:41:05Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <comment>/* NumPy basic program */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2965">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;

== NumPy array creation ==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;</text>
      <sha1>pjg080nte1mamnt6p83v6iff43rxvhb</sha1>
    </revision>
    <revision>
      <id>2527</id>
      <parentid>2519</parentid>
      <timestamp>2019-04-02T09:33:17Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3488">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;

== NumPy array creation ==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;</text>
      <sha1>m353fnc303fkip0xii0nwyguncyoasu</sha1>
    </revision>
    <revision>
      <id>2528</id>
      <parentid>2527</parentid>
      <timestamp>2019-04-02T15:06:02Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4333">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation ==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;


== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;</text>
      <sha1>18sdengprs3l6r554657sg4t260lm5c</sha1>
    </revision>
    <revision>
      <id>2529</id>
      <parentid>2528</parentid>
      <timestamp>2019-04-02T15:09:48Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <comment>/* NumPy array creation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4339">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;</text>
      <sha1>2sx520waivyxqp9x60oaur51o03sbee</sha1>
    </revision>
    <revision>
      <id>2541</id>
      <parentid>2529</parentid>
      <timestamp>2019-04-03T18:36:12Z</timestamp>
      <contributor>
        <username>Srinivas225</username>
        <id>3184</id>
      </contributor>
      <comment>/* NumPy array creation methods */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4341">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;</text>
      <sha1>er3a88tr0fbbxfuzhr14yrdl154r3pk</sha1>
    </revision>
    <revision>
      <id>2587</id>
      <parentid>2541</parentid>
      <timestamp>2019-04-06T10:44:59Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8015">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.</text>
      <sha1>77was4dypjjrblkfepvded65c37lqkm</sha1>
    </revision>
    <revision>
      <id>2588</id>
      <parentid>2587</parentid>
      <timestamp>2019-04-06T10:48:16Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* String Functions in Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8714">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;</text>
      <sha1>2iyn3g30esmrl8msu6z3i0cgl20ul95</sha1>
    </revision>
    <revision>
      <id>2589</id>
      <parentid>2588</parentid>
      <timestamp>2019-04-06T10:52:09Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9540">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;</text>
      <sha1>sb69sbvkky5s5o7d7ghtn5m2smem7wx</sha1>
    </revision>
    <revision>
      <id>2591</id>
      <parentid>2589</parentid>
      <timestamp>2019-04-06T11:08:42Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13025">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)
#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])
#Select all elements of a vector
print(vector_row[:])
#Select everything up to and including the 3rd element
print(vector_row[:3])
#Select the everything after the 3rd element
print(vector_row[3:])
#Select the last element
print(vector[-1])
#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])
#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
#View the Number of Rows and Columns
print(matrix.shape)
#View the number of elements (rows*columns)
print(matrix.size)
#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)
#Return the max element
print(np.max(matrix))
#Return the min element
print(np.min(matrix))
#To find the max element in each column
print(np.max(matrix,axis=0))
#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;




==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;</text>
      <sha1>e122s6jz1rrrqu6sgx6yqdw7mf79eed</sha1>
    </revision>
    <revision>
      <id>2592</id>
      <parentid>2591</parentid>
      <timestamp>2019-04-06T11:09:21Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Creating a Sparse Matrix */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13025">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;

=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])
#Select all elements of a vector
print(vector_row[:])
#Select everything up to and including the 3rd element
print(vector_row[:3])
#Select the everything after the 3rd element
print(vector_row[3:])
#Select the last element
print(vector[-1])
#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])
#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
#View the Number of Rows and Columns
print(matrix.shape)
#View the number of elements (rows*columns)
print(matrix.size)
#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)
#Return the max element
print(np.max(matrix))
#Return the min element
print(np.min(matrix))
#To find the max element in each column
print(np.max(matrix,axis=0))
#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;




==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;</text>
      <sha1>9d3fdwunbxbqbcd9n3mr45zjqwnl0kq</sha1>
    </revision>
    <revision>
      <id>2593</id>
      <parentid>2592</parentid>
      <timestamp>2019-04-06T11:16:39Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Various NumPy Operations */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14627">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;</text>
      <sha1>76b7eeg72jctczg5uj23esdzika07a9</sha1>
    </revision>
    <revision>
      <id>2594</id>
      <parentid>2593</parentid>
      <timestamp>2019-04-06T11:23:14Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Various NumPy Operations */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17145">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_1 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;


=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 1 and 10
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;</text>
      <sha1>rw4z0xd4wz7p9x395aso5ky9opjvwrq</sha1>
    </revision>
    <revision>
      <id>2595</id>
      <parentid>2594</parentid>
      <timestamp>2019-04-06T20:17:37Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18017">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_1 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;


=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 1 and 10
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;



== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;</text>
      <sha1>2v1dro9jaqvi14exmn88gtzobdid5gg</sha1>
    </revision>
    <revision>
      <id>2596</id>
      <parentid>2595</parentid>
      <timestamp>2019-04-06T20:20:46Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Josephus Problem Code in Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19193">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_1 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;


=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 1 and 10
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;</text>
      <sha1>ozl2wi6fpk7vcwy47o8qrcmyugfy3wy</sha1>
    </revision>
    <revision>
      <id>2597</id>
      <parentid>2596</parentid>
      <timestamp>2019-04-06T20:38:14Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="20341">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_1 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;


=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 1 and 10
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;</text>
      <sha1>4wqwfm2tv0mubo0jhb3wfw3di94xxof</sha1>
    </revision>
    <revision>
      <id>2598</id>
      <parentid>2597</parentid>
      <timestamp>2019-04-07T08:56:52Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Regular Expressions ( .* ) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="21213">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_1 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;


=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 1 and 10
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsaussage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;

'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;</text>
      <sha1>oid02s1xwevarsghplj0bw5700rgzhk</sha1>
    </revision>
    <revision>
      <id>2599</id>
      <parentid>2598</parentid>
      <timestamp>2019-04-07T09:01:18Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Regular Expressions ( .* ) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="21566">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_1 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;


=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 1 and 10
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.</text>
      <sha1>7zgyfb5espaigx7n89brcugwe7hxjg2</sha1>
    </revision>
    <revision>
      <id>2600</id>
      <parentid>2599</parentid>
      <timestamp>2019-04-07T12:05:21Z</timestamp>
      <contributor>
        <username>Phegdepatil</username>
        <id>1152</id>
      </contributor>
      <comment>/* Calculating Dot Products */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="21565">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 1 and 10
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.</text>
      <sha1>a2zlzazph9tjgo23pdlk7b0sqvbjg8p</sha1>
    </revision>
    <revision>
      <id>2601</id>
      <parentid>2600</parentid>
      <timestamp>2019-04-07T12:15:27Z</timestamp>
      <contributor>
        <username>Phegdepatil</username>
        <id>1152</id>
      </contributor>
      <comment>/* Generating Random Values */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="21581">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 0 and 10 (start, end, n)
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.</text>
      <sha1>ibjf1fa8qtcfrh1uli161wqab98gyii</sha1>
    </revision>
    <revision>
      <id>2602</id>
      <parentid>2601</parentid>
      <timestamp>2019-04-07T18:03:18Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Regular Expressions ( .* ) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22521">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arrange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 0 and 10 (start, end, n)
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.


=== Email Extraction Program Using Regular Expressions ===
To demonstrate a sample usage of regular expressions, we create a program to extract email addresses from a string.

&lt;pre&gt;
import re

pattern = r&quot;([\w\.-]+)@([\w\.-]+(\.[\w\.]+)&quot;
str = &quot;Please contact hello@hotmail.com for assistance&quot;

match = re.search(pattern, str)
if match:
   print(match.group())
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
hello@hotmail.com
&lt;/pre&gt;

In case the string contains multiple email addresses, we could use the '''re.findall()''' method instead of '''re.search()''' to extract all email addresses.


* '''[\w\.-]+''' matches one or more word character, dot or dash.
* The regex above says that the string should contain word (with dots and dashes allowed), followed by @ sign, then another similar word, then a dot and another word.

Our regex here contains three groups:
* First part of the email address.
* Domain name without the suffix.
* the domain suffix.</text>
      <sha1>5znqyz75mbk66mshmpwvx7r08m2wbg3</sha1>
    </revision>
    <revision>
      <id>2604</id>
      <parentid>2602</parentid>
      <timestamp>2019-04-08T04:00:16Z</timestamp>
      <contributor>
        <username>Sumitkrsharma01</username>
        <id>3363</id>
      </contributor>
      <minor/>
      <comment>/* NumPy array creation methods */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22520">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 0 and 10 (start, end, n)
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.


=== Email Extraction Program Using Regular Expressions ===
To demonstrate a sample usage of regular expressions, we create a program to extract email addresses from a string.

&lt;pre&gt;
import re

pattern = r&quot;([\w\.-]+)@([\w\.-]+(\.[\w\.]+)&quot;
str = &quot;Please contact hello@hotmail.com for assistance&quot;

match = re.search(pattern, str)
if match:
   print(match.group())
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
hello@hotmail.com
&lt;/pre&gt;

In case the string contains multiple email addresses, we could use the '''re.findall()''' method instead of '''re.search()''' to extract all email addresses.


* '''[\w\.-]+''' matches one or more word character, dot or dash.
* The regex above says that the string should contain word (with dots and dashes allowed), followed by @ sign, then another similar word, then a dot and another word.

Our regex here contains three groups:
* First part of the email address.
* Domain name without the suffix.
* the domain suffix.</text>
      <sha1>0wktbmgvf74bpr5fe9mxvc7p7csmupb</sha1>
    </revision>
    <revision>
      <id>2613</id>
      <parentid>2604</parentid>
      <timestamp>2019-04-08T16:15:37Z</timestamp>
      <contributor>
        <username>Divya98</username>
        <id>2439</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23263">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 0 and 10 (start, end, n)
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


=='''More About Flames Games'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
FLAMES is a popular game named after the acronym: Friends, Lovers, Affectionate, Marriage, Enemies, Sibling. This game does not accurately predict whether or not an individual is right for you, but it can be fun to play this with your friends.

There are two steps in this game:&lt;br/&gt;
'''Get the count :'''
*Take the two names.
*Remove the common characters with their respective common occurrences.
*Get the count of the characters that are left .

'''Get the result :'''

*Take FLAMES letters as [“F”, “L”, “A”, “M”, “E”, “S”]
*Start removing letter using the count we got.
*The letter which last the process is the result.





==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.


=== Email Extraction Program Using Regular Expressions ===
To demonstrate a sample usage of regular expressions, we create a program to extract email addresses from a string.

&lt;pre&gt;
import re

pattern = r&quot;([\w\.-]+)@([\w\.-]+(\.[\w\.]+)&quot;
str = &quot;Please contact hello@hotmail.com for assistance&quot;

match = re.search(pattern, str)
if match:
   print(match.group())
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
hello@hotmail.com
&lt;/pre&gt;

In case the string contains multiple email addresses, we could use the '''re.findall()''' method instead of '''re.search()''' to extract all email addresses.


* '''[\w\.-]+''' matches one or more word character, dot or dash.
* The regex above says that the string should contain word (with dots and dashes allowed), followed by @ sign, then another similar word, then a dot and another word.

Our regex here contains three groups:
* First part of the email address.
* Domain name without the suffix.
* the domain suffix.</text>
      <sha1>493fgjg5aikg0qoj4gwb6ynh2fas8eb</sha1>
    </revision>
    <revision>
      <id>2614</id>
      <parentid>2613</parentid>
      <timestamp>2019-04-08T16:27:03Z</timestamp>
      <contributor>
        <username>Divya98</username>
        <id>2439</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="24450">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 0 and 10 (start, end, n)
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


=='''More About Flames Games'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
FLAMES is a popular game named after the acronym: Friends, Lovers, Affectionate, Marriage, Enemies, Sibling. This game does not accurately predict whether or not an individual is right for you, but it can be fun to play this with your friends.

There are two steps in this game:&lt;br/&gt;
'''Get the count :'''
*Take the two names.
*Remove the common characters with their respective common occurrences.
*Get the count of the characters that are left .

'''Get the result :'''

*Take FLAMES letters as [“F”, “L”, “A”, “M”, “E”, “S”]
*Start removing letter using the count we got.
*The letter which last the process is the result.


=='''Flames Example'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''Input''' :   player1 name : AJAY&lt;br/&gt;
      player 2 name : PRIYA&lt;br/&gt;

'''Output''' : Relationship status : Friends&lt;br/&gt;
'''Explaination:''' &lt;br/&gt;
In above given two names A and Y are common letters which are occuring one time(common count) in both names so we are removing these letters from both names. Now count the total letters that are left here it is 5. Now start removing letters one by one from FLAMES using the count we got and the letter which lasts the process is the result.
Counting is done in anti-clockwise circular fashion.

'''FLAMES'''&lt;br/&gt;
counting is start from F, E is at 5th count so we remove E and start counting again but a this time start from S.&lt;br/&gt;
'''FLAMS'''&lt;br/&gt;
M is at 5th count so we remove M and counting start from S.&lt;br/&gt;
'''FLAS'''&lt;br/&gt;
S is at 5th count so we remove S and counting start from F.&lt;br/&gt;
'''FLA'''&lt;br/&gt;
L is at 5th count so we remove L and counting start from A.&lt;br/&gt;
'''FA'''&lt;br/&gt;
A is at 5th count so we remove A. now we have only one letter is remaining so this is the final answer.&lt;br/&gt;
'''F'''&lt;br/&gt;
So, the relationship is F i.e. Friends .&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.


=== Email Extraction Program Using Regular Expressions ===
To demonstrate a sample usage of regular expressions, we create a program to extract email addresses from a string.

&lt;pre&gt;
import re

pattern = r&quot;([\w\.-]+)@([\w\.-]+(\.[\w\.]+)&quot;
str = &quot;Please contact hello@hotmail.com for assistance&quot;

match = re.search(pattern, str)
if match:
   print(match.group())
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
hello@hotmail.com
&lt;/pre&gt;

In case the string contains multiple email addresses, we could use the '''re.findall()''' method instead of '''re.search()''' to extract all email addresses.


* '''[\w\.-]+''' matches one or more word character, dot or dash.
* The regex above says that the string should contain word (with dots and dashes allowed), followed by @ sign, then another similar word, then a dot and another word.

Our regex here contains three groups:
* First part of the email address.
* Domain name without the suffix.
* the domain suffix.</text>
      <sha1>8zdotfnhc5konkjctg6dt5210xkli9i</sha1>
    </revision>
    <revision>
      <id>2629</id>
      <parentid>2614</parentid>
      <timestamp>2019-04-09T16:42:52Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Email Extraction Program Using Regular Expressions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25231">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 0 and 10 (start, end, n)
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


=='''More About Flames Games'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
FLAMES is a popular game named after the acronym: Friends, Lovers, Affectionate, Marriage, Enemies, Sibling. This game does not accurately predict whether or not an individual is right for you, but it can be fun to play this with your friends.

There are two steps in this game:&lt;br/&gt;
'''Get the count :'''
*Take the two names.
*Remove the common characters with their respective common occurrences.
*Get the count of the characters that are left .

'''Get the result :'''

*Take FLAMES letters as [“F”, “L”, “A”, “M”, “E”, “S”]
*Start removing letter using the count we got.
*The letter which last the process is the result.


=='''Flames Example'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''Input''' :   player1 name : AJAY&lt;br/&gt;
      player 2 name : PRIYA&lt;br/&gt;

'''Output''' : Relationship status : Friends&lt;br/&gt;
'''Explaination:''' &lt;br/&gt;
In above given two names A and Y are common letters which are occuring one time(common count) in both names so we are removing these letters from both names. Now count the total letters that are left here it is 5. Now start removing letters one by one from FLAMES using the count we got and the letter which lasts the process is the result.
Counting is done in anti-clockwise circular fashion.

'''FLAMES'''&lt;br/&gt;
counting is start from F, E is at 5th count so we remove E and start counting again but a this time start from S.&lt;br/&gt;
'''FLAMS'''&lt;br/&gt;
M is at 5th count so we remove M and counting start from S.&lt;br/&gt;
'''FLAS'''&lt;br/&gt;
S is at 5th count so we remove S and counting start from F.&lt;br/&gt;
'''FLA'''&lt;br/&gt;
L is at 5th count so we remove L and counting start from A.&lt;br/&gt;
'''FA'''&lt;br/&gt;
A is at 5th count so we remove A. now we have only one letter is remaining so this is the final answer.&lt;br/&gt;
'''F'''&lt;br/&gt;
So, the relationship is F i.e. Friends .&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.


=== Email Extraction Program Using Regular Expressions ===
To demonstrate a sample usage of regular expressions, we create a program to extract email addresses from a string.

&lt;pre&gt;
import re

pattern = r&quot;([\w\.-]+)@([\w\.-]+(\.[\w\.]+)&quot;
str = &quot;Please contact hello@hotmail.com for assistance&quot;

match = re.search(pattern, str)
if match:
   print(match.group())
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
hello@hotmail.com
&lt;/pre&gt;

In case the string contains multiple email addresses, we could use the '''re.findall()''' method instead of '''re.search()''' to extract all email addresses.


* '''[\w\.-]+''' matches one or more word character, dot or dash.
* The regex above says that the string should contain word (with dots and dashes allowed), followed by @ sign, then another similar word, then a dot and another word.

Our regex here contains three groups:
* First part of the email address.
* Domain name without the suffix.
* the domain suffix.

=== Image Compression Program ===
in the program below change the value of comp from any value from 2 ,4,8,16,32 and see the different images quality.
you can use any image i used india_map.jpg which i downloaded from google.


import numpy
from PIL import Image
im=Image.open(&quot;india_map.jpg&quot;)
comp=32
pixelmap=im.load()
m=numpy.asanyarray(Image.open('india_map.jpg'))
#print(m) # orignial matirx
img=Image.new(im.mode,im.size)
pixelnew=img.load()

for i in range(img.size[0]):
    for j in range(img.size[1]):
        temp=[1,2,3]
        for k in range(3):
          temp[k]=int(pixelmap[i,j][k]/comp)
        pixelnew[i,j]=tuple(temp)
        #print(pixelnew[i,j])
        
        
img.save('india_map1.jpg')

j=numpy.asanyarray(Image.open('india_map1.jpg'))  #reduced matrix</text>
      <sha1>hsjjo1rnicbaacf4zslb9nkkav58bf8</sha1>
    </revision>
    <revision>
      <id>2630</id>
      <parentid>2629</parentid>
      <timestamp>2019-04-09T16:44:12Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Image Compression Program */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25245">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 0 and 10 (start, end, n)
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


=='''More About Flames Games'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
FLAMES is a popular game named after the acronym: Friends, Lovers, Affectionate, Marriage, Enemies, Sibling. This game does not accurately predict whether or not an individual is right for you, but it can be fun to play this with your friends.

There are two steps in this game:&lt;br/&gt;
'''Get the count :'''
*Take the two names.
*Remove the common characters with their respective common occurrences.
*Get the count of the characters that are left .

'''Get the result :'''

*Take FLAMES letters as [“F”, “L”, “A”, “M”, “E”, “S”]
*Start removing letter using the count we got.
*The letter which last the process is the result.


=='''Flames Example'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''Input''' :   player1 name : AJAY&lt;br/&gt;
      player 2 name : PRIYA&lt;br/&gt;

'''Output''' : Relationship status : Friends&lt;br/&gt;
'''Explaination:''' &lt;br/&gt;
In above given two names A and Y are common letters which are occuring one time(common count) in both names so we are removing these letters from both names. Now count the total letters that are left here it is 5. Now start removing letters one by one from FLAMES using the count we got and the letter which lasts the process is the result.
Counting is done in anti-clockwise circular fashion.

'''FLAMES'''&lt;br/&gt;
counting is start from F, E is at 5th count so we remove E and start counting again but a this time start from S.&lt;br/&gt;
'''FLAMS'''&lt;br/&gt;
M is at 5th count so we remove M and counting start from S.&lt;br/&gt;
'''FLAS'''&lt;br/&gt;
S is at 5th count so we remove S and counting start from F.&lt;br/&gt;
'''FLA'''&lt;br/&gt;
L is at 5th count so we remove L and counting start from A.&lt;br/&gt;
'''FA'''&lt;br/&gt;
A is at 5th count so we remove A. now we have only one letter is remaining so this is the final answer.&lt;br/&gt;
'''F'''&lt;br/&gt;
So, the relationship is F i.e. Friends .&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.


=== Email Extraction Program Using Regular Expressions ===
To demonstrate a sample usage of regular expressions, we create a program to extract email addresses from a string.

&lt;pre&gt;
import re

pattern = r&quot;([\w\.-]+)@([\w\.-]+(\.[\w\.]+)&quot;
str = &quot;Please contact hello@hotmail.com for assistance&quot;

match = re.search(pattern, str)
if match:
   print(match.group())
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
hello@hotmail.com
&lt;/pre&gt;

In case the string contains multiple email addresses, we could use the '''re.findall()''' method instead of '''re.search()''' to extract all email addresses.


* '''[\w\.-]+''' matches one or more word character, dot or dash.
* The regex above says that the string should contain word (with dots and dashes allowed), followed by @ sign, then another similar word, then a dot and another word.

Our regex here contains three groups:
* First part of the email address.
* Domain name without the suffix.
* the domain suffix.

=== Image Compression Program ===
in the program below change the value of comp from any value from 2 ,4,8,16,32 and see the different images quality.
you can use any image i used india_map.jpg which i downloaded from google.

&lt;pre&gt;

import numpy
from PIL import Image
im=Image.open(&quot;india_map.jpg&quot;)
comp=32
pixelmap=im.load()
m=numpy.asanyarray(Image.open('india_map.jpg'))
#print(m) # orignial matirx
img=Image.new(im.mode,im.size)
pixelnew=img.load()

for i in range(img.size[0]):
    for j in range(img.size[1]):
        temp=[1,2,3]
        for k in range(3):
          temp[k]=int(pixelmap[i,j][k]/comp)
        pixelnew[i,j]=tuple(temp)
        #print(pixelnew[i,j])
        
        
img.save('india_map1.jpg')

&lt;/pre&gt;

j=numpy.asanyarray(Image.open('india_map1.jpg'))  #reduced matrix</text>
      <sha1>r2u4tc8ozhj4hsvwi6h7v20zawirhnr</sha1>
    </revision>
    <revision>
      <id>2632</id>
      <parentid>2630</parentid>
      <timestamp>2019-04-10T01:13:05Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Regular Expressions ( .* ) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25243">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 0 and 10 (start, end, n)
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


=='''More About Flames Games'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
FLAMES is a popular game named after the acronym: Friends, Lovers, Affectionate, Marriage, Enemies, Sibling. This game does not accurately predict whether or not an individual is right for you, but it can be fun to play this with your friends.

There are two steps in this game:&lt;br/&gt;
'''Get the count :'''
*Take the two names.
*Remove the common characters with their respective common occurrences.
*Get the count of the characters that are left .

'''Get the result :'''

*Take FLAMES letters as [“F”, “L”, “A”, “M”, “E”, “S”]
*Start removing letter using the count we got.
*The letter which last the process is the result.


=='''Flames Example'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''Input''' :   player1 name : AJAY&lt;br/&gt;
      player 2 name : PRIYA&lt;br/&gt;

'''Output''' : Relationship status : Friends&lt;br/&gt;
'''Explaination:''' &lt;br/&gt;
In above given two names A and Y are common letters which are occuring one time(common count) in both names so we are removing these letters from both names. Now count the total letters that are left here it is 5. Now start removing letters one by one from FLAMES using the count we got and the letter which lasts the process is the result.
Counting is done in anti-clockwise circular fashion.

'''FLAMES'''&lt;br/&gt;
counting is start from F, E is at 5th count so we remove E and start counting again but a this time start from S.&lt;br/&gt;
'''FLAMS'''&lt;br/&gt;
M is at 5th count so we remove M and counting start from S.&lt;br/&gt;
'''FLAS'''&lt;br/&gt;
S is at 5th count so we remove S and counting start from F.&lt;br/&gt;
'''FLA'''&lt;br/&gt;
L is at 5th count so we remove L and counting start from A.&lt;br/&gt;
'''FA'''&lt;br/&gt;
A is at 5th count so we remove A. now we have only one letter is remaining so this is the final answer.&lt;br/&gt;
'''F'''&lt;br/&gt;
So, the relationship is F i.e. Friends .&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.


=== Email Extraction Program Using Regular Expressions ===
To demonstrate a sample usage of regular expressions, we create a program to extract email addresses from a string.

&lt;pre&gt;
import re

pattern = r&quot;([\w\.-]+)@([\w\.-]+(\.[\w\.]+)&quot;
str = &quot;Please contact hello@hotmail.com for assistance&quot;

match = re.search(pattern, str)
if match:
   print(match.group())
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
hello@hotmail.com
&lt;/pre&gt;

In case the string contains multiple email addresses, we could use the '''re.findall()''' method instead of '''re.search()''' to extract all email addresses.


* '''[\w\.-]+''' matches one or more word character, dot or dash.
* The regex above says that the string should contain word (with dots and dashes allowed), followed by @ sign, then another similar word, then a dot and another word.

Our regex here contains three groups:
* First part of the email address.
* Domain name without the suffix.
* the domain suffix.

== Image Compression Program ==
in the program below change the value of comp from any value from 2 ,4,8,16,32 and see the different images quality.
you can use any image i used india_map.jpg which i downloaded from google.

&lt;pre&gt;

import numpy
from PIL import Image
im=Image.open(&quot;india_map.jpg&quot;)
comp=32
pixelmap=im.load()
m=numpy.asanyarray(Image.open('india_map.jpg'))
#print(m) # orignial matirx
img=Image.new(im.mode,im.size)
pixelnew=img.load()

for i in range(img.size[0]):
    for j in range(img.size[1]):
        temp=[1,2,3]
        for k in range(3):
          temp[k]=int(pixelmap[i,j][k]/comp)
        pixelnew[i,j]=tuple(temp)
        #print(pixelnew[i,j])
        
        
img.save('india_map1.jpg')

&lt;/pre&gt;

j=numpy.asanyarray(Image.open('india_map1.jpg'))  #reduced matrix</text>
      <sha1>k5e0ir8j76opd3xntlt7pfmnhlybr1v</sha1>
    </revision>
    <revision>
      <id>2633</id>
      <parentid>2632</parentid>
      <timestamp>2019-04-10T01:15:05Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Image Compression Program */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25249">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 0 and 10 (start, end, n)
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


=='''More About Flames Games'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
FLAMES is a popular game named after the acronym: Friends, Lovers, Affectionate, Marriage, Enemies, Sibling. This game does not accurately predict whether or not an individual is right for you, but it can be fun to play this with your friends.

There are two steps in this game:&lt;br/&gt;
'''Get the count :'''
*Take the two names.
*Remove the common characters with their respective common occurrences.
*Get the count of the characters that are left .

'''Get the result :'''

*Take FLAMES letters as [“F”, “L”, “A”, “M”, “E”, “S”]
*Start removing letter using the count we got.
*The letter which last the process is the result.


=='''Flames Example'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''Input''' :   player1 name : AJAY&lt;br/&gt;
      player 2 name : PRIYA&lt;br/&gt;

'''Output''' : Relationship status : Friends&lt;br/&gt;
'''Explaination:''' &lt;br/&gt;
In above given two names A and Y are common letters which are occuring one time(common count) in both names so we are removing these letters from both names. Now count the total letters that are left here it is 5. Now start removing letters one by one from FLAMES using the count we got and the letter which lasts the process is the result.
Counting is done in anti-clockwise circular fashion.

'''FLAMES'''&lt;br/&gt;
counting is start from F, E is at 5th count so we remove E and start counting again but a this time start from S.&lt;br/&gt;
'''FLAMS'''&lt;br/&gt;
M is at 5th count so we remove M and counting start from S.&lt;br/&gt;
'''FLAS'''&lt;br/&gt;
S is at 5th count so we remove S and counting start from F.&lt;br/&gt;
'''FLA'''&lt;br/&gt;
L is at 5th count so we remove L and counting start from A.&lt;br/&gt;
'''FA'''&lt;br/&gt;
A is at 5th count so we remove A. now we have only one letter is remaining so this is the final answer.&lt;br/&gt;
'''F'''&lt;br/&gt;
So, the relationship is F i.e. Friends .&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.


=== Email Extraction Program Using Regular Expressions ===
To demonstrate a sample usage of regular expressions, we create a program to extract email addresses from a string.

&lt;pre&gt;
import re

pattern = r&quot;([\w\.-]+)@([\w\.-]+(\.[\w\.]+)&quot;
str = &quot;Please contact hello@hotmail.com for assistance&quot;

match = re.search(pattern, str)
if match:
   print(match.group())
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
hello@hotmail.com
&lt;/pre&gt;

In case the string contains multiple email addresses, we could use the '''re.findall()''' method instead of '''re.search()''' to extract all email addresses.


* '''[\w\.-]+''' matches one or more word character, dot or dash.
* The regex above says that the string should contain word (with dots and dashes allowed), followed by @ sign, then another similar word, then a dot and another word.

Our regex here contains three groups:
* First part of the email address.
* Domain name without the suffix.
* the domain suffix.

== '''Image Compression Program''' ==
in the program below change the value of comp from any value from 2 ,4,8,16,32 and see the different images quality.
you can use any image i used india_map.jpg which i downloaded from google.

&lt;pre&gt;

import numpy
from PIL import Image
im=Image.open(&quot;india_map.jpg&quot;)
comp=32
pixelmap=im.load()
m=numpy.asanyarray(Image.open('india_map.jpg'))
#print(m) # orignial matirx
img=Image.new(im.mode,im.size)
pixelnew=img.load()

for i in range(img.size[0]):
    for j in range(img.size[1]):
        temp=[1,2,3]
        for k in range(3):
          temp[k]=int(pixelmap[i,j][k]/comp)
        pixelnew[i,j]=tuple(temp)
        #print(pixelnew[i,j])
        
        
img.save('india_map1.jpg')

&lt;/pre&gt;

j=numpy.asanyarray(Image.open('india_map1.jpg'))  #reduced matrix</text>
      <sha1>qiqas49f0bv5u1g54zaucohz9pg9l9m</sha1>
    </revision>
    <revision>
      <id>2634</id>
      <parentid>2633</parentid>
      <timestamp>2019-04-10T01:16:49Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Image Compression Program */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25308">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 0 and 10 (start, end, n)
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


=='''More About Flames Games'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
FLAMES is a popular game named after the acronym: Friends, Lovers, Affectionate, Marriage, Enemies, Sibling. This game does not accurately predict whether or not an individual is right for you, but it can be fun to play this with your friends.

There are two steps in this game:&lt;br/&gt;
'''Get the count :'''
*Take the two names.
*Remove the common characters with their respective common occurrences.
*Get the count of the characters that are left .

'''Get the result :'''

*Take FLAMES letters as [“F”, “L”, “A”, “M”, “E”, “S”]
*Start removing letter using the count we got.
*The letter which last the process is the result.


=='''Flames Example'''==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''Input''' :   player1 name : AJAY&lt;br/&gt;
      player 2 name : PRIYA&lt;br/&gt;

'''Output''' : Relationship status : Friends&lt;br/&gt;
'''Explaination:''' &lt;br/&gt;
In above given two names A and Y are common letters which are occuring one time(common count) in both names so we are removing these letters from both names. Now count the total letters that are left here it is 5. Now start removing letters one by one from FLAMES using the count we got and the letter which lasts the process is the result.
Counting is done in anti-clockwise circular fashion.

'''FLAMES'''&lt;br/&gt;
counting is start from F, E is at 5th count so we remove E and start counting again but a this time start from S.&lt;br/&gt;
'''FLAMS'''&lt;br/&gt;
M is at 5th count so we remove M and counting start from S.&lt;br/&gt;
'''FLAS'''&lt;br/&gt;
S is at 5th count so we remove S and counting start from F.&lt;br/&gt;
'''FLA'''&lt;br/&gt;
L is at 5th count so we remove L and counting start from A.&lt;br/&gt;
'''FA'''&lt;br/&gt;
A is at 5th count so we remove A. now we have only one letter is remaining so this is the final answer.&lt;br/&gt;
'''F'''&lt;br/&gt;
So, the relationship is F i.e. Friends .&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.


=== Email Extraction Program Using Regular Expressions ===
To demonstrate a sample usage of regular expressions, we create a program to extract email addresses from a string.

&lt;pre&gt;
import re

pattern = r&quot;([\w\.-]+)@([\w\.-]+(\.[\w\.]+)&quot;
str = &quot;Please contact hello@hotmail.com for assistance&quot;

match = re.search(pattern, str)
if match:
   print(match.group())
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
hello@hotmail.com
&lt;/pre&gt;

In case the string contains multiple email addresses, we could use the '''re.findall()''' method instead of '''re.search()''' to extract all email addresses.


* '''[\w\.-]+''' matches one or more word character, dot or dash.
* The regex above says that the string should contain word (with dots and dashes allowed), followed by @ sign, then another similar word, then a dot and another word.

Our regex here contains three groups:
* First part of the email address.
* Domain name without the suffix.
* the domain suffix.

== '''Image Compression Program''' ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
in the program below change the value of comp from any value from 2 ,4,8,16,32 and see the different images quality.
you can use any image i used india_map.jpg which i downloaded from google.

&lt;pre&gt;

import numpy
from PIL import Image
im=Image.open(&quot;india_map.jpg&quot;)
comp=32
pixelmap=im.load()
m=numpy.asanyarray(Image.open('india_map.jpg'))
#print(m) # orignial matirx
img=Image.new(im.mode,im.size)
pixelnew=img.load()

for i in range(img.size[0]):
    for j in range(img.size[1]):
        temp=[1,2,3]
        for k in range(3):
          temp[k]=int(pixelmap[i,j][k]/comp)
        pixelnew[i,j]=tuple(temp)
        #print(pixelnew[i,j])
        
        
img.save('india_map1.jpg')

&lt;/pre&gt;

j=numpy.asanyarray(Image.open('india_map1.jpg'))  #reduced matrix</text>
      <sha1>kbdo5vklb345me66bjelfqhmlhka32w</sha1>
    </revision>
    <revision>
      <id>2842</id>
      <parentid>2634</parentid>
      <timestamp>2019-04-15T05:08:35Z</timestamp>
      <contributor>
        <username>Sahdevian</username>
        <id>2302</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25139">==''' NumPy '''==
NumPy is a package for array processing in Python. NumPy provides fast multidimensional array object. It is used for scientific computing. We can perform mathematical and logical operations on arrays.

'''Installing NumPy:'''
pip install numpy


== NumPy Arrays ==
We can create a simple array as follows.

import numpy as np
x = np.array([1,2,3])

NumPy’s array class is called ndarray.
The following are the few attributes of ndarray:

'''ndarray.ndim''' : returns number of dimensions in the array&lt;br/&gt;
'''ndarray.shape''' :  returns tuple of integers indicating the size of the array in each dimension.&lt;br/&gt;
'''ndarray.size''' : the total number of elements of the array. This is equal to the product of the elements of ndarray.shape.&lt;br/&gt;
'''ndarray.dtype''' : describes the data type of the elements in the array.&lt;br/&gt;

== NumPy basic program ==
&lt;syntaxhighlight lang='python' line&gt;
# import numpy
import numpy as np 
  
# create array  
x = np.array( [[ 1, 2, 3], 
                 [ 4, 5, 6]] ) 
  
# type of array object 
print(&quot;type of array is: &quot;, type(x))  
#output: &lt;class 'numpy.ndarray'&gt;

# total number of elements in array 
print(&quot;size of array: &quot;, x.size) #output: 6

# shape of array 
print(&quot;shape of array: &quot;, x.shape)  #output: (2,3)
  
# array dimensions
print(&quot;no. of dimensions: &quot;, x.ndim)  #output: 2
  
# data type of elements in array 
print(&quot;the type of elements &quot;, x.dtype) #output: dtype('int32')

&lt;/syntaxhighlight&gt;&lt;br/&gt;


== NumPy array creation methods==
Following are the methods of array creation: &lt;br/&gt;

'''array''' : to create simple array&lt;br/&gt;
'''zeros''' : creates array in which elements are only zeros&lt;br/&gt;
'''ones''' : creates array in which elements are only ones&lt;br/&gt;
'''arange''' : creates array with elements in increasing order&lt;br/&gt;
'''empty''' : uninitialized array with random values&lt;br/&gt;

'''Sample program for array creation'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np

a = np.array([1,2,3])    # creates [1 2 3]        

b = np.zeros( (2,3) )  
'''creates array of zeros
[[0. 0. 0.]
 [0. 0. 0.]]
'''

c = np.ones( (2,3) )  
'''creates array of ones
[[1. 1. 1.]
[1. 1. 1.]]
'''
d = np.arange(10)
'''creates array of values 0 to 9 in increasing order
[0 1 2 3 4 5 6 7 8 9]'''
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== Operations on NumPy array == 
The following is a program for simple operations on numpy array such as addition, subtraction, transpose, etc
&lt;syntaxhighlight lang='python' line&gt;
import numpy as np
x = np.array( [[1,2],[3,4]] )
y = np.array( [[4,5],[2,1]] )

print(np.add(x,y)) #addition of x,y
'''
[[5 7]
 [5 5]]
'''
print(np.subtract(x,y)) #subtraction of x,y
'''
[[-3 -3]
 [ 1  3]]
'''
print(np.sqrt(x)) #square root  of all elements of x
'''
[[1.         1.41421356]
 [1.73205081 2.        ]]
'''
print(x.T) #transpose of x 
'''
[[1 3]
 [2 4]]
'''
print(np.sum(x,axis = 0)) #column wise sum i.e., [4 6]

print(np.sum(x,axis = 1)) #row wise sum i.e.,[3 7]
&lt;/syntaxhighlight&gt;&lt;br/&gt;



== Various NumPy Operations ==
Numpy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. Moreover, Numpy forms the foundation of the Machine Learning stack.

=== Creating a Vector ===
Here we use Numpy to create a 1-D Array which we then call a vector.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([1,2,3])

#Create vector as a Column
vector_column = np.array([[1],[2],[3]])
&lt;/pre&gt;


=== Creating a Matrix ===
We Create a 2-D Array in Numpy and call it a Matrix. It contains 2 rows and 3 columns. 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6]])
print(matrix)
&lt;/pre&gt;


=== Creating a Sparse Matrix ===
Given data with very few non zero values you want to efficiently represent it. Sparse Matrices store only non zero elements and assume all other values will be zero, leading to significant computational savings.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[0,0],[0,1],[3,0]])
print(matrix)

#Create Compressed Sparse Row(CSR) matrix
matrix_sparse = sparse.csr_matrix(matrix)
print(matrix_sparse)
&lt;/pre&gt;


=== Selecting Elements ===
When you need to select one or more element in a vector or matrix 

&lt;pre&gt;
#Load Library
import numpy as np

#Create a vector as a Row
vector_row = np.array([ 1,2,3,4,5,6 ])

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Select 3rd element of Vector
print(vector_row[2])

#Select 2nd row 2nd column
print(matrix[1,1])

#Select all elements of a vector
print(vector_row[:])

#Select everything up to and including the 3rd element
print(vector_row[:3])

#Select the everything after the 3rd element
print(vector_row[3:])

#Select the last element
print(vector[-1])

#Select the first 2 rows and all the columns of the matrix
print(matrix[:2,:])

#Select all rows and the 2nd column of the matrix
print(matrix[:,1:2])
&lt;/pre&gt;


=== Describing a Matrix ===
When you want to know about the shape size and dimensions of a Matrix.

&lt;pre&gt;
import numpy as np


#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])

#View the Number of Rows and Columns
print(matrix.shape)

#View the number of elements (rows*columns)
print(matrix.size)

#View the number of Dimensions(2 in this case)
print(matrix.ndim)
&lt;/pre&gt;


=== Applying Operations to Elements ===
You want to apply some function to multiple elements in an array. Numpy’s vectorize class converts a function into a function that can apply to multiple elements in an array or slice of an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Create a function that adds 100 to something
add_100 =lambda i: i+100

#Convert it into a vectorized function
vectorized_add_100= np.vectorize(add_100)

#Apply function to all elements in matrix
print(vectorized_add_100(matrix))
&lt;/pre&gt;


=== Finding the Maximum &amp; Minimum Values ===
We use Numpy’s max and min functions:

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Return the max element
print(np.max(matrix))

#Return the min element
print(np.min(matrix))

#To find the max element in each column
print(np.max(matrix,axis=0))

#To find the max element in each row
print(np.max(matrix,axis=1))
&lt;/pre&gt;


=== Calculating Average, Variance &amp; Standard Deviation ===
When you want to calculate some descriptive statistics about an array.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Mean
print(np.mean(matrix))

#Standard Dev.
print(np.std(matrix))

#Variance
print(np.var(matrix))
&lt;/pre&gt;


=== Reshaping Arrays ===
When you want to reshape an array(changing the number of rows and columns) without changing the elements. 


&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Reshape
print(matrix.reshape(9,1))

#Here -1 says as many columns as needed and 1 row
print(matrix.reshape(1,-1))

#If we provide only 1 value Reshape would return a 1-d array of that length
print(marix.reshape(9))

#We can also use the Flatten method to convert a matrix to 1-d array
print(matrix.flatten())
&lt;/pre&gt;


=== Transposing a Vector or a Matrix ===
By transposing you interchange the rows and columns of a Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Transpose the matrix
print(matrix.T)
&lt;/pre&gt;


=== Finding the Determinant &amp; Rank of a Matrix ===
The rank of a Matrix is the number of dimensions of the vector space spanned by its rows or columns.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate the Determinant
print(np.linalg.det(matrix))

#Calculate the Rank
print(np.linalg.matrix_rank(matrix))
&lt;/pre&gt;


=== Getting the Diagonal of a Matrix ===
When you need to extract only the diagonal elements of a matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Principal diagonal
print(matrix.diagonal())

#Print the diagonal one above the Principal diagonal
print(matrix.diagonal(offset=1))

#Print the diagonal one below Principal diagonal
print(matrix.diagonal(offset=-1))
&lt;/pre&gt;


=== Calculating the Trace of Matrix ===
Trace of a Matrix is the sum of elements on the Principal Diagonal of the Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Print the Trace
print(matrix.trace())
&lt;/pre&gt;


=== Finding EigenValues &amp; EigenVectors ===
Eigenvectors are widely used in Machine Learning libraries. Intutively given a linear transformation represented by a matrix,A, eigenvectors are vectors that when that transformation is applied, change only in scale(not direction).

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

# Calculate the Eigenvalues and Eigenvectors of that Matrix
eigenvalues ,eigenvectors=np.linalg.eig(matrix)
print(eigenvalues)
print(eigenvectors)
&lt;/pre&gt;


=== Calculating Dot Products ===
&lt;pre&gt;
#Load Library
import numpy as np

#Create vector-1
vector_1 = np.array([ 1,2,3 ])

#Create vector-2
vector_2 = np.array([ 4,5,6 ])

#Calculate Dot Product
print(np.dot(vector_1,vector_2))

#Alternatively you can use @ to calculate dot products
print(vector_1 @ vector_2)
&lt;/pre&gt;

=== Inverting a Matrix ===
This is used when you want to calculate the inverse of a Square Matrix.

&lt;pre&gt;
#Load Library
import numpy as np

#Create a Matrix
matrix = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(matrix)

#Calculate its inverse
print(np.linalg.inv(matrix))
&lt;/pre&gt;


=== Generating Random Values ===
Numpy offers a wide variety of means to generate Random Numbers.

Moreover, It can sometimes be useful to return the same random numbers to get predictable, repeatable results. We can do so by setting the '''Seed''' (An Integer) of the pseudorandom generator. Random processes with the same seed would always produce the same result.

&lt;pre&gt;
#Load Library
import numpy as np

#Set seed
np.random.seed(1)

#Generate 3 random integers b/w 0 and 10 (start, end, n)
print(np.random.randint(0,11,3))

#Draw 3 numbers from a normal distribution with mean 1.0 and std 2.0
print(np.random.normal(1.0,2.0,3))
&lt;/pre&gt;

==Flames Game==
Flames is a popular game which is an acronym for Friend, Lover, Affection, Marriage, Enemy, Siblings or Sister. It tells about the relationship status between two persons.

'''Procedure:''' &lt;br/&gt;
*Take the names of two persons.&lt;br/&gt;
*Cancel out the common alphabets in both of their names.&lt;br/&gt;
*Then count the number of letters remaining.&lt;br/&gt;
*Take the F L A M E S letters.&lt;br/&gt;
*Start removing the letter in flames at which the count ends.&lt;br/&gt;
*The letter remaining is the end result of the game.&lt;br/&gt;


== Flames Code in Python ==
&lt;pre&gt;
def flames(name1, name2):
    for i in range(len(name1)):
        for j in range(len(name2)):
            if(name1[i]==name2[j]):
                 name2=name2.replace(name2[j],&quot;*&quot;)
                 break
    #print(name1)
    #print(name2)
    t=name2.count('*')*2
    print(t)
    results = ['friend','love','affection','marriage','enemy','sister']
    t=len(name1)+len(name2)-t-1
    #print(t)
    i=-1
    while(len(results)&gt;1):       
        count=-1
        while(count&lt;t):
            count=count+1
            i=(i+1)%len(results)            
        results.remove(results[i-1])      
    return results[0]
    
name1 = input('Enter name of first person: ').casefold()
name2 = input('Enter name of second person: ').casefold()
print('Relationship is', flames(name1, name2))
&lt;/pre&gt;


=='''More About Flames Games'''==
FLAMES is a popular game named after the acronym: Friends, Lovers, Affectionate, Marriage, Enemies, Sibling. This game does not accurately predict whether or not an individual is right for you, but it can be fun to play this with your friends.

There are two steps in this game:&lt;br/&gt;
'''Get the count :'''
*Take the two names.
*Remove the common characters with their respective common occurrences.
*Get the count of the characters that are left .

'''Get the result :'''

*Take FLAMES letters as [“F”, “L”, “A”, “M”, “E”, “S”]
*Start removing letter using the count we got.
*The letter which last the process is the result.


=='''Flames Example'''==
'''Input''' :   player1 name : AJAY&lt;br/&gt;
      player 2 name : PRIYA&lt;br/&gt;

'''Output''' : Relationship status : Friends&lt;br/&gt;
'''Explaination:''' &lt;br/&gt;
In above given two names A and Y are common letters which are occuring one time(common count) in both names so we are removing these letters from both names. Now count the total letters that are left here it is 5. Now start removing letters one by one from FLAMES using the count we got and the letter which lasts the process is the result.
Counting is done in anti-clockwise circular fashion.

'''FLAMES'''&lt;br/&gt;
counting is start from F, E is at 5th count so we remove E and start counting again but a this time start from S.&lt;br/&gt;
'''FLAMS'''&lt;br/&gt;
M is at 5th count so we remove M and counting start from S.&lt;br/&gt;
'''FLAS'''&lt;br/&gt;
S is at 5th count so we remove S and counting start from F.&lt;br/&gt;
'''FLA'''&lt;br/&gt;
L is at 5th count so we remove L and counting start from A.&lt;br/&gt;
'''FA'''&lt;br/&gt;
A is at 5th count so we remove A. now we have only one letter is remaining so this is the final answer.&lt;br/&gt;
'''F'''&lt;br/&gt;
So, the relationship is F i.e. Friends .&lt;br/&gt;


==Josephus Problem==
The Josephus problem consists of n number of people that are arranged in a circle. Each person standing in the circle should kill the person next to them and then hand over the sword or a weapon to next living person. This can be started from any person. This procedure continues until only one person is left alive. The last person is the survivor.&lt;br/&gt;

Let us say there are six persons in the circle numbered one to six. &lt;br/&gt;
123456 &lt;br/&gt;
If person number 1 starts, then he executes person number 2 and hands over the sword to person number 3.&lt;br/&gt;
1x3456 &lt;br/&gt;
Then person number 3 executes number 4.&lt;br/&gt;
1x3x56 &lt;br/&gt;
Similarly, number 5 executes number 6.&lt;br/&gt;
1x3x5x &lt;br/&gt;
After that person number 3 is executed by 1.&lt;br/&gt;
1xxx5x &lt;br/&gt;
and then 1 is executed.&lt;br/&gt;
xxxx5x &lt;br/&gt;
Only number 5 is remaining. &lt;br/&gt;


== Josephus Problem Code in Python ==

=== First Approach ===
&lt;pre&gt;
&gt;&gt;&gt; def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
&lt;/pre&gt;

'''Output''':
&lt;pre&gt;
&gt;&gt;&gt; print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2

&gt;&gt;&gt; print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
&lt;/pre&gt; 

'''Yet another faster way: not showing the killing order'''
&lt;pre&gt;
&gt;&gt;&gt;def josephus(n, k):
        r = 0
        for i in xrange(1, n+1):
            r = (r+k)%i
        return 'Survivor: %d' %r
 
&gt;&gt;&gt; print(josephus(5, 2))
Survivor: 2
&gt;&gt;&gt; print(josephus(41, 3))
Survivor: 30
&lt;/pre&gt;


=== Alternate Solution with a Circular Linked List ===
The function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1]. In the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner. 

&lt;pre&gt;
def josephus(n, k):
    a = list(range(1, n + 1))
    a[n - 1] = 0
    p = 0
    v = []
    while a[p] != p:
        for i in range(k - 2):
            p = a[p]
        v.append(a[p])
        a[p] = a[a[p]]
        p = a[p]
    v.append(p)
    return v
 
josephus(10, 2)
[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]
 
josephus(41, 3)[-1]
30
&lt;/pre&gt;


=== Recursive Solution ===
&lt;pre&gt;
int JosephusHelper(int n,int k)
{
	if(n==1) return 0;  // if there is only one person his index is 0
	return ((JosephusHelper(n-1,k)+k)%n); 
} 
int Josephus(int n,int k)
{
return 1+JosephusHelper(n,k);  //adding 1 to change indexing
}
&lt;/pre&gt;


=== Dynamic Programming Solution ===
&lt;pre&gt;

int Josephus(int n,int k)
{
int result=0; //for n=1
for(int i=2;i&lt;=n;i++)
{
	result=(k+result)%i;
}
return (result+1);  //adding 1 to change indexing;
}
&lt;/pre&gt;

== String Functions in Python ==
Python has several built-in functions associated with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Python programming language and are readily available for us to use.


=== Making Strings Uppercase() &amp; Lowercase() ===
The functions '''str.upper()''' and '''str.lower()''' will return a string with all the letters of an original string converted to upper- or lower-case letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.

The '''str.upper()''' and '''str.lower()''' functions make it easier to evaluate and compare strings by making case consistent throughout. That way if a user writes their name all lower case, we can still determine whether their name is in our database by checking it against an all upper-case version, for example.


=== Boolean Methods ===
Python has some string methods that will evaluate to a Boolean value. These methods are useful when we are creating forms for users to fill in, for example. If we are asking for a post code we will only want to accept a numeric string, but when we are asking for a name, we will only want to accept an alphabetic string.

* '''str.isalnum()''': True if String consists of only alphanumeric characters (no symbols)
* '''str.isalpha()''': True if String consists of only alphabetic characters (no symbols)
* '''str.islower()''': True if String’s alphabetic characters are all lower case
* '''str.isnumeric()''': True if String consists of only numeric characters
* '''str.isspace()''': True if String consists of only whitespace characters
* '''str.istitle()''': True if String is in title case
* '''str.isupper()''': True if String’s alphabetic characters are all upper case

Using the '''str.isnumeric()''' method on the string '''5''' returns a value of '''True''', while using the same method on the string '''abcdef''' returns a value of '''False'''.

Checking whether characters are lower case, upper case, or title case, can help us to sort our data appropriately, as well as provide us with the opportunity to standardize data we collect by checking and then modifying strings as needed. 

Boolean string methods are useful when we want to check whether something a user enters fits within given parameters. 


=== Determining String Length ===
The string method '''len()''' returns the number of characters in a string. This method is useful for when you need to enforce minimum or maximum password lengths, for example, or to truncate larger strings to be within certain limits for use as abbreviations. 

Keep in mind that any character bound by single or double quotation marks — including letters, numbers, whitespace characters, and symbols — will be counted by the len() method.


=== Join Split &amp; Replace Methods ===
* The '''str.join()''' method will concatenate two strings, but in a way that passes one string through another. 
* We can also use the '''str.join()''' method to return a string that is a reversal from the original string.
* The '''str.join()''' method is also useful to combine a list of strings into a new single string. 

* The '''str.split()''' method returns a list of strings that are separated by whitespace if no other parameter is given. 
* We can also use '''str.split()''' to remove certain parts of an original string. 

* The '''str.replace()''' method can take an original string and return an updated string with some replacement.


=== Example ===
&lt;pre&gt;
import string

text = &quot;Monty Python's Flying Circus&quot;

print &quot;upper&quot;, &quot;=&gt;&quot;, string.upper(text)
print &quot;lower&quot;, &quot;=&gt;&quot;, string.lower(text)
print &quot;split&quot;, &quot;=&gt;&quot;, string.split(text)
print &quot;join&quot;, &quot;=&gt;&quot;, string.join(string.split(text), &quot;+&quot;)
print &quot;replace&quot;, &quot;=&gt;&quot;, string.replace(text, &quot;Python&quot;, &quot;Java&quot;)
print &quot;find&quot;, &quot;=&gt;&quot;, string.find(text, &quot;Python&quot;), string.find(text, &quot;Java&quot;)
print &quot;count&quot;, &quot;=&gt;&quot;, string.count(text, &quot;n&quot;)
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
upper =&gt; MONTY PYTHON'S FLYING CIRCUS
lower =&gt; monty python's flying circus
split =&gt; ['Monty', &quot;Python's&quot;, 'Flying', 'Circus']
join =&gt; Monty+Python's+Flying+Circus
replace =&gt; Monty Java's Flying Circus
find =&gt; 6 -1
count =&gt; 3
&lt;/pre&gt;


== Regular Expressions ( .* ) ==
* Regular expressions are a powerful tool for various kinds of string manipulation.
* They are a '''Domain specific Language (DSL)''' that is present as a library in most of the modern programming languages.

They are useful for two main tasks:
* Verifying that strings match a pattern (for instance, that a string has a format of an email address)
* Performing substitutions in a string.

* Domain Specific Languages are highly specialized mini programming languages.
* Private DSL are often used for specific industrial purposes.

'''Regular Expressions''' can be accessed using the '''re''' module which is a part of the standard library.

After we've defined a regular expression, the '''re.match()''' function can be used to determine whether it matches at the beginning of the string.
* If it does, match returns an object representing the match, &amp; if not, it returns None.

Raw strings don't escape anything, which makes use of regular expressions easier.

For example,
&lt;pre&gt;
import re

pattern = r&quot;hello&quot;
if re.match(pattern,&quot;hellohellohello&quot;):
     print(&quot;Match !&quot;)
else:
     print(&quot;No match !&quot;)
&lt;/pre&gt;


* The function '''re.search()''' finds a match of a pattern anywhere in the string.
* The function '''re.findall()''' returns a list of all substrings that match a pattern.
* The function '''re.finditer()''' does the same thing as '''re.findall()''' except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.

These methods include '''group''' which return the string matched, '''&quot;Start&quot;''' &amp; '''&quot;End&quot;''' which return the starting and ending positions of the first match and '''&quot;Span&quot;''' which returns the start and end positions of the first match as a tuple.

&lt;pre&gt;
import re
pattern r&quot;pam&quot;

match = re.search(pattern, &quot;eggspamsausage&quot;)
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
&lt;/pre&gt;


'''Output:'''
&lt;pre&gt;
pam
4
7
(4, 7)
&lt;/pre&gt;


=== Search &amp; Replace ===
One of the most important &quot;re&quot; methods that use regular expressions is '''sub'''.

'''Syntax: re.sub(pattern, repl, string, max = 0)'''

This method replaces all occurrences of the '''pattern''' in '''string''' with '''repl''', substituting all occurrences, unless '''max''' provided. This method returns the modified string.


=== Email Extraction Program Using Regular Expressions ===
To demonstrate a sample usage of regular expressions, we create a program to extract email addresses from a string.

&lt;pre&gt;
import re

pattern = r&quot;([\w\.-]+)@([\w\.-]+(\.[\w\.]+)&quot;
str = &quot;Please contact hello@hotmail.com for assistance&quot;

match = re.search(pattern, str)
if match:
   print(match.group())
&lt;/pre&gt;


'''Output''':
&lt;pre&gt;
hello@hotmail.com
&lt;/pre&gt;

In case the string contains multiple email addresses, we could use the '''re.findall()''' method instead of '''re.search()''' to extract all email addresses.


* '''[\w\.-]+''' matches one or more word character, dot or dash.
* The regex above says that the string should contain word (with dots and dashes allowed), followed by @ sign, then another similar word, then a dot and another word.

Our regex here contains three groups:
* First part of the email address.
* Domain name without the suffix.
* the domain suffix.

== '''Image Compression Program''' ==
in the program below change the value of comp from any value from 2 ,4,8,16,32 and see the different images quality.
you can use any image i used india_map.jpg which i downloaded from google.

&lt;pre&gt;

import numpy
from PIL import Image
im=Image.open(&quot;india_map.jpg&quot;)
comp=32
pixelmap=im.load()
m=numpy.asanyarray(Image.open('india_map.jpg'))
#print(m) # orignial matirx
img=Image.new(im.mode,im.size)
pixelnew=img.load()

for i in range(img.size[0]):
    for j in range(img.size[1]):
        temp=[1,2,3]
        for k in range(3):
          temp[k]=int(pixelmap[i,j][k]/comp)
        pixelnew[i,j]=tuple(temp)
        #print(pixelnew[i,j])
        
        
img.save('india_map1.jpg')

&lt;/pre&gt;

j=numpy.asanyarray(Image.open('india_map1.jpg'))  #reduced matrix</text>
      <sha1>jnu02f70q4b5j6icpsa3nghe6m79k57</sha1>
    </revision>
  </page>
</mediawiki>
