<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>JOCWiki</sitename>
    <dbname>Jocwiki_second</dbname>
    <base>http://sccilabs.org/jocwiki2/index.php/Main_Page</base>
    <generator>MediaWiki 1.30.0</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">JOCWiki</namespace>
      <namespace key="5" case="first-letter">JOCWiki talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
      <namespace key="2600" case="first-letter">Topic</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Lecture Notes:Week 11</title>
    <ns>0</ns>
    <id>916</id>
    <revision>
      <id>2617</id>
      <timestamp>2019-04-08T16:55:37Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <comment>Created page with &quot;== datetime library == The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month...&quot;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3470">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year)
time – Time independent of the day (Hour, minute, second, microsecond)


'''Get current date and time:'''
'''a) current time''' &lt;br/&gt;
import datetime

datetime_object = datetime.datetime.now()
print(datetime_object)

OR&lt;br/&gt;
from datetime import datetime as dt
date_object = dt.today()
print(date_object)

#output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:'''
import datetime

date_object = datetime.date.today()
print(date_object)

#output: 2019-04-08

'''c) Date object '''
import datetime

d = datetime.date(2019, 4, 8)
print(d)

#output: 2019-04-08

== Classes of datetime ==  &lt;br/&gt;

=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object'''
from datetime import time

t = time()
print(t)  #output: 00:00:00

t = time(1,56,34,324534)  #hour, minute, second, microsecond
print(t)  #output: 01:56:34.324534

'''b) time attributes'''
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1
print(&quot;minute:&quot;, a.minute)  #minute: 56
print(&quot;second:&quot;, a.second)   #second: 31
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0


=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
from datetime import datetime

#year, month, day
d1 = datetime(2018, 10, 28)  #2018-10-28 00:00:00
print(d1)

#year, month, day, hour, minute, second, microsecond
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380
print(d2)

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt;</text>
      <sha1>og3n08kepcvwnu5d1ko7yh834ld62h5</sha1>
    </revision>
    <revision>
      <id>2618</id>
      <parentid>2617</parentid>
      <timestamp>2019-04-08T17:02:35Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3526">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year)
time – Time independent of the day (Hour, minute, second, microsecond)


'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime
datetime_object = datetime.datetime.now()
print(datetime_object)

OR&lt;br/&gt;
from datetime import datetime as dt
date_object = dt.today()
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today()
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8)
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==  &lt;br/&gt;

=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()
print(t)  #output: 00:00:00

t = time(1,56,34,324534)  #hour, minute, second, microsecond
print(t)  #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1
print(&quot;minute:&quot;, a.minute)  #minute: 56
print(&quot;second:&quot;, a.second)   #second: 31
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  2018-10-28 00:00:00
print(d1)

##year, month, day, hour, minute, second, microsecond
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380
print(d2) &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt;</text>
      <sha1>7x00dg9qyhba5c42j1o25w3qu1cdaeg</sha1>
    </revision>
    <revision>
      <id>2619</id>
      <parentid>2618</parentid>
      <timestamp>2019-04-08T17:06:48Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <comment>/* datetime library */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3531">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime
datetime_object = datetime.datetime.now()
print(datetime_object)

OR&lt;br/&gt;
from datetime import datetime as dt
date_object = dt.today()
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today()
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8)
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==  &lt;br/&gt;

=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()
print(t)  #output: 00:00:00

t = time(1,56,34,324534)  #hour, minute, second, microsecond
print(t)  #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1
print(&quot;minute:&quot;, a.minute)  #minute: 56
print(&quot;second:&quot;, a.second)   #second: 31
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  2018-10-28 00:00:00
print(d1)

##year, month, day, hour, minute, second, microsecond
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380
print(d2) &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt;</text>
      <sha1>6pg3alqjprq3bosz5smerjo58ketu8a</sha1>
    </revision>
    <revision>
      <id>2620</id>
      <parentid>2619</parentid>
      <timestamp>2019-04-08T17:07:49Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <comment>/* datetime library */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3546">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt
date_object = dt.today()
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today()
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8)
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==  &lt;br/&gt;

=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()
print(t)  #output: 00:00:00

t = time(1,56,34,324534)  #hour, minute, second, microsecond
print(t)  #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1
print(&quot;minute:&quot;, a.minute)  #minute: 56
print(&quot;second:&quot;, a.second)   #second: 31
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  2018-10-28 00:00:00
print(d1)

##year, month, day, hour, minute, second, microsecond
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380
print(d2) &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt;</text>
      <sha1>5gje002xfx99uqyq28mw4q56qjj7u93</sha1>
    </revision>
    <revision>
      <id>2621</id>
      <parentid>2620</parentid>
      <timestamp>2019-04-08T17:10:36Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <comment>/* datetime.time */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3573">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt
date_object = dt.today()
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today()
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8)
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==  &lt;br/&gt;

=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)   #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  2018-10-28 00:00:00
print(d1)

##year, month, day, hour, minute, second, microsecond
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380
print(d2) &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt;</text>
      <sha1>lxi839622dmbjb3zstu32qethmiuzp3</sha1>
    </revision>
    <revision>
      <id>2622</id>
      <parentid>2621</parentid>
      <timestamp>2019-04-08T17:11:59Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <comment>/* datetime.datetime */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3583">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt
date_object = dt.today()
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today()
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8)
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==  &lt;br/&gt;

=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)   #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:

from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  2018-10-28 00:00:00

print(d1)

''' year, month, day, hour, minute, second, microsecond '''

d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt;</text>
      <sha1>amcgfa4tjzcknpr4lnoo5s4x2e9sv40</sha1>
    </revision>
    <revision>
      <id>2623</id>
      <parentid>2622</parentid>
      <timestamp>2019-04-08T17:12:56Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <comment>/* datetime.datetime */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3581">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt
date_object = dt.today()
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today()
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8)
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==  &lt;br/&gt;

=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)   #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:

from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  2018-10-28 00:00:00

print(d1)

   # year, month, day, hour, minute, second, microsecond 

d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt;</text>
      <sha1>f1h4f8gbzfcqw4o7nmwtgwfsoe3wexa</sha1>
    </revision>
    <revision>
      <id>2625</id>
      <parentid>2623</parentid>
      <timestamp>2019-04-09T03:19:48Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3685">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt;</text>
      <sha1>ggioi85dc8at11qadwer3p8gvhs4fil</sha1>
    </revision>
    <revision>
      <id>2626</id>
      <parentid>2625</parentid>
      <timestamp>2019-04-09T03:23:07Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <minor/>
      <comment>/* datetime.datetime */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3704">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) &lt;br/&gt;
&lt;/syntaxhighlight&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt;</text>
      <sha1>oh4gb9enct4vcej9crmk5bssiqau4ge</sha1>
    </revision>
    <revision>
      <id>2627</id>
      <parentid>2626</parentid>
      <timestamp>2019-04-09T03:23:39Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <comment>/* datetime.datetime */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3705">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt;</text>
      <sha1>smnvudd9gyo52bnho2gq12vtyjmcuss</sha1>
    </revision>
    <revision>
      <id>2635</id>
      <parentid>2627</parentid>
      <timestamp>2019-04-10T04:19:09Z</timestamp>
      <contributor>
        <username>Harinder</username>
        <id>3081</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4234">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;</text>
      <sha1>p7taekauv1vfnpu7ggvcjd724nesoyr</sha1>
    </revision>
    <revision>
      <id>2650</id>
      <parentid>2635</parentid>
      <timestamp>2019-04-11T12:10:41Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Calendar */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6039">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Turutle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;</text>
      <sha1>tqay4zeff3d4pxpmqcqtenssi92r107</sha1>
    </revision>
    <revision>
      <id>2651</id>
      <parentid>2650</parentid>
      <timestamp>2019-04-11T12:11:28Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Draw any Google Icon using Turutle */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6045">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;</text>
      <sha1>4ph6gxnwebehfyoc38yoz6v37wu5b7y</sha1>
    </revision>
    <revision>
      <id>2652</id>
      <parentid>2651</parentid>
      <timestamp>2019-04-11T12:26:05Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Draw any Google Icon using Python Turtle */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7271">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''===
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails N=int(total duration of the file in seconds /50) + 2
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)</text>
      <sha1>jk419u8zd3vrz7im6c5pdu4075t3zpv</sha1>
    </revision>
    <revision>
      <id>2653</id>
      <parentid>2652</parentid>
      <timestamp>2019-04-11T12:27:03Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Speech Recognition Python Program for audio wav files larger than 1 min= */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7284">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

&lt;pre&gt;
import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails N=int(total duration of the file in seconds /50) + 2
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;</text>
      <sha1>gjwzsa99re3osdbpyvwkb1h3ec1mthc</sha1>
    </revision>
    <revision>
      <id>2654</id>
      <parentid>2653</parentid>
      <timestamp>2019-04-11T12:27:35Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Speech Recognition Python Program for audio wav files larger than 1 min */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7285">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails N=int(total duration of the file in seconds /50) + 2
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;</text>
      <sha1>kkh07vg88ouu3ql5pzky8ed1022cgmt</sha1>
    </revision>
    <revision>
      <id>2655</id>
      <parentid>2654</parentid>
      <timestamp>2019-04-11T12:30:46Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Speech Recognition Python Program for audio wav files larger than 1 min */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7235">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;</text>
      <sha1>04sw9k4cf94ukh358agqa1fpe4qemi0</sha1>
    </revision>
    <revision>
      <id>2658</id>
      <parentid>2655</parentid>
      <timestamp>2019-04-11T15:55:04Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7883">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;


== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.</text>
      <sha1>j0ae4oxhnml2q5biy0jgsms6pph72c0</sha1>
    </revision>
    <revision>
      <id>2659</id>
      <parentid>2658</parentid>
      <timestamp>2019-04-11T15:56:29Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8274">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;


== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.


== Why to Choose Python Over Java in Selenium ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.</text>
      <sha1>0axa15zhn1tuct3hb0arj6p59z8018e</sha1>
    </revision>
    <revision>
      <id>2660</id>
      <parentid>2659</parentid>
      <timestamp>2019-04-11T15:56:54Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Why to Choose Python Over Java in Selenium */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8276">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;


== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.


== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.</text>
      <sha1>aiz5c4fd9flybdnyu7nwbuxpdv99k3d</sha1>
    </revision>
    <revision>
      <id>2661</id>
      <parentid>2660</parentid>
      <timestamp>2019-04-11T16:06:30Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* What is Selenium ? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9478">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;


== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.


=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.</text>
      <sha1>b8aggtpxe0ryg5yhagir330xxmc9p1z</sha1>
    </revision>
    <revision>
      <id>2662</id>
      <parentid>2661</parentid>
      <timestamp>2019-04-11T16:12:03Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10391">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;


== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.


=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;


== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.


== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 

'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.

'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 

'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.</text>
      <sha1>5r62rnlxbremn16t55plx4fwfid3e7o</sha1>
    </revision>
    <revision>
      <id>2663</id>
      <parentid>2662</parentid>
      <timestamp>2019-04-11T16:14:10Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* What is WebDriver ? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10784">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;


== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.


=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;


== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.


== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>7hnv101jzfwrpdigl7y7wz6p0fcr1h4</sha1>
    </revision>
    <revision>
      <id>2665</id>
      <parentid>2663</parentid>
      <timestamp>2019-04-12T00:43:58Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Speech Recognition Python Program for audio wav files larger than 1 min */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10841">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.


=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;


== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.


== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>q2ho4xel6y324s1z9c0h1gdk6a4ognb</sha1>
    </revision>
    <revision>
      <id>2666</id>
      <parentid>2665</parentid>
      <timestamp>2019-04-12T00:44:29Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Draw any Google Icon using Python Turtle */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10900">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.


=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;


== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.


== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>rs5ndgb81f2zm9oyi22juqorwjz34qx</sha1>
    </revision>
    <revision>
      <id>2685</id>
      <parentid>2666</parentid>
      <timestamp>2019-04-12T14:11:09Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* What is Selenium ? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11249">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

'''Install Selenium in Windows'''
&lt;pre&gt;
How to install selenium   
http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4


Copy Selenium to Anaconda 
http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4


Find Chrome driver location on your system
http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4
&lt;\pre&gt;



=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.


== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>8spqzr11ejzahg10wxwzblt0kw8rshc</sha1>
    </revision>
    <revision>
      <id>2686</id>
      <parentid>2685</parentid>
      <timestamp>2019-04-12T14:12:26Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* What is Selenium ? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11266">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

'''Install Selenium in Windows'''
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4
&lt;\pre&gt;



=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.


== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>62k8y4tvs9cqm5xc4fmysugsnbt5on7</sha1>
    </revision>
    <revision>
      <id>2687</id>
      <parentid>2686</parentid>
      <timestamp>2019-04-12T14:13:11Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* What is Selenium ? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11266">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

'''Install Selenium in Windows'''
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4
&lt;/pre&gt;



=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.


== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>1fa8ouiu2v97w1g3txx9ej0l4poed0s</sha1>
    </revision>
    <revision>
      <id>2688</id>
      <parentid>2687</parentid>
      <timestamp>2019-04-12T14:14:48Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* What is Selenium ? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11270">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=='''Install Selenium in Windows'''==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4
&lt;/pre&gt;



=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.


== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>b0n2xcz6k05me13d6gnui6lo1n1lrw4</sha1>
    </revision>
    <revision>
      <id>2689</id>
      <parentid>2688</parentid>
      <timestamp>2019-04-12T14:16:04Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Install Selenium in Windows */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11268">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;

=='''Install Selenium in Windows'''==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4
&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.


== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>t22p4l7d8xpsynpzvjlleyriaz49a5u</sha1>
    </revision>
    <revision>
      <id>2690</id>
      <parentid>2689</parentid>
      <timestamp>2019-04-12T14:16:49Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Install Selenium in Windows */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11272">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



=='''Install Selenium in Windows'''==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.


== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>q5hj8bg6ar7c2dcjv3fsycsos0e1sra</sha1>
    </revision>
    <revision>
      <id>2691</id>
      <parentid>2690</parentid>
      <timestamp>2019-04-12T14:17:20Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Why to Choose Python Over Java in Selenium ? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11271">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



=='''Install Selenium in Windows'''==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>if5z127rm6b8vn8b1rx9d1k2astzl7e</sha1>
    </revision>
    <revision>
      <id>2692</id>
      <parentid>2691</parentid>
      <timestamp>2019-04-12T14:17:50Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Install Selenium in Windows */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11265">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== '''Draw any Google Icon using Python Turtle''' ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>gztbymk2joay51aionrt4mnvm9a3l44</sha1>
    </revision>
    <revision>
      <id>2693</id>
      <parentid>2692</parentid>
      <timestamp>2019-04-12T14:18:39Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Draw any Google Icon using Python Turtle */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11259">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

=='''Speech Recognition Python Program for audio wav files larger than 1 min'''==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>4828cvnicv9tkdv61e7ucnorl2l18n9</sha1>
    </revision>
    <revision>
      <id>2694</id>
      <parentid>2693</parentid>
      <timestamp>2019-04-12T14:19:47Z</timestamp>
      <contributor>
        <username>Kamalakar</username>
        <id>3019</id>
      </contributor>
      <comment>/* Speech Recognition Python Program for audio wav files larger than 1 min */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11253">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.</text>
      <sha1>6t2hth6ygbqmjm238ueqxvab8d4qsrt</sha1>
    </revision>
    <revision>
      <id>2709</id>
      <parentid>2694</parentid>
      <timestamp>2019-04-13T04:33:36Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12184">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.</text>
      <sha1>0rx4h9g61z5f9loo6yhx57hgvm5f58l</sha1>
    </revision>
    <revision>
      <id>2710</id>
      <parentid>2709</parentid>
      <timestamp>2019-04-13T04:34:58Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Locating elements Using Selenium WebDriver */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12620">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;</text>
      <sha1>iis7fn0pka34ejnsgefjoh3ewd0lxk6</sha1>
    </revision>
    <revision>
      <id>2711</id>
      <parentid>2710</parentid>
      <timestamp>2019-04-13T04:44:18Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Locating elements Using Selenium WebDriver */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15557">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.</text>
      <sha1>qh1n46ffka7qja0jxgqkydusq7wjh3b</sha1>
    </revision>
    <revision>
      <id>2813</id>
      <parentid>2711</parentid>
      <timestamp>2019-04-14T11:01:21Z</timestamp>
      <contributor>
        <username>Divya98</username>
        <id>2439</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="16236">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Browser Automation Whatsapp using Python==
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;</text>
      <sha1>k1thxt53t2nm7qh56bp6beq0csn7fws</sha1>
    </revision>
    <revision>
      <id>2816</id>
      <parentid>2813</parentid>
      <timestamp>2019-04-14T11:08:12Z</timestamp>
      <contributor>
        <username>Divya98</username>
        <id>2439</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="16291">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;</text>
      <sha1>m56ulpki5u4furwtm2qr57ojc8rj4dr</sha1>
    </revision>
    <revision>
      <id>2817</id>
      <parentid>2816</parentid>
      <timestamp>2019-04-14T11:12:58Z</timestamp>
      <contributor>
        <username>Divya98</username>
        <id>2439</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17549">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;</text>
      <sha1>kqazr5i1e6glt1d1ukm8d9sfzr8xrip</sha1>
    </revision>
    <revision>
      <id>2818</id>
      <parentid>2817</parentid>
      <timestamp>2019-04-14T11:19:15Z</timestamp>
      <contributor>
        <username>Divya98</username>
        <id>2439</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17881">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.</text>
      <sha1>rcdmumzi722n6qcfyruyap1m6ajmc76</sha1>
    </revision>
    <revision>
      <id>2819</id>
      <parentid>2818</parentid>
      <timestamp>2019-04-14T11:23:20Z</timestamp>
      <contributor>
        <username>Divya98</username>
        <id>2439</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18212">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;</text>
      <sha1>t1grwupobjlygga93azhdvjj2dqnuc6</sha1>
    </revision>
    <revision>
      <id>2820</id>
      <parentid>2819</parentid>
      <timestamp>2019-04-14T13:03:34Z</timestamp>
      <contributor>
        <username>Divya98</username>
        <id>2439</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18812">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;</text>
      <sha1>3k3jtplwabotm2rzf7ic3kzi0m5fx83</sha1>
    </revision>
    <revision>
      <id>2821</id>
      <parentid>2820</parentid>
      <timestamp>2019-04-14T13:09:50Z</timestamp>
      <contributor>
        <username>Divya98</username>
        <id>2439</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19622">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;</text>
      <sha1>1bzpphygagxui7wr072vd6q5lxdc2sh</sha1>
    </revision>
    <revision>
      <id>2825</id>
      <parentid>2821</parentid>
      <timestamp>2019-04-14T18:46:19Z</timestamp>
      <contributor>
        <username>Divya98</username>
        <id>2439</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19918">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 


==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;</text>
      <sha1>ss4zdcf9vsv8q24kdkz9prl29axj0co</sha1>
    </revision>
    <revision>
      <id>2826</id>
      <parentid>2825</parentid>
      <timestamp>2019-04-14T18:48:19Z</timestamp>
      <contributor>
        <username>Divya98</username>
        <id>2439</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19974">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;</text>
      <sha1>cpfvwdvouate4vjw4vy843dydocjr7u</sha1>
    </revision>
    <revision>
      <id>2827</id>
      <parentid>2826</parentid>
      <timestamp>2019-04-14T18:57:31Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="20683">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.</text>
      <sha1>i0smiti6cno3ry2yftnxjsjfwhdiw49</sha1>
    </revision>
    <revision>
      <id>2828</id>
      <parentid>2827</parentid>
      <timestamp>2019-04-14T19:12:04Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23792">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.</text>
      <sha1>diy7nftuxum482p0jrtzxhj3khxgcu3</sha1>
    </revision>
    <revision>
      <id>2829</id>
      <parentid>2828</parentid>
      <timestamp>2019-04-14T19:17:34Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* DateTime Library */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26392">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;

When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;


=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;

When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;


=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;</text>
      <sha1>ru1anls2zsk6wpn0ty7tb6uzcq13yt6</sha1>
    </revision>
    <revision>
      <id>2830</id>
      <parentid>2829</parentid>
      <timestamp>2019-04-14T19:18:29Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Date Time Representation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26393">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;

=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;

When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;


=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;</text>
      <sha1>0ueeujycch5kfcttn88o9mbfnwdjqn2</sha1>
    </revision>
    <revision>
      <id>2831</id>
      <parentid>2830</parentid>
      <timestamp>2019-04-14T19:18:46Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Date Time Arithmetic */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26394">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;

=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;

=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;</text>
      <sha1>31bzxqgonkc4m6i6xufiqxnzejqwxzz</sha1>
    </revision>
    <revision>
      <id>2832</id>
      <parentid>2831</parentid>
      <timestamp>2019-04-14T19:19:16Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* DateTime Library */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26398">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;</text>
      <sha1>ebirj7gw9jv8hp7kkq7dbso7f917zwu</sha1>
    </revision>
    <revision>
      <id>2833</id>
      <parentid>2832</parentid>
      <timestamp>2019-04-14T19:27:40Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="28994">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.</text>
      <sha1>es9zkd63dkp65ykrzepc3fmswyqngo6</sha1>
    </revision>
    <revision>
      <id>2834</id>
      <parentid>2833</parentid>
      <timestamp>2019-04-14T19:37:16Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30779">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==
&lt;code&gt;Posted By: [[User:Kamalakar|Kamalakar]] &lt;/code&gt;&lt;br/&gt;
&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==
&lt;code&gt;Posted By: [[User:Divya98|Divya98]] &lt;/code&gt;&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>pl24zjtmiclvji2ct1nljueink6aqbo</sha1>
    </revision>
    <revision>
      <id>2841</id>
      <parentid>2834</parentid>
      <timestamp>2019-04-15T05:07:12Z</timestamp>
      <contributor>
        <username>Sahdevian</username>
        <id>2302</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30285">== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>0yl07w5i068di63ah26d8gg9cxxdsdn</sha1>
    </revision>
    <revision>
      <id>2893</id>
      <parentid>2841</parentid>
      <timestamp>2019-04-17T07:48:58Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30381">==Code for Automated FACEBOOK Login==
&lt;syntaxhighlight lang='Python' line&gt;
&lt;/syntaxhighlight&gt;


== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>06gtgtgoy1eqwzd10i0hnt8ovvuaud8</sha1>
    </revision>
    <revision>
      <id>2894</id>
      <parentid>2893</parentid>
      <timestamp>2019-04-17T07:50:26Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <comment>/* Code for Automated FACEBOOK Login */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30442">==Code for Automated FACEBOOK Login==
&lt;syntaxhighlight lang='Python' line&gt;
&lt;/syntaxhighlight&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019

@author: ssmkhrj
&quot;&quot;&quot;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>2pgt0eurcli1otlq6zd4fny9tqyom4h</sha1>
    </revision>
    <revision>
      <id>2895</id>
      <parentid>2894</parentid>
      <timestamp>2019-04-17T07:51:55Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <comment>/* Code for Automated FACEBOOK Login */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30476">==Code for Automated FACEBOOK Login==
&lt;syntaxhighlight lang='Python' line&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019

@author: ssmkhrj
&quot;&quot;&quot;

from selenium import webdriver


&lt;/syntaxhighlight&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>c9230eaj6q6iqdu5tv6hi7a4ik96ijx</sha1>
    </revision>
    <revision>
      <id>2896</id>
      <parentid>2895</parentid>
      <timestamp>2019-04-17T07:52:44Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <comment>/* Code for Automated FACEBOOK Login */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30593">==Code for Automated FACEBOOK Login==
&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)




&lt;/syntaxhighlight&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>fhqdegedzwiqq7sdhr0xbzz1nbz84yi</sha1>
    </revision>
    <revision>
      <id>2897</id>
      <parentid>2896</parentid>
      <timestamp>2019-04-17T08:06:41Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <comment>/* Code for Automated FACEBOOK Login */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30707">==Code for Automated FACEBOOK Login==
&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
p = getpass.getpass(prompt='Enter your fb password')





&lt;/syntaxhighlight&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>gtauawwuidlmvrzdtpabzbiqfiz8cyt</sha1>
    </revision>
    <revision>
      <id>2898</id>
      <parentid>2897</parentid>
      <timestamp>2019-04-17T08:06:58Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <comment>/* Code for Automated FACEBOOK Login */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30907">==Code for Automated FACEBOOK Login==
&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
p = getpass.getpass(prompt='Enter your fb password')

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()





&lt;/syntaxhighlight&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>8z7wadl789vgfs3nrm7xus70607d3c2</sha1>
    </revision>
    <revision>
      <id>2899</id>
      <parentid>2898</parentid>
      <timestamp>2019-04-17T08:08:25Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <comment>/* Code for Automated FACEBOOK Login */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30978">==Code for Automated FACEBOOK Login==
&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
# Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()





&lt;/syntaxhighlight&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>s2b36c8313zqc8wu55lmrm403dqq7zm</sha1>
    </revision>
    <revision>
      <id>2900</id>
      <parentid>2899</parentid>
      <timestamp>2019-04-17T08:10:18Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <comment>/* Code for Automated FACEBOOK Login */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31190">==Code for Automated FACEBOOK Login==
&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()





&lt;/syntaxhighlight&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>loas801obyzin7fos024w7f0evb8sd9</sha1>
    </revision>
    <revision>
      <id>2901</id>
      <parentid>2900</parentid>
      <timestamp>2019-04-17T08:11:20Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <comment>/* Code for Automated FACEBOOK Login */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31255">==Code for Automated FACEBOOK Login==
&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()





&lt;/syntaxhighlight&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>rdeiq696x15qlc4iee60w245a7eicmc</sha1>
    </revision>
    <revision>
      <id>2902</id>
      <parentid>2901</parentid>
      <timestamp>2019-04-17T08:11:46Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <comment>/* Code for Automated FACEBOOK Login */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31316">==Code for Automated FACEBOOK Login==
&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place


log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()





&lt;/syntaxhighlight&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>6krtnlyqxmshn9dshf87vjsbrd4hw7e</sha1>
    </revision>
    <revision>
      <id>2903</id>
      <parentid>2902</parentid>
      <timestamp>2019-04-17T08:12:43Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <comment>/* Code for Automated FACEBOOK Login */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31393">==Code for Automated FACEBOOK Login==
&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()
#After entering the email-id and password, clicking the login button to enter
&lt;/syntaxhighlight&gt;
&lt;br&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>p03auetc8h68qh7fuh30ld394l78sq2</sha1>
    </revision>
    <revision>
      <id>2904</id>
      <parentid>2903</parentid>
      <timestamp>2019-04-17T08:15:14Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <comment>/* Code for Automated FACEBOOK Login */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31436">==Code for Automated FACEBOOK Login==
&lt;code&gt;Posted By: [[User:Som|Som]] &lt;/code&gt;

&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()
#After entering the email-id and password, clicking the login button to enter
&lt;/syntaxhighlight&gt;
&lt;br&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically removes your access and hence if you want to do it you may 
#need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>2kl0588om82uvnviafw36z6szweny0s</sha1>
    </revision>
    <revision>
      <id>2929</id>
      <parentid>2904</parentid>
      <timestamp>2019-04-20T06:12:19Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Speech Recognition Python Program for audio wav files larger than 1 min */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31439">==Code for Automated FACEBOOK Login==
&lt;code&gt;Posted By: [[User:Som|Som]] &lt;/code&gt;

&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()
#After entering the email-id and password, clicking the login button to enter
&lt;/syntaxhighlight&gt;
&lt;br&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically
# removes your access and hence if you want to do it you may 
# need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n \n \n Audio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>jnci1zalkdtv74inlx7bzmedst4lwrb</sha1>
    </revision>
    <revision>
      <id>2930</id>
      <parentid>2929</parentid>
      <timestamp>2019-04-20T06:13:04Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Speech Recognition Python Program for audio wav files larger than 1 min */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31436">==Code for Automated FACEBOOK Login==
&lt;code&gt;Posted By: [[User:Som|Som]] &lt;/code&gt;

&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()
#After entering the email-id and password, clicking the login button to enter
&lt;/syntaxhighlight&gt;
&lt;br&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically
# removes your access and hence if you want to do it you may 
# need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n\n\nAudio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>bsohi3uvmncu1png1o6i28c7bn63m0i</sha1>
    </revision>
    <revision>
      <id>2984</id>
      <parentid>2930</parentid>
      <timestamp>2019-04-25T15:11:02Z</timestamp>
      <contributor>
        <username>Aritraghosh452</username>
        <id>2648</id>
      </contributor>
      <minor/>
      <comment>/* datetime library */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31566">==Code for Automated FACEBOOK Login==
&lt;code&gt;Posted By: [[User:Som|Som]] &lt;/code&gt;

&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()
#After entering the email-id and password, clicking the login button to enter
&lt;/syntaxhighlight&gt;
&lt;br&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;
'''without using variable make the function shorter as-'''
import datetime &lt;br/&gt;
print(datetime.date.today())&lt;br/&gt;
2019-04-25
&gt;&gt;&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically
# removes your access and hence if you want to do it you may 
# need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n\n\nAudio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>lo0jr3kfvgt7kjfmgpg3wtwqshvezo7</sha1>
    </revision>
    <revision>
      <id>2985</id>
      <parentid>2984</parentid>
      <timestamp>2019-04-25T15:13:05Z</timestamp>
      <contributor>
        <username>Aritraghosh452</username>
        <id>2648</id>
      </contributor>
      <minor/>
      <comment>/* datetime library */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31589">==Code for Automated FACEBOOK Login==
&lt;code&gt;Posted By: [[User:Som|Som]] &lt;/code&gt;

&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()
#After entering the email-id and password, clicking the login button to enter
&lt;/syntaxhighlight&gt;
&lt;br&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;
'''without using variable make the function shorter as-'''&lt;br/&gt;
import datetime &lt;br/&gt;
print(datetime.date.today())&lt;br/&gt;
'''output'''&lt;br/&gt;
2019-04-25
&gt;&gt;&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically
# removes your access and hence if you want to do it you may 
# need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n\n\nAudio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>dauwr32qkrb3qna3dbpgt7yi3t3outw</sha1>
    </revision>
    <revision>
      <id>2986</id>
      <parentid>2985</parentid>
      <timestamp>2019-04-25T15:13:44Z</timestamp>
      <contributor>
        <username>Aritraghosh452</username>
        <id>2648</id>
      </contributor>
      <comment>/* datetime library */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31591">==Code for Automated FACEBOOK Login==
&lt;code&gt;Posted By: [[User:Som|Som]] &lt;/code&gt;

&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()
#After entering the email-id and password, clicking the login button to enter
&lt;/syntaxhighlight&gt;
&lt;br&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;

import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;

OR&lt;br/&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)

output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;
'''without using variable make the function shorter as-'''&lt;br/&gt;
import datetime &lt;br/&gt;
print(datetime.date.today())&lt;br/&gt;
'''output'''&lt;br/&gt;
2019-04-25
&lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically
# removes your access and hence if you want to do it you may 
# need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n\n\nAudio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>93hsftartt7sblz5ma8wfxcrpuvnmsx</sha1>
    </revision>
    <revision>
      <id>2987</id>
      <parentid>2986</parentid>
      <timestamp>2019-04-25T16:27:44Z</timestamp>
      <contributor>
        <username>Aritraghosh452</username>
        <id>2648</id>
      </contributor>
      <minor/>
      <comment>/* datetime library */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31845">==Code for Automated FACEBOOK Login==
&lt;code&gt;Posted By: [[User:Som|Som]] &lt;/code&gt;

&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()
#After entering the email-id and password, clicking the login button to enter
&lt;/syntaxhighlight&gt;
&lt;br&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;
&lt;synta lang='xhighlightpython' line&gt;
import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;
&lt;/syntaxhighlight&gt;&lt;br/&gt;
OR&lt;br/&gt;
&lt;synta lang='xhighlightpython' line&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)
&lt;/syntaxhighlight&gt;&lt;br/&gt;
output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
&lt;synta lang='xhighlightpython' line&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)
&lt;/syntaxhighlight&gt;&lt;br/&gt;

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
&lt;synta lang='xhighlightpython' line&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;
'''without using variable make the function shorter as-'''&lt;br/&gt;
import datetime &lt;br/&gt;
&lt;synta lang='xhighlightpython' line&gt;
print(datetime.date.today())&lt;br/&gt;
'''output'''&lt;br/&gt;
2019-04-25
&lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically
# removes your access and hence if you want to do it you may 
# need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n\n\nAudio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>l9v1p25re147kvje0gljeozhngie4zh</sha1>
    </revision>
    <revision>
      <id>2988</id>
      <parentid>2987</parentid>
      <timestamp>2019-04-25T16:30:15Z</timestamp>
      <contributor>
        <username>Aritraghosh452</username>
        <id>2648</id>
      </contributor>
      <comment>/* datetime library */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31845">==Code for Automated FACEBOOK Login==
&lt;code&gt;Posted By: [[User:Som|Som]] &lt;/code&gt;

&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()
#After entering the email-id and password, clicking the login button to enter
&lt;/syntaxhighlight&gt;
&lt;br&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import datetime&lt;br/&gt;
datetime_object = datetime.datetime.now()&lt;br/&gt;
print(datetime_object)&lt;br/&gt;
&lt;/syntaxhighlight&gt;&lt;br/&gt;
OR&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime as dt  &lt;br/&gt;
date_object = dt.today()  &lt;br/&gt;
print(date_object)
&lt;/syntaxhighlight&gt;&lt;br/&gt;
output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import datetime

date_object = datetime.date.today() &lt;br/&gt;
print(date_object)
&lt;/syntaxhighlight&gt;&lt;br/&gt;

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import datetime

d = datetime.date(2019, 4, 8) &lt;br/&gt;
print(d)

output: 2019-04-08 &lt;br/&gt;
'''without using variable make the function shorter as-'''&lt;br/&gt;
import datetime &lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
print(datetime.date.today())&lt;br/&gt;
'''output'''&lt;br/&gt;
2019-04-25
&lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically
# removes your access and hence if you want to do it you may 
# need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n\n\nAudio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>972juv6xspsbamxjlandwkde0el6o9f</sha1>
    </revision>
    <revision>
      <id>2989</id>
      <parentid>2988</parentid>
      <timestamp>2019-04-25T16:36:56Z</timestamp>
      <contributor>
        <username>Aritraghosh452</username>
        <id>2648</id>
      </contributor>
      <comment>/* datetime library */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31848">==Code for Automated FACEBOOK Login==
&lt;code&gt;Posted By: [[User:Som|Som]] &lt;/code&gt;

&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()
#After entering the email-id and password, clicking the login button to enter
&lt;/syntaxhighlight&gt;
&lt;br&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import datetime
datetime_object = datetime.datetime.now()
print(datetime_object)
&lt;/syntaxhighlight&gt;&lt;br/&gt;
OR&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime as dt  
date_object = dt.today()  
print(date_object)
&lt;/syntaxhighlight&gt;&lt;br/&gt;
output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import datetime

date_object = datetime.date.today() 
print(date_object)
&lt;/syntaxhighlight&gt;&lt;br/&gt;

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import datetime

d = datetime.date(2019, 4, 8) 
print(d)
&lt;/syntaxhighlight&gt;&lt;br/&gt;
output: 2019-04-08 &lt;br/&gt;
'''without using variable make the function shorter as-'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import datetime 

print(datetime.date.today())
&lt;/syntaxhighlight&gt;&lt;br/&gt;
'''output'''&lt;br/&gt;
2019-04-25
&lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically
# removes your access and hence if you want to do it you may 
# need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n\n\nAudio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By 
import time 
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;



== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>4wp38805mn7dlp0zyz580q0a458vdyn</sha1>
    </revision>
    <revision>
      <id>3038</id>
      <parentid>2989</parentid>
      <timestamp>2019-04-27T16:44:54Z</timestamp>
      <contributor>
        <username>KuntalPaul</username>
        <id>2843</id>
      </contributor>
      <minor/>
      <comment>/* Code for Browser Automation Whatsapp using Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31834">==Code for Automated FACEBOOK Login==
&lt;code&gt;Posted By: [[User:Som|Som]] &lt;/code&gt;

&lt;syntaxhighlight lang='Python'&gt;
&quot;&quot;&quot;
Created on Wed Apr 17 01:46:40 2019
@author: ssmkhrj
&quot;&quot;&quot;
from selenium import webdriver
import getpass
browser=webdriver.Chrome(&quot;/Users/ssmkhrj/Downloads/chromedriver&quot;)
browser.get(&quot;https://www.facebook.com/&quot;)

e = input(&quot;Enter your email i.e. linked with facebook:\n&quot;)
#Taking the email id from the user and storing it in variable 'e'.
p = getpass.getpass(prompt='Enter your fb password:\n')
#Taking the password from the user and storing it in variable 'e'.
#Note the usage of getpass to keep the password hidden
#But getpass functionality doesn't work on Sypder Console, try Jupyter Notebook for this. 

email = browser.find_element_by_id(&quot;email&quot;)
email.send_keys(e)
#Sending the email address provided by the user in desired place

password = browser.find_element_by_id(&quot;pass&quot;)
password.send_keys(p)
#Sending the password provided by the user in desired place

log_in = browser.find_element_by_id(&quot;loginbutton&quot;)
log_in.click()
#After entering the email-id and password, clicking the login button to enter
&lt;/syntaxhighlight&gt;
&lt;br&gt;

== datetime library ==
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. datetime is a combination of time and date (Month, day, year, hour, second, microsecond). It provides a number of functions to deal with dates, times and time intervals. &lt;br/&gt;
date – Manipulate just date ( Month, day, year) &lt;br/&gt;
time – Time independent of the day (Hour, minute, second, microsecond)

'''Get current date and time:''' &lt;br/&gt;
'''a) current time''' &lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import datetime
datetime_object = datetime.datetime.now()
print(datetime_object)
&lt;/syntaxhighlight&gt;&lt;br/&gt;
OR&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime as dt  
date_object = dt.today()  
print(date_object)
&lt;/syntaxhighlight&gt;&lt;br/&gt;
output: 
2019-04-08 18:54:42.831086 &lt;br/&gt;

'''b) Get current date:''' &lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import datetime

date_object = datetime.date.today() 
print(date_object)
&lt;/syntaxhighlight&gt;&lt;br/&gt;

output: 2019-04-08

'''c) Date object ''' &lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import datetime

d = datetime.date(2019, 4, 8) 
print(d)
&lt;/syntaxhighlight&gt;&lt;br/&gt;
output: 2019-04-08 &lt;br/&gt;
'''without using variable make the function shorter as-'''&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
import datetime 

print(datetime.date.today())
&lt;/syntaxhighlight&gt;&lt;br/&gt;
'''output'''&lt;br/&gt;
2019-04-25
&lt;br/&gt;

== Classes of datetime ==
=== datetime.date ===
It has three attributes year, month, and day.

Example:&lt;br/&gt;
&lt;syntaxhighlight lang='python' line&gt;
from datetime import date

dt = date.today() 
print(dt)

print(&quot;Current year:&quot;, dt.year)
print(&quot;Current month:&quot;, dt.month)
print(&quot;Current day:&quot;, dt.day)

# output:
# 2019-04-08
# Current year: 2019
# Current month: 4
# Current day: 8
&lt;/syntaxhighlight&gt;&lt;br/&gt;

=== datetime.time ===
Its attributes: hour, minute, second, microsecond, and tzinfo.

'''a) time object''' &lt;br/&gt;
from datetime import time

t = time()

print(t)                     #output: 00:00:00

t = time(1,56,34,324534)     #hour, minute, second, microsecond

print(t)                     #output: 01:56:34.324534

'''b) time attributes''' &lt;br/&gt;
from datetime import time

a = time(1, 56, 31)

print(&quot;hour: &quot;, a.hour)   #hour:  1 &lt;br/&gt;
print(&quot;minute:&quot;, a.minute)  #minute: 56 &lt;br/&gt;
print(&quot;second:&quot;, a.second)   #second: 31 &lt;br/&gt;
print(&quot;microsecond:&quot;, a.microsecond)  #microsecond: 0
&lt;br/&gt;

=== datetime.datetime ===
A combination of a date and a time. It has following attributes:
* year, month, day, hour, minute, second, microsecond, and tzinfo.

Example:
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime

d1 = datetime(2018, 10, 28)  # year, month, day  
print(d1)                    #2018-10-28 00:00:00

# year, month, day, hour, minute, second, microsecond 
d2 = datetime(2018, 10, 28, 9, 40, 59, 322380) # 2018-10-28 09:40:59.322380

print(d2) 
&lt;/syntaxhighlight&gt; &lt;br/&gt;

=== datetime.timedelta ===
It represents duration or the difference between two dates.
&lt;syntaxhighlight lang='python' line&gt;
from datetime import datetime, timedelta

current_date = datetime.now()

# future dates
future_date = current_date + timedelta(days=90)

print('Current Date:', current_date)
print('Date after 90 days:', future_date)

# past dates
past_date = current_date - timedelta(days=10)
print('Date before 10 days:', past_date)

# output:
# Current Date: 2019-04-08 19:33:32.856681
# Date after 90 days: 2019-07-07 19:34:28.002737
# Date before 10 days: 2019-03-29 19:33:32.856681
&lt;/syntaxhighlight&gt;&lt;br/&gt;

== PYTZ ==
It is an effecient time zone library in Python.

'''Command for installation:''' pip install pytz

'''pytz attributes:''' &lt;br/&gt;
'''all_timezones''': returns a list of all timezones &lt;br/&gt;
'''common_timezones''': returns a list of commonly used timezones. &lt;br/&gt;

=== Country names with codes ===
&lt;syntaxhighlight lang='python' line&gt;
import pytz
#country names with their codes
for key, val in pytz.country_names.items():
    print(key, '=', val, end='')
    print()

# output:
# AD = Andorra
# AE = United Arab Emirates
# AF = Afghanistan
# ...
# ZW = Zimbabwe
&lt;/syntaxhighlight&gt; &lt;/br&gt;

== Calendar ==
The calendar library in Python allows us to display calendars of any year/month and perform calculations on day, month or year.

'''Example : ''' &lt;br/&gt;
'''1) Calendar of a month : ''' &lt;br/&gt;
import calendar

year = 2019

month = 4

print(calendar.month(year, month))
&lt;br/&gt;

'''2) Calendar of a year : ''' &lt;br/&gt;
import calendar

year = 2019

print(calendar.calendar(year))
&lt;br/&gt;

'''3) Check Leap Year with calendar module : ''' &lt;br/&gt;

import calendar

print(calendar.isleap(2019))       #returns False
&lt;br/&gt;

== Draw any Google Icon using Python Turtle ==

&lt;pre&gt;
#download any  icon from google images and save it upside down into a file called my2.jpg
#for better clarity decrease the inc value, for speed of drawing increase the inc value
#Good for drawing icons of size 200X200 pixels. it will take more time if you increase the picture size

inc=5  # change the value for pixel size
image_name=&quot;my2.jpg&quot;  # name of the image to be converted

from PIL import Image
import turtle 
import time
import tkinter as tk


a=turtle.Turtle()
turtle.bgcolor(&quot;pink&quot;)

# Open our image
im = Image.open(image_name)

rgb_im = im.convert('RGB')
 
width = rgb_im.size[0]
height = rgb_im.size[1]
turtle.setup(width*2,height*2)
print( height,width)
#a.screen.screensize(height,width)
#a.screen.setworldcoordinates(0,0,height,width)
# set some counters for current row and column and total pixels
row = 1
col = 1 
pix = 0

hint=-height/2
wint=-width/2
a.penup()
a.goto(wint,hint)
a.pendown()
# create an empty output row
rowdata = &quot;&quot;
while row &lt; height + 1:
    #print(&quot;&quot;)
    #print(&quot;Row number: &quot; + str(row))
    while col &lt; width + 1:
        
        r, g, b = rgb_im.getpixel((col-1,row-1))
        a.screen.colormode(255)
        a.pencolor(r,g,b)
        a.pensize(inc)
        a.speed('fastest')
        a.pendown()
        #print(col-inc,row-inc)
        a.goto(col+wint,row+hint)
        a.penup()
        
        col = col + inc
        # increment the pixel count
        pix = pix + inc
    
    rowdata = &quot;&quot;
    # increment the row...
    row = row + inc 
    # reset the column count
    col = 1
    a.penup()
    a.goto(wint,row+hint-inc)
    print(row-inc)
print(&quot;completed execution&quot;)

b=input(&quot;enter any character to clear turtle screen and continue&quot;)
#a.reset()
print(&quot;Turtle ready for next program&quot;)

&lt;/pre&gt;

==Speech Recognition Python Program for audio wav files larger than 1 min==

&lt;pre&gt;
# if you use it for more than one hour, google will automatically
# removes your access and hence if you want to do it you may 
# need to purchase the feature

import speech_recognition as sr 
import time

sleep_time=2 # in seconds &gt;0 
total_duration=210 # total duration of the file in seconds 
offset=0 # start from the beginning of the file 
duration=30 # cannot be greater than 60 seconds 

if total_duration%duration != 0:

 N = int(total_duration/duration) + 2  # No of trails 
 
 print(&quot;\n\n&quot;,N)
else:

   N = int(total_duration/duration) + 1
for i in range(1,N):

 Audio_file= &quot;i.wav&quot; # Name of the audio file in Wav format
 r=sr.Recognizer()
 with sr.AudioFile(Audio_file) as source:
   audio=r.record(source,offset=offset,duration = duration)
   time.sleep(sleep_time)
   
 try:
   print(end=&quot;&quot; + r.recognize_google(audio))
   
 except sr.UnknownValueError:
    print(&quot;\n\n\nAudio file failed after &quot;,(i-1)*duration, &quot;seconds to convert to text, Try again \n \n\n&quot; )
    i=i-1
    continue
 finally:
      offset=offset+duration 
       
print(&quot;\n\nCompleted the converstion \n\n&quot;)

&lt;/pre&gt;

== What is Selenium ? ==
Selenium is a tool to test your web application. 

You can do this in various ways, for instance 
* Permit it to tap on buttons
* Enter content in structures 
* Skim your site to check whether everything is &quot;OK&quot; and so on. 


'''Key Points'''
* Selenium is an open-source web-based automation tool. 
* Python language is used with Selenium for testing. It has far less verbose and easy to use than any other programming language
* The Python APIs empower you to connect with the browser through Selenium
* Selenium can send the standard Python commands to different browsers, despite variation in their browser's design.

=== Example 1 ===
* Open a new Firefox browser
* Load the page at the given URL

&lt;pre&gt;
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://seleniumhq.org/')
&lt;/pre&gt;


=== Example 2 ===
* Open a new Firefox browser
* Load the Yahoo homepage
* Search for “seleniumhq”
* Close the browser

&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

browser = webdriver.Firefox()

browser.get('http://www.yahoo.com')
assert 'Yahoo' in browser.title

elem = browser.find_element_by_name('p')  # Find the search box
elem.send_keys('seleniumhq' + Keys.RETURN)

browser.quit()
&lt;/pre&gt;


=== Example 3 ===
Selenium WebDriver is often used as a basis for testing web applications. Here is a simple example using Python’s standard unittest library:

&lt;pre&gt;
import unittest
from selenium import webdriver

class GoogleTestCase(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.addCleanup(self.browser.quit)

    def testPageTitle(self):
        self.browser.get('http://www.google.com')
        self.assertIn('Google', self.browser.title)

if __name__ == '__main__':
    unittest.main(verbosity=2)
&lt;/pre&gt;



==Install Selenium in Windows==
&lt;pre&gt;
1. How to install selenium   
    http://sccilabs.org/jocwiki/index.php/File:Install_selenium.mp4
2. Copy Selenium to Anaconda 
    http://sccilabs.org/jocwiki/index.php/File:Copy_Selenium.mp4
3. Find Chrome driver location on your system
    http://sccilabs.org/jocwiki/index.php/File:Chrome_Driver_file_location.mp4


&lt;/pre&gt;

== Why to Choose Python Over Java in Selenium ? ==
Few points that favor Python over Java to use with Selenium is, 
* Java programs tend to run slower compared to Python programs. 
* Java uses traditional braces to start and ends blocks, while Python uses indentation. 
* Java employs static typing, while Python is dynamically typed. 
* Python is simpler and more compact compared to Java.

== What is WebDriver ? == 
WebDriver is a web automation framework that allows you to execute your tests against different browsers.

WebDriver also enables you to use a programming language in creating your test scripts. We can also use conditional operations like if-then-else or switch-case. We can also perform looping controls like do-while. 


'''WebDriver's Architecture is Simpler'''
* It controls the browser from the OS level
* All you need are your programming language's IDE (which contains your Selenium commands) and a browser.


'''Speed'''
* WebDriver is faster since it speaks directly to the browser uses the browser's own engine to control it. 


'''Real-Life Interaction'''
* WebDriver interacts with page elements in a more realistic way. For example, if you have a disabled text box on a page you were testing, WebDriver really cannot enter any value in it just as how a real person cannot.


'''Browser Support'''
* WebDriver can support the headless HtmlUnit browser 
* HtmlUnit is termed as &quot;headless&quot; because it is an invisible browser - it is GUI-less. 
* It is a very fast browser because no time is spent in waiting for page elements to load. This accelerates your test execution cycles. Since it is invisible to the user, it can only be controlled through automated means.


== Locating elements Using Selenium WebDriver ==
There are various strategies to locate elements in a page. You can use the most appropriate one for your case. Selenium provides the following methods to locate elements in a page:
* find_element_by_id
* find_element_by_name
* find_element_by_xpath
* find_element_by_link_text
* find_element_by_partial_link_text
* find_element_by_tag_name
* find_element_by_class_name
* find_element_by_css_selector

'''To find multiple elements (these methods will return a list):'''
* find_elements_by_name
* find_elements_by_xpath
* find_elements_by_link_text
* find_elements_by_partial_link_text
* find_elements_by_tag_name
* find_elements_by_class_name
* find_elements_by_css_selector

Apart from the public methods given above, there are two private methods which might be useful with locators in page objects. These are the two private methods: '''find_element''' and '''find_elements'''.

'''These are the attributes available for By class:'''
* ID = &quot;id&quot;
* XPATH = &quot;xpath&quot;
* LINK_TEXT = &quot;link text&quot;
* PARTIAL_LINK_TEXT = &quot;partial link text&quot;
* NAME = &quot;name&quot;
* TAG_NAME = &quot;tag name&quot;
* CLASS_NAME = &quot;class name&quot;
* CSS_SELECTOR = &quot;css selector&quot;

'''For Example'''
&lt;pre&gt;
from selenium.webdriver.common.by import By

driver.find_element(By.XPATH, '//button[text()=&quot;Some text&quot;]')
driver.find_elements(By.XPATH, '//button')
&lt;/pre&gt;


=== Locating by Id ===
Use this when you know ''id'' attribute of an element. With this strategy, the first element with the id attribute value matching the location will be returned. If no element has a matching ''id'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by Name ===
Use this when you know ''name'' attribute of an element. With this strategy, the first element with the ''name'' attribute value matching the location will be returned. If no element has a matching ''name'' attribute, a '''NoSuchElementException''' will be raised.


=== Locating by XPath ===
XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.

One of the main reasons for using XPath is when you don’t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.

Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.


=== Locating Hyperlinks by Link Text ===
Use this when you know ''link'' text used within an anchor tag. With this strategy, the first element with the link text value matching the location will be returned. If no element has a matching link text attribute, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Tag Name ===
Use this when you want to locate an element by ''tag name''. With this strategy, the first element with the given tag name will be returned. If no element has a matching tag name, a '''NoSuchElementException''' will be raised.


=== Locating Elements by Class Name ===
Use this when you want to locate an element by ''class attribute name''. With this strategy, the first element with the matching class attribute name will be returned. If no element has a matching ''class attribute name'', a '''NoSuchElementException''' will be raised.


=== Locating Elements by CSS Selectors ===
Use this when you want to locate an element by CSS selector syntax. With this strategy, the first element with the matching CSS selector will be returned. If no element has a matching CSS selector, a '''NoSuchElementException''' will be raised.



==Special Character==

&lt;syntaxhighlight lang='python' line&gt;
import re
string=input()
def run(string): 
    regex = re.compile('[@_!#$%^&amp;*()&lt;&gt;?/\|}{~:]')      
    if(regex.search(string) == None): 
        print(&quot;NO&quot;) 
          
    else: 
        print(&quot;YES&quot;)  
run(string) 
&lt;/syntaxhighlight&gt;


==Browser Automation Whatsapp using Python==

Have you ever wished to automatically wish your friends on their birthdays, or send a set of messages to your friend ( or any Whastapp contact! ) automatically at a pre-set time, or send your friends by sending thousands of random text on whatsapp! Using Browser Automation you can do all of it and much more!&lt;br/&gt;
First you must install these:-&lt;br/&gt;

1) Python Bindings for Selenium ( Browser Automation software )&lt;br/&gt;

'''pip install selenium'''&lt;br/&gt;

2) Chrome webdriver&lt;br/&gt;

Download Chrome driver &lt;br/&gt;

3) Chromium Web Browser( Open source version of chrome browser )&lt;br/&gt;

'''sudo apt-get install chromium-browser'''&lt;br/&gt;


== Code for Browser Automation Whatsapp using Python==

&lt;syntaxhighlight lang='python' line&gt;
from selenium import webdriver 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC 
from selenium.webdriver.common.keys import Keys 
from selenium.webdriver.common.by import By  
  
# Replace below path with the absolute path 
# to chromedriver in your computer 
driver = webdriver.Chrome('/home/Divya/Downloads/chromedriver') 
  
driver.get(&quot;https://web.whatsapp.com/&quot;) 
wait = WebDriverWait(driver, 600) 
  
# Replace 'Friend's Name' with the name of your friend  
# or the name of a group  
target = '&quot;Friend\'s Name&quot;'
  
# Replace the below string with your own message 
string = &quot;Message sent using Python!!!&quot;
  
x_arg = '//span[contains(@title,' + target + ')]'
group_title = wait.until(EC.presence_of_element_located(( 
    By.XPATH, x_arg))) 
group_title.click() 
inp_xpath = '//div[@class=&quot;input&quot;][@dir=&quot;auto&quot;][@data-tab=&quot;1&quot;]'
input_box = wait.until(EC.presence_of_element_located(( 
    By.XPATH, inp_xpath))) 
for i in range(100): 
    input_box.send_keys(string + Keys.ENTER) 
    time.sleep(1)
&lt;/syntaxhighlight&gt;

== Browser Automation Using Selenium==

Selenium is a powerful tool for controlling web browser through program. It is functional for all browsers, works on all major OS and its scripts are written in various languages i.e Python, Java, C# etc, we will be working with Python.&lt;br/&gt;

Mastering Selenium will help you automate your day to day tasks like controlling your tweets, Whatsapp texting and even just googling without actually opening a browser in just 15-30 lines of python code. The limits of automation is endless with selenium.&lt;br/&gt;


== Installation of Selenium==

1.1 Selenium Bindings in Python&lt;br/&gt;
Selenium Python bindings provide a convenient API to access Selenium Web Driver like Firefox,Chrome,etc.&lt;br/&gt;

'''Pip install Selenium''' &lt;br/&gt;

1.2 Web Drivers&lt;br/&gt;
Selenium requires a web driver to interface with the chosen browser.Web drivers is a package to interact with web browser. It interacts with the web browser or a remote web server through a wire protocol which is common to all. You can check out and install the web drivers of your browser choice.&lt;br/&gt;
Chrome:    https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;br/&gt;
Firefox: https://github.com/mozilla/geckodriver/releases&lt;br/&gt;
Safari:    https://webkit.org/blog/6900/webdriver-support-in-safari-10/&lt;br/&gt;

== Conditions for a year to be leap year==

'''These are the conditions for a leap year''' :&lt;br/&gt;
*The year is evenly divisible by 4;
*If the year can be evenly divided by 100, it is NOT a leap year, unless;
*The year is also evenly divisible by 400. Then it is a leap year.


== Code to check year is leap year or not==

&lt;syntaxhighlight lang='python' line&gt;
year=int(input(&quot;Enter year to be checked:&quot;))
if(year%4==0 and year%100!=0 or year%400==0):
    print(&quot;The year is a leap year!)
else:
    print(&quot;The year isn't a leap year!)
&lt;/syntaxhighlight&gt;


== Simple Metacharacters ==
Metacharacters are what make regular expressions more powerful than normal string methods. They allow us to create regular expressions to represent concepts like &quot;one or more repetitions&quot; of a vowel.

The existence of metacharacters poses a problem if we want to create a regular expression (or regex) that matches a literal metacharacter such as &quot;$&quot;. We can do this by escaping the metacharacters by putting a backslash in front of them.

To avoid this, we can use a raw string, which is a normal string with an &quot;r&quot; in front of it.

* '''.(dot)''' matches any character other than a anew line.
* '''^''' and '''$''' match the '''start''' and '''end''' of a string respectively.


== DateTime Library ==

=== Import datetime library ===
Python datetime functions are provided by the library named datetime and in order to use date time functions we need to import this library like below:

'''from datetime import datetime'''


=== Date &amp; Time ===
While using pythons datetime functions, libraries and data structures we will involve with two basic data structures date and time. Date part or object is used to hold date. Time part or object is used to hold time. We can use these separately without providing other part.


=== Current Date ===
Current date or simply now represents date and time we are currently. We will use now function in order to get current date and time. now is provided by datetime object. '''now''' provides current date and time like below:
&lt;pre&gt;
datetime.today()
now=datetime.now()
&lt;/pre&gt;

We see that date time returns following values:
* Year
* Month
* Date
* Hour
* Minute
* Second


=== Datetime Time Zone ===
Every location in the world have different time but in order to make things more properly time zones are created. Time zones are used to synchronize some area time to the same time. The time zone may change according to location. We can get time zone information with '''tzinfo''' command like below.:
&lt;pre&gt;
now=datetime.now()
now.tzinfo
&lt;/pre&gt;


=== Subtract Dates ===
Dates can be also subtracted from each other. This is very useful feature to find the interval between two dates as years, months, days, hours, minutes, seconds.
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
t2-t1
&lt;/pre&gt;


=== Compare Dates ===
We can use normal logical comparison operators like &gt; , &lt; and = 
&lt;pre&gt;
t1=datetime.now()
t2=datetime.now()
if(t1&lt;t2):
    print(&quot;t1 is lower than t2&quot;)
&lt;/pre&gt;


=== Formatters ===
We can use following formatters

* '''%a''' Locale’s abbreviated weekday name.
* '''%A''' Locale’s full weekday name.
* '''%b''' Locale’s abbreviated month name.
* '''%B''' Locale’s full month name.
* '''%c''' Locale’s appropriate date and time representation.
* '''%d''' Day of the month as a decimal number [01,31].
* '''%f''' Microsecond as a decimal number [0,999999], zero-padded on the left
* '''%H''' Hour (24-hour clock) as a decimal number [00,23].
* '''%I''' Hour (12-hour clock) as a decimal number [01,12].
* '''%j''' Day of the year as a decimal number [001,366].
* '''%m''' Month as a decimal number [01,12].
* '''%M''' Minute as a decimal number [00,59].
* '''%p''' Locale’s equivalent of either AM or PM.
* '''%S''' Second as a decimal number [00,61].
* '''%U''' Week number of the year (Sunday as the first day of the week)
* '''%w''' Weekday as a decimal number [0(Sunday),6].
* '''%W''' Week number of the year (Monday as the first day of the week)
* '''%x''' Locale’s appropriate date representation.
* '''%X''' Locale’s appropriate time representation.
* '''%y''' Year without century as a decimal number [00,99].
* '''%Y''' Year with century as a decimal number.
* '''%z''' UTC offset in the form +HHMM or -HHMM.
* '''%Z''' Time zone name (empty string if the object is naive).
* '''%%''' A literal ‘%’ character.


=== Date Time Representation ===
A date and its various parts are represented by using different datetime functions. Also, there are format specifiers which play a role in displaying the alphabetical parts of a date like name of the month or week day. 

For Example,
&lt;pre&gt;
import datetime
print 'The Date Today is  :', datetime.datetime.today()

date_today = datetime.date.today()
print date_today
print 'This Year   :', date_today.year
print 'This Month    :', date_today.month
print 'Month Name:',date_today.strftime('%B')
print 'This Week Day    :', date_today.day
print 'Week Day Name:',date_today.strftime('%A')
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
The Date Today is  : 2018-04-22 15:38:35.835000
2018-04-22
This Year   : 2018
This Month    : 4
Month Name: April
This Week Day    : 22
Week Day Name: Sunday
&lt;/pre&gt;



=== Date Time Arithmetic ===
For calculations involving dates we store the various dates into variables and apply the relevant mathematical operator to these variables. 
&lt;pre&gt;
import datetime 
 
#Capture the First Date
day1 = datetime.date(2018, 2, 12)
print 'day1:', day1.ctime()

# Capture the Second Date
day2 = datetime.date(2017, 8, 18)
print 'day2:', day2.ctime()

# Find the difference between the dates
print 'Number of Days:', day1-day2


date_today  = datetime.date.today() 

# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 
 
# Use Delta for future Date
after_four_days = date_today + no_of_days 
print 'After Four Days:', after_four_days 
&lt;/pre&gt;



When we execute the above code, it produces the following result.
&lt;pre&gt;
day1: Mon Feb 12 00:00:00 2018
day2: Fri Aug 18 00:00:00 2017
Number of Days: 178 days, 0:00:00
Before Four Days: 2018-04-18
After Four Days: 2018-04-26
&lt;/pre&gt;



=== Date Time Comparison ===
Date and time are compared using logical operators. But we must be careful in comparing the right parts of the dates with each other.
&lt;pre&gt; 
import datetime

date_today  = datetime.date.today() 

print 'Today is: ', date_today
# Create a delta of Four Days 
no_of_days = datetime.timedelta(days=4) 

# Use Delta for Past Date
before_four_days = date_today - no_of_days 
print 'Before Four Days:', before_four_days 

after_four_days =  date_today + no_of_days

date1 = datetime.date(2018,4,4)

print 'date1:',date1

if date1 == before_four_days :
    print 'Same Dates'
if date_today &gt; date1:
    print 'Past Date'
if date1 &lt; after_four_days:
    print 'Future Date'
&lt;/pre&gt;


== Calendar Module ==
'''class calendar.Calendar([firstweekday])'''
* Creates a Calendar object. 
* firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.

* A Calendar object provides several methods that can be used for preparing the calendar data for formatting. This class doesn’t do any formatting itself. This is the job of subclasses.

Calendar instances have the following methods:

* '''iterweekdays()'''
* Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.

* '''itermonthdates(year, month)'''
* Return an iterator for the month month (1–12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.

* '''itermonthdays2(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.

* '''itermonthdays(year, month)'''
* Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.

* '''monthdatescalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.

* '''monthdays2calendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.

* '''monthdayscalendar(year, month)'''
* Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.

* '''yeardatescalendar(year[, width])'''
* Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1–7 days. Days are datetime.date objects.

* '''yeardays2calendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.

* '''yeardayscalendar(year[, width])'''
* Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.


== datetime objects ==
A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.

Constructor:

'''class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'''

The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints or longs, in the following ranges:
* MINYEAR &lt;= year &lt;= MAXYEAR
* 1 &lt;= month &lt;= 12
* 1 &lt;= day &lt;= number of days in the given month and year
* 0 &lt;= hour &lt; 24
* 0 &lt;= minute &lt; 60
* 0 &lt;= second &lt; 60
* 0 &lt;= microsecond &lt; 1000000

If an argument outside those ranges is given, '''ValueError''' is raised.


'''Class attributes:'''

* '''datetime.min'''
* The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).

* '''datetime.max'''
* The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).

* '''datetime.resolution'''
* The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).

Instance attributes (read-only):

* '''datetime.year'''
* Between MINYEAR and MAXYEAR inclusive.

* '''datetime.month'''
* Between 1 and 12 inclusive.

* '''datetime.day'''
* Between 1 and the number of days in the given month of the given year.

* '''datetime.hour'''
* In range(24).

* '''datetime.minute'''
* In range(60).

* '''datetime.second'''
* In range(60).

* '''datetime.microsecond'''
* In range(1000000).

* '''datetime.tzinfo'''
* The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.</text>
      <sha1>b1y2n3k42herlrf2mkb2cunqxsqznas</sha1>
    </revision>
  </page>
</mediawiki>
