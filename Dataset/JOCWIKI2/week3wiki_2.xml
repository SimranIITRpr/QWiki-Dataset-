<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>JOCWiki</sitename>
    <dbname>Jocwiki_second</dbname>
    <base>http://sccilabs.org/jocwiki2/index.php/Main_Page</base>
    <generator>MediaWiki 1.30.0</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">JOCWiki</namespace>
      <namespace key="5" case="first-letter">JOCWiki talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
      <namespace key="2600" case="first-letter">Topic</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Lecture Notes:Week 3</title>
    <ns>0</ns>
    <id>382</id>
    <revision>
      <id>749</id>
      <timestamp>2019-02-15T17:21:36Z</timestamp>
      <contributor>
        <username>Ravi4224</username>
        <id>461</id>
      </contributor>
      <comment>Created page with &quot;*for creating list  shopping=[] *to add new data: shopping.append(Data) *to insert data at a desired position shopping.insert(position)//position starts from 0 *to reverse the...&quot;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="258">*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order</text>
      <sha1>5gffci8ms28tu9d2h50jnnwofvxa3jp</sha1>
    </revision>
    <revision>
      <id>750</id>
      <parentid>749</parentid>
      <timestamp>2019-02-15T17:22:51Z</timestamp>
      <contributor>
        <username>Ravi4224</username>
        <id>461</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="395">*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search</text>
      <sha1>smxos2nkxzl3nbcszryaz6hdlky0bb0</sha1>
    </revision>
    <revision>
      <id>753</id>
      <parentid>750</parentid>
      <timestamp>2019-02-16T06:02:31Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="763">*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.</text>
      <sha1>5qo7twqq1tvvfim92ruahpxa18pmcy8</sha1>
    </revision>
    <revision>
      <id>754</id>
      <parentid>753</parentid>
      <timestamp>2019-02-16T06:08:38Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1420">*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)</text>
      <sha1>hiq0sj1b6w4nzqq4jq6oinzuzpmbs4o</sha1>
    </revision>
    <revision>
      <id>755</id>
      <parentid>754</parentid>
      <timestamp>2019-02-16T06:13:31Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2005">*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.</text>
      <sha1>45o1pp0fluulco8yb4pkajrjox0eo9q</sha1>
    </revision>
    <revision>
      <id>756</id>
      <parentid>755</parentid>
      <timestamp>2019-02-16T06:16:23Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2281">*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.</text>
      <sha1>c7i5koungchk78wncdbk5ujy1h3fxuu</sha1>
    </revision>
    <revision>
      <id>757</id>
      <parentid>756</parentid>
      <timestamp>2019-02-16T06:18:24Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2332">
== General Features of List ==
*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search


== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==</text>
      <sha1>mw07fdvknt55mmcx3ll0lslpfvpf0yd</sha1>
    </revision>
    <revision>
      <id>758</id>
      <parentid>757</parentid>
      <timestamp>2019-02-16T06:25:29Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2962">
== General Features of List ==
*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search


== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.</text>
      <sha1>jo323tsy7uwob093lbsl7ms7qj8t7ue</sha1>
    </revision>
    <revision>
      <id>759</id>
      <parentid>758</parentid>
      <timestamp>2019-02-16T06:29:00Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3245">
== General Features of List ==
*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search


== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.</text>
      <sha1>8o86cbl889i35j4ii392gh06qgrda2y</sha1>
    </revision>
    <revision>
      <id>760</id>
      <parentid>759</parentid>
      <timestamp>2019-02-16T07:14:33Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3901">
== General Features of List ==
*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search


== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).</text>
      <sha1>huu5lr2xvtqdgwa716qcdvju4u2sdtw</sha1>
    </revision>
    <revision>
      <id>761</id>
      <parentid>760</parentid>
      <timestamp>2019-02-16T07:15:38Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Opening Files */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3968">
== General Features of List ==
*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search


== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.</text>
      <sha1>mxzqxt7z6fm9177e8iwksa6rpoteekc</sha1>
    </revision>
    <revision>
      <id>763</id>
      <parentid>761</parentid>
      <timestamp>2019-02-16T07:30:10Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4308">
== General Features of List ==
*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search


== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.</text>
      <sha1>9l0g0ecqpif5pqmkz05lrb7j79o83zh</sha1>
    </revision>
    <revision>
      <id>764</id>
      <parentid>763</parentid>
      <timestamp>2019-02-16T07:37:01Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4875">
== General Features of List ==
*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search


== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.</text>
      <sha1>61cix4lnq4yxmwb6sq06q6xb0tkgq8c</sha1>
    </revision>
    <revision>
      <id>768</id>
      <parentid>764</parentid>
      <timestamp>2019-02-16T14:14:02Z</timestamp>
      <contributor>
        <username>Ravi4224</username>
        <id>461</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5146">
== General Features of List ==
*for creating list
 shopping=[]
*to add new data:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.</text>
      <sha1>04m1x95bwfr0t5m7uw4wczjtiidhp5s</sha1>
    </revision>
    <revision>
      <id>777</id>
      <parentid>768</parentid>
      <timestamp>2019-02-17T08:21:59Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5796">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
This method is used mainly when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
shopping.append(Data)
*to insert data at a desired position
shopping.insert(position)//position starts from 0
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.</text>
      <sha1>aasytc9dqhly35i18vmkx75uzf4gn9i</sha1>
    </revision>
    <revision>
      <id>779</id>
      <parentid>777</parentid>
      <timestamp>2019-02-17T08:38:56Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6033">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
This method is used mainly when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
shopping.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.</text>
      <sha1>iwrqku6q1ttcq7ol5us7l8scwb0y9uc</sha1>
    </revision>
    <revision>
      <id>780</id>
      <parentid>779</parentid>
      <timestamp>2019-02-17T08:40:18Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6034">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
This method is used mainly when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.</text>
      <sha1>c8fezmzgizqlllklkru3v6377u5t5a1</sha1>
    </revision>
    <revision>
      <id>781</id>
      <parentid>780</parentid>
      <timestamp>2019-02-17T08:41:29Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6036">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is used mainly when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.</text>
      <sha1>tm419lqjgkb49i2l0iuhg413dzmmaph</sha1>
    </revision>
    <revision>
      <id>782</id>
      <parentid>781</parentid>
      <timestamp>2019-02-17T08:42:21Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6036">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
shopping.reverse()
*to sort a list
shopping.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.</text>
      <sha1>6xi899nkwjseriwh7vko8wmiu9m77lo</sha1>
    </revision>
    <revision>
      <id>784</id>
      <parentid>782</parentid>
      <timestamp>2019-02-17T09:17:04Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6038">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.</text>
      <sha1>d51i835c8wqdkqn5fot5mhiet2ofdgy</sha1>
    </revision>
    <revision>
      <id>789</id>
      <parentid>784</parentid>
      <timestamp>2019-02-17T10:40:51Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Reading Files */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6510">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.</text>
      <sha1>5mpf9k5qlbt84nhjeikq4ts8n4f4f4z</sha1>
    </revision>
    <revision>
      <id>790</id>
      <parentid>789</parentid>
      <timestamp>2019-02-17T10:45:45Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6969">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>n1etrauv60l7zygjhhqgfdcdferauu0</sha1>
    </revision>
    <revision>
      <id>840</id>
      <parentid>790</parentid>
      <timestamp>2019-02-18T13:09:10Z</timestamp>
      <contributor>
        <username>Jaiprince17</username>
        <id>2120</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7226">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*
== General Features of List ==
fizz buzz simple with if conditions

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      if(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      if(i%5==0):
          print(str(i)+&quot;=buzz&quot;)

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>speux7qh21jy7yzuvjedfe2hp86s9hy</sha1>
    </revision>
    <revision>
      <id>841</id>
      <parentid>840</parentid>
      <timestamp>2019-02-18T13:11:53Z</timestamp>
      <contributor>
        <username>Jaiprince17</username>
        <id>2120</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7202">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*
== fizz buzz simple with if conditions ==


for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      if(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      if(i%5==0):
          print(str(i)+&quot;=buzz&quot;)

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>4w0ppohcqj61njbj1zn120kcycab6uu</sha1>
    </revision>
    <revision>
      <id>843</id>
      <parentid>841</parentid>
      <timestamp>2019-02-18T14:12:35Z</timestamp>
      <contributor>
        <username>Raghav</username>
        <id>1067</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7203">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()//sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]/// displays shopping[0],[1],[2],[3]
* to get the length of a list
len(shopping)// gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==


for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      if(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      if(i%5==0):
          print(str(i)+&quot;=buzz&quot;)

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>pzyj85bjliwvbmavyjtbb2mnemkrivw</sha1>
    </revision>
    <revision>
      <id>844</id>
      <parentid>843</parentid>
      <timestamp>2019-02-18T14:31:23Z</timestamp>
      <contributor>
        <username>Raghav</username>
        <id>1067</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7205">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==


for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      if(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      if(i%5==0):
          print(str(i)+&quot;=buzz&quot;)

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>jcsmyc3v7zuf6bil9riiw3krss2mcjy</sha1>
    </revision>
    <revision>
      <id>848</id>
      <parentid>844</parentid>
      <timestamp>2019-02-18T16:12:37Z</timestamp>
      <contributor>
        <username>Debasmita</username>
        <id>896</id>
      </contributor>
      <comment>/* fizz buzz simple with if conditions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7245">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==


for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>851mnb9herf1n0bf4sjxsi9uaptn25u</sha1>
    </revision>
    <revision>
      <id>851</id>
      <parentid>848</parentid>
      <timestamp>2019-02-18T18:43:26Z</timestamp>
      <contributor>
        <username>Raghav</username>
        <id>1067</id>
      </contributor>
      <comment>/* fizz buzz simple with if conditions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7454">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz. 

== fizz buzz simple with if conditions ==


for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>nby84i67eqy4vm22qo8hn07j341bsrx</sha1>
    </revision>
    <revision>
      <id>852</id>
      <parentid>851</parentid>
      <timestamp>2019-02-18T18:43:58Z</timestamp>
      <contributor>
        <username>Raghav</username>
        <id>1067</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7245">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==


for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>851mnb9herf1n0bf4sjxsi9uaptn25u</sha1>
    </revision>
    <revision>
      <id>853</id>
      <parentid>852</parentid>
      <timestamp>2019-02-18T18:44:17Z</timestamp>
      <contributor>
        <username>Raghav</username>
        <id>1067</id>
      </contributor>
      <comment>/* fizz buzz simple with if conditions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7452">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>pags3hg013x35x0y1hlivsy6v1df8jk</sha1>
    </revision>
    <revision>
      <id>856</id>
      <parentid>853</parentid>
      <timestamp>2019-02-19T03:39:37Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8371">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats
Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,
             200,200,220,220,220,220,234,250,250,250,
             250,250,250,250,250,250,263,270,275,275,
             286,300,300,300,300,300,300,300,300,320,
             350,350,350,400,400,400,400,400,450,467,
             500,500,500,500,500,500,500,550,550,600,
             600,600,650,700,700,720]
Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(m)
#above two line are substitute for below lines. And &quot;stats&quot; where imported for above line.
#trm_val=int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;


== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>80vt7lzjqnoj479ou46d8csxd22lnmm</sha1>
    </revision>
    <revision>
      <id>857</id>
      <parentid>856</parentid>
      <timestamp>2019-02-19T03:41:45Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8358">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(m)
#above two line are substitute for below lines. And &quot;stats&quot; where imported for above line.
#trm_val=int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>ddudshnkexg4nw6c8qmjpivt0j8aorg</sha1>
    </revision>
    <revision>
      <id>858</id>
      <parentid>857</parentid>
      <timestamp>2019-02-19T03:42:19Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8364">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(m)
#above two line are substitute for below lines. And &quot;stats&quot; where imported for above line.
#trm_val=int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>siqtl81thfkx9k9qxp32h06sf3ujgeo</sha1>
    </revision>
    <revision>
      <id>859</id>
      <parentid>858</parentid>
      <timestamp>2019-02-19T03:44:02Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8407">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>cga43qxhl6tl9gev8lln19c03l6uooq</sha1>
    </revision>
    <revision>
      <id>878</id>
      <parentid>859</parentid>
      <timestamp>2019-02-19T10:56:25Z</timestamp>
      <contributor>
        <username>Raghav</username>
        <id>1067</id>
      </contributor>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8641">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

'''To plot data using Python'''
import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>icvuip0i24i9e7p6h5jfx72ge8st7qk</sha1>
    </revision>
    <revision>
      <id>879</id>
      <parentid>878</parentid>
      <timestamp>2019-02-19T10:57:04Z</timestamp>
      <contributor>
        <username>Raghav</username>
        <id>1067</id>
      </contributor>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8642">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))

'''To plot data using Python'''
import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis &lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>ow6u9vw2cmu5ozbr36mpk0rb88d978w</sha1>
    </revision>
    <revision>
      <id>880</id>
      <parentid>879</parentid>
      <timestamp>2019-02-19T10:57:41Z</timestamp>
      <contributor>
        <username>Raghav</username>
        <id>1067</id>
      </contributor>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8648">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))

''''''To plot data using Python''''''
import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis &lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>5xhqkt5rlsmmzgcb1p60tru2esdavxo</sha1>
    </revision>
    <revision>
      <id>881</id>
      <parentid>880</parentid>
      <timestamp>2019-02-19T10:58:46Z</timestamp>
      <contributor>
        <username>Raghav</username>
        <id>1067</id>
      </contributor>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8642">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))

'''To plot data using Python'''
import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis
&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.</text>
      <sha1>00yzkoiewjmni3of2pffs8t1gms9tu8</sha1>
    </revision>
    <revision>
      <id>897</id>
      <parentid>881</parentid>
      <timestamp>2019-02-19T18:23:37Z</timestamp>
      <contributor>
        <username>Raghav</username>
        <id>1067</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8899">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))

'''To plot data using Python'''
import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis
&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>3meq9ecco3stpddlzohmx3mvnpiblab</sha1>
    </revision>
    <revision>
      <id>905</id>
      <parentid>897</parentid>
      <timestamp>2019-02-19T23:18:01Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8905">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))

==='''To plot data using Python'''===
import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis
&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>h7ned7mgyofw61b7n6x78gcr184dvlx</sha1>
    </revision>
    <revision>
      <id>906</id>
      <parentid>905</parentid>
      <timestamp>2019-02-19T23:19:32Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8924">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

=== '''To plot data using Python''' ===
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>8wi4y1e5gczkaw8jccxafm4w95twpka</sha1>
    </revision>
    <revision>
      <id>907</id>
      <parentid>906</parentid>
      <timestamp>2019-02-19T23:19:45Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* To plot data using Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8918">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

=== To plot data using Python ===
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>o7vmu2c63x5zqwhgvd858kfg9ckxy66</sha1>
    </revision>
    <revision>
      <id>908</id>
      <parentid>907</parentid>
      <timestamp>2019-02-19T23:20:01Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* To plot data using Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8924">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value
*

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

=== To plot data using Python ===
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>dx3gwe3qb7igve0eg7r1y1g916hatyf</sha1>
    </revision>
    <revision>
      <id>909</id>
      <parentid>908</parentid>
      <timestamp>2019-02-19T23:20:22Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8922">
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.
== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

=== To plot data using Python ===
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>6mf0kmz0vmh91iq3s3vw7luhgm6guz7</sha1>
    </revision>
    <revision>
      <id>910</id>
      <parentid>909</parentid>
      <timestamp>2019-02-19T23:44:37Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8944">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

=== To plot data using Python ===
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>4nuyke88vj1ezt0blst5r5bk1ulix6u</sha1>
    </revision>
    <revision>
      <id>911</id>
      <parentid>910</parentid>
      <timestamp>2019-02-19T23:46:53Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Data structures */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9001">== [https://docs.python.org/3/tutorial/datastructures.html Data structures] ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

=== To plot data using Python ===
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>glwmvaeucb4pky49ui7roy5wxerapgn</sha1>
    </revision>
    <revision>
      <id>912</id>
      <parentid>911</parentid>
      <timestamp>2019-02-19T23:48:10Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Data structures */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9068">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

for i in range(1,51):

      if(i%3==0 and i%5==0):
           print(str(i)+&quot;=fizzbuzz&quot;)
      elif(i%3==0):
          print(str(i)+&quot;=fizz&quot;)
      elif(i%5==0):
          print(str(i)+&quot;=buzz&quot;)
      else:
          print(str(i))


== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

=== To plot data using Python ===
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>bg7tm5p9r4bz4cedo0dxww0b72mi9fm</sha1>
    </revision>
    <revision>
      <id>934</id>
      <parentid>912</parentid>
      <timestamp>2019-02-20T21:40:23Z</timestamp>
      <contributor>
        <username>Lalit</username>
        <id>3136</id>
      </contributor>
      <comment>/* fizz buzz simple with if conditions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9148">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)

== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

=== To plot data using Python ===
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>adm8usavwypum8hfb0bdf962tdmu5hx</sha1>
    </revision>
    <revision>
      <id>935</id>
      <parentid>934</parentid>
      <timestamp>2019-02-20T21:40:47Z</timestamp>
      <contributor>
        <username>Lalit</username>
        <id>3136</id>
      </contributor>
      <comment>/* fizz buzz simple with if conditions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9149">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== fizz buzz simple with if conditions ==

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)

== Crowd Computing Code ==

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

=== To plot data using Python ===
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>euj7oeqyyhmdcxui5jisq0si2ztk019</sha1>
    </revision>
    <revision>
      <id>938</id>
      <parentid>935</parentid>
      <timestamp>2019-02-21T05:01:33Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12864">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)

=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program.

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # print out some text 
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    print(&quot;\t&quot;*2, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=input(&quot;- What is your guess: &quot;)
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    name_p1=input(&quot;Player 1, Please enter your name: &quot;)
    name_p2=input(&quot;Player 2, Please enter your name: &quot;)
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    #As this is a two player game, we need 2 while loop runs to finish one round.
    #So we are doubling the round count here.
    rounds = rounds*2
#    rounds=0
    turn=0
    score_p1=0
    score_p2=0
#    chances=3
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    
play()&lt;/nowiki&gt;&lt;br /&gt;



== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>1y03h2vj1izhec9fkyk9jwsyg80lzrq</sha1>
    </revision>
    <revision>
      <id>939</id>
      <parentid>938</parentid>
      <timestamp>2019-02-21T05:02:35Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Week-3 Game programs */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12868">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program.

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # print out some text 
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    print(&quot;\t&quot;*2, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=input(&quot;- What is your guess: &quot;)
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    name_p1=input(&quot;Player 1, Please enter your name: &quot;)
    name_p2=input(&quot;Player 2, Please enter your name: &quot;)
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    #As this is a two player game, we need 2 while loop runs to finish one round.
    #So we are doubling the round count here.
    rounds = rounds*2
#    rounds=0
    turn=0
    score_p1=0
    score_p2=0
#    chances=3
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    
play()&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>cako0t4big5u8lz6ho500irakvtrf6v</sha1>
    </revision>
    <revision>
      <id>940</id>
      <parentid>939</parentid>
      <timestamp>2019-02-21T05:08:05Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12950">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program.

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # print out some text 
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    print(&quot;\t&quot;*2, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=input(&quot;- What is your guess: &quot;)
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    name_p1=input(&quot;Player 1, Please enter your name: &quot;)
    name_p2=input(&quot;Player 2, Please enter your name: &quot;)
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>8hphf2z3w993wct0ooks8e4hm49sica</sha1>
    </revision>
    <revision>
      <id>941</id>
      <parentid>940</parentid>
      <timestamp>2019-02-21T05:10:47Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12975">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program.

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    print(&quot;\t&quot;*2, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=input(&quot;- What is your guess: &quot;)
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    name_p1=input(&quot;Player 1, Please enter your name: &quot;)
    name_p2=input(&quot;Player 2, Please enter your name: &quot;)
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>h1r85h1ve9ren447d1vb8hynms4wsw2</sha1>
    </revision>
    <revision>
      <id>943</id>
      <parentid>941</parentid>
      <timestamp>2019-02-21T05:36:49Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13280">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program.

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    print(&quot;\t&quot;*2, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=input(&quot;- What is your guess: &quot;)
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    name_p1=input(&quot;Player 1, Please enter your name: &quot;)
    name_p2=input(&quot;Player 2, Please enter your name: &quot;)
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>c303lrmqawxmjfnynrk2l0crm2t7hsn</sha1>
    </revision>
    <revision>
      <id>944</id>
      <parentid>943</parentid>
      <timestamp>2019-02-21T05:37:33Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13282">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program.

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    print(&quot;\t&quot;*2, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=input(&quot;- What is your guess: &quot;)
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    name_p1=input(&quot;Player 1, Please enter your name: &quot;)
    name_p2=input(&quot;Player 2, Please enter your name: &quot;)
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;



== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>p25mkwgiefo8ztdcz44yz63fzsk74cb</sha1>
    </revision>
    <revision>
      <id>958</id>
      <parentid>944</parentid>
      <timestamp>2019-02-21T06:58:56Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13430">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. And also, I have added a condition to random, so that we will never get a unjumbled output.

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    print(&quot;\t&quot;*2, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=input(&quot;- What is your guess: &quot;)
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    name_p1=input(&quot;Player 1, Please enter your name: &quot;)
    name_p2=input(&quot;Player 2, Please enter your name: &quot;)
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer between 1 to 5.

2) random.randrange(1,5) -- Generates a random integer between 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>kiflu4itiyn0k7r1w9si56kdhes2ukg</sha1>
    </revision>
    <revision>
      <id>972</id>
      <parentid>958</parentid>
      <timestamp>2019-02-21T14:11:44Z</timestamp>
      <contributor>
        <username>Shreedevi P</username>
        <id>1239</id>
      </contributor>
      <minor/>
      <comment>/* Important Random Library Functions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13424">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. And also, I have added a condition to random, so that we will never get a unjumbled output.

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    print(&quot;\t&quot;*2, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=input(&quot;- What is your guess: &quot;)
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    name_p1=input(&quot;Player 1, Please enter your name: &quot;)
    name_p2=input(&quot;Player 2, Please enter your name: &quot;)
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 to 1.</text>
      <sha1>2prfhrna1xib0z8yo9e01reh15q9xwc</sha1>
    </revision>
    <revision>
      <id>973</id>
      <parentid>972</parentid>
      <timestamp>2019-02-21T14:12:18Z</timestamp>
      <contributor>
        <username>Shreedevi P</username>
        <id>1239</id>
      </contributor>
      <minor/>
      <comment>/* Important Random Library Functions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13425">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. And also, I have added a condition to random, so that we will never get a unjumbled output.

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    print(&quot;\t&quot;*2, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=input(&quot;- What is your guess: &quot;)
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    name_p1=input(&quot;Player 1, Please enter your name: &quot;)
    name_p2=input(&quot;Player 2, Please enter your name: &quot;)
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>jzn8z2ouee5mig2houbit3q3bld9z8j</sha1>
    </revision>
    <revision>
      <id>983</id>
      <parentid>973</parentid>
      <timestamp>2019-02-21T17:45:10Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13431">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    print(&quot;\t&quot;*2, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=input(&quot;- What is your guess: &quot;)
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    name_p1=input(&quot;Player 1, Please enter your name: &quot;)
    name_p2=input(&quot;Player 2, Please enter your name: &quot;)
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>sgri19dorr6ipmeg1g3vw0dkmwmtoqc</sha1>
    </revision>
    <revision>
      <id>984</id>
      <parentid>983</parentid>
      <timestamp>2019-02-21T17:47:00Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13506">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>ev3dnn2qtuqvzw8nj845owe87ev9b2t</sha1>
    </revision>
    <revision>
      <id>985</id>
      <parentid>984</parentid>
      <timestamp>2019-02-21T17:50:40Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13587">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== Crowd Computing Code ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----
=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>hwwyrj1rum38d8pl2hwyk6fwrdvgbjz</sha1>
    </revision>
    <revision>
      <id>986</id>
      <parentid>985</parentid>
      <timestamp>2019-02-21T17:54:53Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13594">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== Jumbled Words Game ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>4cqy15b2ti1w85bgnyefm2l96kgtw8e</sha1>
    </revision>
    <revision>
      <id>987</id>
      <parentid>986</parentid>
      <timestamp>2019-02-21T17:55:03Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13600">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below line
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>o8z5s21gpu8y4xi26wbv4jztx5vz07i</sha1>
    </revision>
    <revision>
      <id>988</id>
      <parentid>987</parentid>
      <timestamp>2019-02-21T17:56:49Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13619">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need.

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>jvgjsms9mlezgdpvry8zcp0dbdigcbr</sha1>
    </revision>
    <revision>
      <id>1052</id>
      <parentid>988</parentid>
      <timestamp>2019-02-25T02:37:50Z</timestamp>
      <contributor>
        <username>SS210</username>
        <id>3015</id>
      </contributor>
      <minor/>
      <comment>/* Data structures */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13634">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data at the end of the list:
List_name.append(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse()
*to sort a list
List_name.sort()  //sorts in ascending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>3myne74c7e70gjyilo9pm82u3p91bb9</sha1>
    </revision>
    <revision>
      <id>1053</id>
      <parentid>1052</parentid>
      <timestamp>2019-02-25T02:54:02Z</timestamp>
      <contributor>
        <username>SS210</username>
        <id>3015</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13827">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1
List_name[::-1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>eltn4db5p6joc1tl5f9yjh2yq3rymk4</sha1>
    </revision>
    <revision>
      <id>1054</id>
      <parentid>1053</parentid>
      <timestamp>2019-02-25T02:56:21Z</timestamp>
      <contributor>
        <username>SS210</username>
        <id>3015</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13830">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1
List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>a542ulx8dzdc5d3sk33j0xjeedyox8m</sha1>
    </revision>
    <revision>
      <id>1055</id>
      <parentid>1054</parentid>
      <timestamp>2019-02-25T02:57:30Z</timestamp>
      <contributor>
        <username>SS210</username>
        <id>3015</id>
      </contributor>
      <comment>/* General Features of List */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13831">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a flexible data structure.
*Flexible data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>d049ikvessqmqpmviell4ayptar2drs</sha1>
    </revision>
    <revision>
      <id>1070</id>
      <parentid>1055</parentid>
      <timestamp>2019-02-25T09:46:56Z</timestamp>
      <contributor>
        <username>Mohanbalaji</username>
        <id>3255</id>
      </contributor>
      <minor/>
      <comment>/* Data structures */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13827">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.</text>
      <sha1>c7pvflpiv746qi8kimd21rspv2mjyc2</sha1>
    </revision>
    <revision>
      <id>1195</id>
      <parentid>1070</parentid>
      <timestamp>2019-02-28T02:11:01Z</timestamp>
      <contributor>
        <username>SS210</username>
        <id>3015</id>
      </contributor>
      <comment>/* Important Random Library Functions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13907">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.

4) random.choice(List_name) -- Generates an item randomly from the given list.</text>
      <sha1>loookiysi3vhu4aula2xr2rxx5hrqcg</sha1>
    </revision>
    <revision>
      <id>1441</id>
      <parentid>1195</parentid>
      <timestamp>2019-03-04T20:52:25Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14056">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===

Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.

4) random.choice(List_name) -- Generates an item randomly from the given list.</text>
      <sha1>o68iitcb0gb6vid11dbp5xs89y1dvpx</sha1>
    </revision>
    <revision>
      <id>1442</id>
      <parentid>1441</parentid>
      <timestamp>2019-03-04T20:53:52Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14204">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
Below code is the default code from the Video.

'''Code:'''
 &lt;nowiki&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/nowiki&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.

4) random.choice(List_name) -- Generates an item randomly from the given list.</text>
      <sha1>mi6oh0y4mwxk3irza8m24mqrqtfypt8</sha1>
    </revision>
    <revision>
      <id>1455</id>
      <parentid>1442</parentid>
      <timestamp>2019-03-05T03:31:33Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Crowd Computing Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14248">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
Below code is the default code from the Video.

'''Code:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/syntaxhighlight&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

 &lt;nowiki&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/nowiki&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.

4) random.choice(List_name) -- Generates an item randomly from the given list.</text>
      <sha1>awc1af8ixolyjxusx6qu4hrcxj8ij2d</sha1>
    </revision>
    <revision>
      <id>1456</id>
      <parentid>1455</parentid>
      <timestamp>2019-03-05T03:33:13Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14291">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
Below code is the default code from the Video.

'''Code:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/syntaxhighlight&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/syntaxhighlight&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.

4) random.choice(List_name) -- Generates an item randomly from the given list.</text>
      <sha1>fannok2c88gri4ne7ay63ucjafoby48</sha1>
    </revision>
    <revision>
      <id>1457</id>
      <parentid>1456</parentid>
      <timestamp>2019-03-05T04:51:18Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Jumbled Words Game */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14312">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)


----
=== '''Crowd Computing Code''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
Below code is the default code from the Video.

'''Code:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/syntaxhighlight&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic? Ask by clicking here]&lt;/code&gt;&lt;br /&gt;
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/syntaxhighlight&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.

4) random.choice(List_name) -- Generates an item randomly from the given list.</text>
      <sha1>op4trwb8dduswyqtxycocddvxeifk8y</sha1>
    </revision>
    <revision>
      <id>1458</id>
      <parentid>1457</parentid>
      <timestamp>2019-03-05T04:53:55Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* fizz buzz simple with if conditions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14375">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)&lt;/syntaxhighlight&gt;


----

=== '''Crowd Computing Code''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
Below code is the default code from the Video.

'''Code:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/syntaxhighlight&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) //To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  //To label y axis
plt.xlabel(&quot;some x values&quot;)  //To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic? Ask by clicking here]&lt;/code&gt;&lt;br /&gt;
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/syntaxhighlight&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.

4) random.choice(List_name) -- Generates an item randomly from the given list.</text>
      <sha1>q7xp4t044b40ajgmem9iikh5cgzuocf</sha1>
    </revision>
    <revision>
      <id>2840</id>
      <parentid>1458</parentid>
      <timestamp>2019-04-15T02:18:33Z</timestamp>
      <contributor>
        <username>Dharmesh.enc</username>
        <id>475</id>
      </contributor>
      <comment>/* To plot data using Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14372">== Data structures ==
*Data Structure is a specialized format for organizing and storing efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)&lt;/syntaxhighlight&gt;


----

=== '''Crowd Computing Code''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
Below code is the default code from the Video.

'''Code:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/syntaxhighlight&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) #To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  #To label y axis
plt.xlabel(&quot;some x values&quot;)  #To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic? Ask by clicking here]&lt;/code&gt;&lt;br /&gt;
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/syntaxhighlight&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.

4) random.choice(List_name) -- Generates an item randomly from the given list.</text>
      <sha1>bhpf3801sp7go8c138tsrsizbl60tyh</sha1>
    </revision>
    <revision>
      <id>3021</id>
      <parentid>2840</parentid>
      <timestamp>2019-04-26T15:50:01Z</timestamp>
      <contributor>
        <username>Manan</username>
        <id>381</id>
      </contributor>
      <minor/>
      <comment>/* Data structures */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14377">== Data structures ==
*Data Structure is a specialized format for organizing and storing data efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)&lt;/syntaxhighlight&gt;


----

=== '''Crowd Computing Code''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
Below code is the default code from the Video.

'''Code:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/syntaxhighlight&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) #To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  #To label y axis
plt.xlabel(&quot;some x values&quot;)  #To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic? Ask by clicking here]&lt;/code&gt;&lt;br /&gt;
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/syntaxhighlight&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overridden).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.

4) random.choice(List_name) -- Generates an item randomly from the given list.</text>
      <sha1>n94bxlvq4q9jexp7wufrrmjue1knqfn</sha1>
    </revision>
    <revision>
      <id>3026</id>
      <parentid>3021</parentid>
      <timestamp>2019-04-27T09:07:37Z</timestamp>
      <contributor>
        <username>Vignesh. P</username>
        <id>3477</id>
      </contributor>
      <comment>/* Writing Files */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14378">== Data structures ==
*Data Structure is a specialized format for organizing and storing data efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)&lt;/syntaxhighlight&gt;


----

=== '''Crowd Computing Code''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
Below code is the default code from the Video.

'''Code:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/syntaxhighlight&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) #To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  #To label y axis
plt.xlabel(&quot;some x values&quot;)  #To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic? Ask by clicking here]&lt;/code&gt;&lt;br /&gt;
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/syntaxhighlight&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.


== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overwritten).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.

4) random.choice(List_name) -- Generates an item randomly from the given list.</text>
      <sha1>erj3dp8of788go171nfsv0yorzh2lc9</sha1>
    </revision>
    <revision>
      <id>3031</id>
      <parentid>3026</parentid>
      <timestamp>2019-04-27T12:17:09Z</timestamp>
      <contributor>
        <username>Nitiksha Shah</username>
        <id>3394</id>
      </contributor>
      <comment>/* Useful Functions &amp; Methods for Lists */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14438">== Data structures ==
*Data Structure is a specialized format for organizing and storing data efficiently.
*List is a linear data structure.
*linear data structure is a data structure in which you can add and delete items as and when there is a need('''Mutable''').

Refer to the python Docs for better over view of [https://docs.python.org/3/tutorial/datastructures.html Data structures].

== General Features of List ==
*for creating an empty list
 List_name=[]
*Syntax for creating a list containing items
List_name=[&quot;item_1&quot;,&quot;item_2&quot;,&quot;item_3&quot;.....]
*Syntax for printing the contents of a list
print(List_name)
*Syntax for printing the contents of the list using for loop
for item in List_name:
print(item)
//This method is mainly used when we have to print the items one below the other in human friendly format.
Note that item is an intuitive name.

*to add new data(''1 item only'') at the end of the list:
List_name.append(Data)
*to add new data(''list of items'') at the end of list :
List_name.extend(Data)
*to insert data at a desired position
List_name.insert(position,&quot;item&quot;)//position starts from 0
*count function is used to count the number of occurrences of a particular item in a list
*Syntax
List_name.count(item)
*To find the number of items present in a list we use len function
*Syntax to find the length
len(List_name)
*to reverse the list:
List_name.reverse() #method1

List_name[ : : -1]     #method2

*to sort a list
List_name.sort()  //sorts in ascending order
List_name.sort(reverse=True) //sorts in descending order
* to count number of data of a particular type present in the list use:
shopping.count(data)//data=the object or item you want to search
* slicing of a list
shopping[1:4]  /// displays shopping[1],[2],[3]
* to get the length of a list
len(shopping)  // gives the length as output
*to get the maximum/minimmum value
max(shopping/ages)//returns the maximum value
min(shopping/ages)//returns the minimum value

== '''Week-3 Game programs''' ==
=== fizz buzz simple with if conditions ===

'''Problem:''' If a number is divisible by 3 the output should be fizz, if a number is divisible by 5 output should be buzz and if the number is divisible by both 3 and 5 then the output should be fizzbuzz.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
n=int(input(&quot;enter your last point of your game!&quot;))

for i in range (1,n):
    if(i%3==0 and i%5==0):
        print(i,&quot;= fizzbuzz&quot;)
    else:
        if(i%3==0):
            print(i,&quot;= fizz&quot;)
        else:
             if(i%5==0):
                 print(i,&quot;= buzz&quot;)
             else:
                 print(i)&lt;/syntaxhighlight&gt;


----

=== '''Crowd Computing Code''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
Below code is the default code from the Video.

'''Code:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from statistics import mean
from scipy import stats

Estimates = [1000,1010,1786,2000,1500,1500,100,120,150,
             150,150,170,175,180,197,200,200,200,200,200,
             200,220,220,220,220,234,250,250,250,250,250,
             250,250,250,250,263,270,275,275,286,300,300,
             300,300,300,300,300,300,320,350,350,350,400,
             400,400,400,400,450,467,500,500,500,500,500,
             500,500,550,550,600,600,600,650,700,700,720]

Estimates.sort()
m = stats.trim_mean(Estimates,0.1)
print(&quot;The near approximate value would be: &quot;, m)
#Above two line are substitute for below lines, and &quot;stats&quot; where imported for above line.
#trm_val = int(0.1*(len(Estimates)))
#Estimates = Estimates[trm_val:]
#Estimates = Estimates[:len(Estimates)-trm_val]
#print(mean(Estimates))&lt;/syntaxhighlight&gt;&lt;br /&gt;

==== To plot data using Python ====
 &lt;nowiki&gt;import matplotlib.pyplot as plt
plt.plot([1,2,3,4],[1,4,9,16]) #To plot data on x and y axis respectively
plt.ylabel(&quot;some y values&quot;)  #To label y axis
plt.xlabel(&quot;some x values&quot;)  #To label x axis&lt;/nowiki&gt;&lt;br /&gt;


----

=== '''Jumbled Words Game''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_3 Doubts on this topic? Ask by clicking here]&lt;/code&gt;&lt;br /&gt;
'''This code is a customized and improvised code.''' I have added few extra functions like '''clear screen''', '''sleep''', and '''3 chances'''. I used functions everywhere possible, to reduce the length of the program. '''And also, I have added a condition to random, so that we will never get a unjumbled output.'''

'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
# import only system to know OS type and store in the variable &quot;name&quot;
from os import system, name 
# import sleep to show output for some time period 
from time import sleep 

# This function is created to clear the screen
def wipeScreen():
    # Clear command for windows
    if name == 'nt':
        _ = system('cls')
    # Clear command for mac and linux
    else:
        _ = system('clear') 
    # To add some empty vertical space from the top
    print('\n'*5) 

def choose():
    cwords=['rainbow', 'dart', 'general', 'chemical', 'humble', 'family', 
           'dramatic', 'gland', 'arm', 'arun', 'identical', 'mushroom', 'whale', 
           'charm', 'comet', 'cultural', 'first', 'align', 'rich', 'India', 
           'hump', 'fluid', 'bite', 'fighter', 'ten', 'photograph', 'escalator', 
           'rose', 'dog', 'horse', 'jumble', 'python3.7', 'anaconda', 'spyder3.3.3', 
           'science', 'computer', 'programming', 'player', 'cheater']
    pick=random.choice(cwords)
    return pick

# This function is responsible for jumbling
def jumble(rec_word):
    jumbled=rec_word
    while (jumbled == rec_word):
        jumbled=&quot;&quot;.join(random.sample(rec_word,len(rec_word)))
    return jumbled

# This function is responsible for the final score.
def thank(p1n, p2n, s1, s2):
    wipeScreen()
    print(p1n, &quot;Your final socre is: &quot;, s1)
    print(p2n, &quot;Your final socre is: &quot;, s2)
    print(&quot;I hope you enjoyed playing. \nHave a nice day!&quot;)

# This function is responsible to check the user answer and chances.
def j_game(player, score, pword, jword):
    wipeScreen()
    sleep(0.5)
    print(&quot;\t&quot;*3, player.capitalize(), &quot;it's your turn!\n&quot;)
    #Below print is just for decoration
    print(&quot;*&quot;*25)
    print(&quot;Guess this word: &quot;, jword)
    for chance in range(1,4):
        print(&quot;Chance&quot;, chance)
        answer=str(input(&quot;- What is your guess: &quot;))
        if answer==pword:
            score=score+1
            print(&quot;\nYour scored&quot;, score, &quot;point(s)!&quot;)
            break
        else:
            print(&quot;Try again.&quot;)
    print(&quot;\nCorrect answer is: &quot;, pword)
    #sleep for 2 seconds
    sleep(2)
    return score

def play():
    wipeScreen()
    sleep(0.5)
    name_p1=str(input(&quot;Player 1, Please enter your name: &quot;))
    name_p2=str(input(&quot;Player 2, Please enter your name: &quot;))
    rounds=int(input(&quot;How many rounds you want to play? &quot;))
    
    # Cheating part. (Not yet updated/Added). I dont know English much.
    # So, i want this cheat.
    
    # As this is a two player game, we need 2 while loop runs to finish one round.
    # So we are doubling the round count here.
    rounds = rounds*2
    turn=0
    score_p1=0
    score_p2=0

    # Main game loop starts here
    while (turn &lt; rounds):
        #Program chooses a random word from the above list
        picked_word=choose()
        #Picked word is jumbled here
        jumbled_word=jumble(picked_word)
        
        #Player1
        if turn%2 == 0:
            #We have created a j_game function. it will manage the game part.
            score_p1=j_game(name_p1, score_p1, picked_word, jumbled_word)

        #Player2
        else:
            #We have created a j_game function. it will manage the game part.
            score_p2=j_game(name_p2, score_p2, picked_word, jumbled_word)
                
        #turn increment 
        turn=turn+1
        if turn &lt; rounds:
            #Player choice to Quit
            cont=int(input(&quot;Do you want to continue? \n press 1 to continue or 0 to quit: &quot;))
            if cont == 0:
                break
    
    #Exit greetings
    thank(name_p1, name_p2, score_p1, score_p2)
    # Main game loop ends here

# Entire game starts because of this below &quot;play()&quot; function call.
play()&lt;/syntaxhighlight&gt;&lt;br /&gt;
'''Ask Any question related to this program in the Week-3 FAQs section, [http://sccilabs.org/jocwiki/index.php/Topic:Uultywe7wdbupilg click here]'''&lt;br /&gt;

== Useful Functions &amp; Methods for Lists ==
'''max(list)''' -- Returns the list item with the maximum value.

'''min(list)''' -- Returns the list item with minimum value.

'''list.count(obj)''' -- Returns a count of how many times an item occurs in a list.

'''list.remove(obj)''' -- Removes an object from a list.

'''list.reverse()''' -- Reverses objects in a list.

'''list[ : : -1]'''-- Reverses objects in a list.(Method 2)

== Functions (Reusing Code) ==
Code reuse is a very important part of programming in any language. Increasing code size at times makes it harder to maintain.

For a large programming project, it is essential to abide by the &quot;'''Don't Repeat Yourself'''&quot; or &quot;'''DRY'''&quot; principle. It makes the code easier to maintain.

Any statement that consists of a word followed by information in parenthesis is a '''FUNCTION CALL'''.

In addition to using pre-defined functions, we can create our own functions by using the &quot;'''def'''&quot; statement. The statements in the function are only executed when the function is called.

&gt;&gt;&gt;def my_func():
        print(&quot;Hello&quot;)

The code block within every function starts with a colon and is indented.
We MUST define functions before they are called.


== Function Arguments ==
All the function definitions '''MAY/ MAY NOT''' take arguments.

Function arguments can be used as variables inside the function definition. However, they '''cannot''' be referenced outside of the function's definition. This also applies to other variables created inside the function.

Technically, &quot;parameters&quot; are the variables in a function definition and &quot;arguments&quot; are the values put into parameters when functions are called.

== Returning from Functions ==
We use &quot;'''return'''&quot; statement.

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it '''immediately stops''' being executed. Any code after the return statement will never happen.

== Docstrings ==
Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific &amp; have a different syntax.

Docstrings are created by putting a multiline string containing an explanation of the function below the function's first line.

&gt;&gt;&gt;def shout(word):
         &quot;&quot;&quot;
         Printing a word.
          ………….
         &quot;&quot;&quot;
      print(word + '!')


&gt;&gt;&gt; shout(&quot;Hello&quot;)

will give the output -- Hello !

Unlike conventional comments, docstrings are retained throughout the runtime of a program. This allows the programmer to inspect these comments at runtime.

== Functions as Objects ==
Although they are created differently from normal variables, functions are just like any other kind of value.

They can be assigned &amp; re-assigned to variables &amp; later referenced by those names.

Functions can also be used as arguments of other functions.

== Opening Files ==
Python can be used to read and write the contents of a file. Text files are easiest to manipulate. Before a file can be edited, it must be opened using the &quot;'''open'''&quot; function.

'''&gt;&gt;&gt;myfile = open(&quot;filename.txt&quot;)
'''

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

&quot;r&quot; =&gt; read mode {Default}

&quot;w&quot; =&gt; write mode -- rewriting the contents of file.

&quot;a&quot; =&gt; append mode -- for adding new content to the end of file.

Adding &quot;b&quot; to a mode opens it in binary mode, which is used for non-text files(such as image and sound files).

&quot;+&quot; sign with each of the modes above give extra access to files.

== Reading Files ==
The contents of a file that has been opened in text mode can be read using the &quot;read()&quot; method.

'''&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

'''
'''&gt;&gt;&gt;cont = file.read()
'''

'''&gt;&gt;&gt; print(cont)
'''

'''&gt;&gt;&gt;file.close()
'''

The above code will print all the contents of the file.

To close the file: &quot;close&quot; method is used.


To read only a certain amount of a file, we can provide a number as an argument to read the function. This determines the number of bytes that should be read.

We can make more calls to read on the same file object to read more of the file byte by byte. With NO argument, read returns the rest of the file.

Just like passing no arguments, negative values will return the entire content.

After all the contents of a file have been read, any attempts to read further from that file will return an EMPTY STRING, because we are trying to read from the &quot;end of file&quot;.

To retrieve each line in a file, we can use &quot;readlines&quot; method to return a list in which each element is a line in the file.

'''&gt;&gt;&gt;print(file.readlines())''' 

You can also use a for loop to iterate through the lines in the file.

&gt;&gt;&gt;file = open(&quot;filename.txt&quot;, &quot;r&quot;)

       for line in file:
          print(line)

       file.close()

In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.

== Writing Files ==
To write to files, we use the &quot;write&quot; method, which writes a string to the file.

&gt;&gt;&gt;file.write(&quot;Hello&quot;)

The &quot;w&quot; mode will create a file, if it does not already exist. When a file is opened in write mode, the file's existing content is deleted(content gets overwritten).

The write() method returns the number of bytes written to a file, if successful.

To write something other than a string, it needs to be converted to a string first.

== Important Random Library Functions ==
1) random.randint(1,5) -- Generates a random integer from 1 to 5.

2) random.randrange(1,5) -- Generates a random integer from 1 to 4.

3) random.random() --  Generates a random decimal number between 0 and 1.

4) random.choice(List_name) -- Generates an item randomly from the given list.</text>
      <sha1>cbsjkp3qjnz2ciegrz64dp9ca4wa3lt</sha1>
    </revision>
  </page>
</mediawiki>
