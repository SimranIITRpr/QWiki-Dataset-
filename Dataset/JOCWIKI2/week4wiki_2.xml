<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>JOCWiki</sitename>
    <dbname>Jocwiki_second</dbname>
    <base>http://sccilabs.org/jocwiki2/index.php/Main_Page</base>
    <generator>MediaWiki 1.30.0</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">JOCWiki</namespace>
      <namespace key="5" case="first-letter">JOCWiki talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
      <namespace key="2600" case="first-letter">Topic</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Lecture Notes:Week 4</title>
    <ns>0</ns>
    <id>498</id>
    <revision>
      <id>999</id>
      <timestamp>2019-02-22T19:09:47Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>Created page with &quot; == Modules == Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.  The bas...&quot;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="552">
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.</text>
      <sha1>n2cpxnq8h8xj3e9k1h3s1yfpcksfhs0</sha1>
    </revision>
    <revision>
      <id>1000</id>
      <parentid>999</parentid>
      <timestamp>2019-02-22T19:22:34Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1268">
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root</text>
      <sha1>1f9bgwyk0gj6cgh40x864utks8svx78</sha1>
    </revision>
    <revision>
      <id>1001</id>
      <parentid>1000</parentid>
      <timestamp>2019-02-22T19:31:50Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1862">
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.</text>
      <sha1>f3hqi3l8lamg95chmho5m38k4jgz21s</sha1>
    </revision>
    <revision>
      <id>1002</id>
      <parentid>1001</parentid>
      <timestamp>2019-02-22T19:35:43Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2345">
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root


== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.


== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.


== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.</text>
      <sha1>grag45inptrxrkak117erh2e3ocut0n</sha1>
    </revision>
    <revision>
      <id>1003</id>
      <parentid>1002</parentid>
      <timestamp>2019-02-22T19:47:11Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3118">
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).</text>
      <sha1>chfkrj85bpav2f5r5z0xhkiqg3m9d6l</sha1>
    </revision>
    <revision>
      <id>1004</id>
      <parentid>1003</parentid>
      <timestamp>2019-02-22T19:59:16Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4232">
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.</text>
      <sha1>mc9hgr8l4224kggornkmu59k6ahw1y3</sha1>
    </revision>
    <revision>
      <id>1005</id>
      <parentid>1004</parentid>
      <timestamp>2019-02-22T20:06:53Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4848">
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.</text>
      <sha1>k3v1swh5onil8klcxakwn7z8pnityon</sha1>
    </revision>
    <revision>
      <id>1007</id>
      <parentid>1005</parentid>
      <timestamp>2019-02-22T20:23:08Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5265">
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]</text>
      <sha1>3rqmdntzctyt72s6on2m75ba61gka27</sha1>
    </revision>
    <revision>
      <id>1010</id>
      <parentid>1007</parentid>
      <timestamp>2019-02-23T09:42:36Z</timestamp>
      <contributor>
        <username>Simran</username>
        <id>4</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13565">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6  
 3  5  7
 4  9  2

----------------
 6  1  8  
 7  5  3  
 2  9  4

----------------
 2  7  6  
 9  5  1  
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)     (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  going DOWN
then put next value
&lt;/pre&gt;
Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48 1 10 19 28 
38 47 7 9 18 27 29 
46 6 8 17 26 35 37 
5 14 16 25 34 36 45 
13 15 24 33 42 44 4 
21 23 32 41 43 3 12 
22 31 40 49 2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]</text>
      <sha1>miob7fc702paf7liexx003nrojk2zam</sha1>
    </revision>
    <revision>
      <id>1014</id>
      <parentid>1010</parentid>
      <timestamp>2019-02-23T11:17:23Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14345">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6  
 3  5  7
 4  9  2

----------------
 6  1  8  
 7  5  3  
 2  9  4

----------------
 2  7  6  
 9  5  1  
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)     (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  going DOWN
then put next value
&lt;/pre&gt;
Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48 1 10 19 28 
38 47 7 9 18 27 29 
46 6 8 17 26 35 37 
5 14 16 25 34 36 45 
13 15 24 33 42 44 4 
21 23 32 41 43 3 12 
22 31 40 49 2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.

&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world

&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world

&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True

&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO

&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']</text>
      <sha1>0o3ia0zj7najgjjy4ei6r2sctds7b4g</sha1>
    </revision>
    <revision>
      <id>1015</id>
      <parentid>1014</parentid>
      <timestamp>2019-02-23T11:19:15Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14349">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6  
 3  5  7
 4  9  2

----------------
 6  1  8  
 7  5  3  
 2  9  4

----------------
 2  7  6  
 9  5  1  
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)     (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  going DOWN
then put next value
&lt;/pre&gt;
Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48 1 10 19 28 
38 47 7 9 18 27 29 
46 6 8 17 26 35 37 
5 14 16 25 34 36 45 
13 15 24 33 42 44 4 
21 23 32 41 43 3 12 
22 31 40 49 2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True

&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']</text>
      <sha1>856esd2lqjdn4y7eqm4lc463xa8z0b4</sha1>
    </revision>
    <revision>
      <id>1016</id>
      <parentid>1015</parentid>
      <timestamp>2019-02-23T11:24:24Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14907">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6  
 3  5  7
 4  9  2

----------------
 6  1  8  
 7  5  3  
 2  9  4

----------------
 2  7  6  
 9  5  1  
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)     (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  going DOWN
then put next value
&lt;/pre&gt;
Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48 1 10 19 28 
38 47 7 9 18 27 29 
46 6 8 17 26 35 37 
5 14 16 25 34 36 45 
13 15 24 33 42 44 4 
21 23 32 41 43 3 12 
22 31 40 49 2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False</text>
      <sha1>04r6zjmjwrwsvkb6d61ss8gvnekb9y5</sha1>
    </revision>
    <revision>
      <id>1018</id>
      <parentid>1016</parentid>
      <timestamp>2019-02-23T11:52:03Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15706">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6  
 3  5  7
 4  9  2

----------------
 6  1  8  
 7  5  3  
 2  9  4

----------------
 2  7  6  
 9  5  1  
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)     (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  going DOWN
then put next value
&lt;/pre&gt;
Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48 1 10 19 28 
38 47 7 9 18 27 29 
46 6 8 17 26 35 37 
5 14 16 25 34 36 45 
13 15 24 33 42 44 4 
21 23 32 41 43 3 12 
22 31 40 49 2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.</text>
      <sha1>5lbvel742jqksauf2nv4bpoq5tznfv5</sha1>
    </revision>
    <revision>
      <id>1019</id>
      <parentid>1018</parentid>
      <timestamp>2019-02-23T12:04:02Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="16436">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6  
 3  5  7
 4  9  2

----------------
 6  1  8  
 7  5  3  
 2  9  4

----------------
 2  7  6  
 9  5  1  
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)     (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  going DOWN
then put next value
&lt;/pre&gt;
Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48 1 10 19 28 
38 47 7 9 18 27 29 
46 6 8 17 26 35 37 
5 14 16 25 34 36 45 
13 15 24 33 42 44 4 
21 23 32 41 43 3 12 
22 31 40 49 2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be sued to make games by itself.</text>
      <sha1>95f45lifew7w89p6w2sh4z7js2zd8vv</sha1>
    </revision>
    <revision>
      <id>1042</id>
      <parentid>1019</parentid>
      <timestamp>2019-02-24T11:41:01Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="16435">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6  
 3  5  7
 4  9  2

----------------
 6  1  8  
 7  5  3  
 2  9  4

----------------
 2  7  6  
 9  5  1  
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  going DOWN
then put next value
&lt;/pre&gt;
Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48 1 10 19 28 
38 47 7 9 18 27 29 
46 6 8 17 26 35 37 
5 14 16 25 34 36 45 
13 15 24 33 42 44 4 
21 23 32 41 43 3 12 
22 31 40 49 2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be sued to make games by itself.</text>
      <sha1>7kblvgqn2cwk2o8eqdo3zr0wf30ghka</sha1>
    </revision>
    <revision>
      <id>1043</id>
      <parentid>1042</parentid>
      <timestamp>2019-02-24T11:50:42Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Major 3rd-Party Libraries */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="16435">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6  
 3  5  7
 4  9  2

----------------
 6  1  8  
 7  5  3  
 2  9  4

----------------
 2  7  6  
 9  5  1  
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  going DOWN
then put next value
&lt;/pre&gt;
Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48 1 10 19 28 
38 47 7 9 18 27 29 
46 6 8 17 26 35 37 
5 14 16 25 34 36 45 
13 15 24 33 42 44 4 
21 23 32 41 43 3 12 
22 31 40 49 2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.</text>
      <sha1>3ojo7jbefvu6gup3qmfd6f5ceejljvq</sha1>
    </revision>
    <revision>
      <id>1045</id>
      <parentid>1043</parentid>
      <timestamp>2019-02-24T16:36:58Z</timestamp>
      <contributor>
        <username>C++veteran</username>
        <id>1964</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17902">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6  
 3  5  7
 4  9  2

----------------
 6  1  8  
 7  5  3  
 2  9  4

----------------
 2  7  6  
 9  5  1  
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  going DOWN
then put next value
&lt;/pre&gt;
Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48 1 10 19 28 
38 47 7 9 18 27 29 
46 6 8 17 26 35 37 
5 14 16 25 34 36 45 
13 15 24 33 42 44 4 
21 23 32 41 43 3 12 
22 31 40 49 2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.</text>
      <sha1>jy6990d04v99arrfvp58z0beu7d8n31</sha1>
    </revision>
    <revision>
      <id>1047</id>
      <parentid>1045</parentid>
      <timestamp>2019-02-25T00:29:01Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Magic Square */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17899">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6
 3  5  7
 4  9  2

----------------
 6  1  8
 7  5  3
 2  9  4

----------------
 2  7  6
 9  5  1
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48 1 10 19 28 
38 47  7 9 18 27 29 
46 6 8 17 26 35 37 
5 14 16 25 34 36 45 
13 15 24 33 42 44 4 
21 23 32 41 43 3 12 
22 31 40 49 2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.</text>
      <sha1>nvyl4d04uai0505fjhc643euz2kbedj</sha1>
    </revision>
    <revision>
      <id>1048</id>
      <parentid>1047</parentid>
      <timestamp>2019-02-25T00:30:54Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Easier way to get the magic square for odd order by avoiding Rule 1 and 2 */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17907">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6
 3  5  7
 4  9  2

----------------
 6  1  8
 7  5  3
 2  9  4

----------------
 2  7  6
 9  5  1
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.</text>
      <sha1>kudqbjcsovda7at6bhovs2urkgdgwqu</sha1>
    </revision>
    <revision>
      <id>1049</id>
      <parentid>1048</parentid>
      <timestamp>2019-02-25T00:32:02Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Easier way to get the magic square for odd order by avoiding Rule 1 and 2 */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17912">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :

 8  1  6
 3  5  7
 4  9  2

----------------
 6  1  8
 7  5  3
 2  9  4

----------------
 2  7  6
 9  5  1
 4  3  8
---------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.</text>
      <sha1>du36nb4sl7stl2tr3qvdma7g25kmnwi</sha1>
    </revision>
    <revision>
      <id>1050</id>
      <parentid>1049</parentid>
      <timestamp>2019-02-25T00:33:36Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Magic Square */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17923">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ol&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1). And if the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

'''Steps:'''
&lt;ol&gt; &lt;li&gt;position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;position of number 2 = (1-1, 2+1) = (0, 0)&lt;/li&gt;
&lt;li&gt;position of number 3 = (0-1, 0+1) = (3-1, 1) = (2, 1)&lt;/li&gt;
&lt;li&gt; position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   Since, at this position, 1 is there. So, apply condition 2.
   new position=(1+1,2-2)=(2,0)
&lt;li&gt;position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;position of number 7 = (0-1, 2+1) = (-1,3) // this is tricky, see condition 3 
   new position = (0, 3-2) = (0,1)&lt;/li&gt;
&lt;li&gt;position of number 8=(0-1,1+1)=(-1,2)=(2,2) //wrap around&lt;/li&gt;
&lt;li&gt;position of number 9=(2-1,2+1)=(1,3)=(1,0) //wrap around&lt;/li&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.</text>
      <sha1>o4h47m9a50yzc3s6cuvyv12lq97xvz8</sha1>
    </revision>
    <revision>
      <id>1065</id>
      <parentid>1050</parentid>
      <timestamp>2019-02-25T09:10:51Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18795">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then using &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.</text>
      <sha1>osuxmw4hftbtsrcq4xz2uh26q7bza4n</sha1>
    </revision>
    <revision>
      <id>1071</id>
      <parentid>1065</parentid>
      <timestamp>2019-02-25T12:04:15Z</timestamp>
      <contributor>
        <username>HardcodeCoder</username>
        <id>3264</id>
      </contributor>
      <minor/>
      <comment>/* Modules */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18818">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.</text>
      <sha1>eq43vylm3imxtmbqsg9dii6ufwagezc</sha1>
    </revision>
    <revision>
      <id>1077</id>
      <parentid>1071</parentid>
      <timestamp>2019-02-25T14:19:49Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="20314">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]


== PROGRAM FOR DOBBLE GAME: ==
&lt;pre&gt;

METHOD 1 :
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

        
METHOD 2:
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.</text>
      <sha1>gm0srhq1gdr35wdilboaeoxsnqsef2h</sha1>
    </revision>
    <revision>
      <id>1078</id>
      <parentid>1077</parentid>
      <timestamp>2019-02-25T15:31:12Z</timestamp>
      <contributor>
        <username>Som</username>
        <id>1910</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="21389">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]


== PROGRAM FOR DOBBLE GAME: ==
&lt;pre&gt;

METHOD 1 :
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

        
METHOD 2:
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>6b7x4rbucf0b9ucsjwk1eyfudxmkfs4</sha1>
    </revision>
    <revision>
      <id>1125</id>
      <parentid>1078</parentid>
      <timestamp>2019-02-26T15:27:46Z</timestamp>
      <contributor>
        <username>Shivani Sama</username>
        <id>3294</id>
      </contributor>
      <minor/>
      <comment>/* Magic Square */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="21387">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]

== PROGRAM FOR DOBBLE GAME: ==
&lt;pre&gt;

METHOD 1 :
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

        
METHOD 2:
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling themselves.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>i16pvj8tz3y5506dcx6dv9j5umcd50e</sha1>
    </revision>
    <revision>
      <id>1178</id>
      <parentid>1125</parentid>
      <timestamp>2019-02-27T11:56:29Z</timestamp>
      <contributor>
        <username>HardcodeCoder</username>
        <id>3264</id>
      </contributor>
      <comment>/* Recursion with few use cases */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="21577">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
[[#Top]]

== PROGRAM FOR DOBBLE GAME: ==
&lt;pre&gt;

METHOD 1 :
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

        
METHOD 2:
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>kbc3soatttnorzkj6ogr1zfebad721t</sha1>
    </revision>
    <revision>
      <id>1179</id>
      <parentid>1178</parentid>
      <timestamp>2019-02-27T14:06:32Z</timestamp>
      <contributor>
        <username>Soumyajit1097</username>
        <id>3333</id>
      </contributor>
      <comment>/* Magic Square */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="21972">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 


Sum of each row, column and diagonals =  175
&lt;/pre&gt;
A brute force approach--
import random 
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)
[[#Top]]

== PROGRAM FOR DOBBLE GAME: ==
&lt;pre&gt;

METHOD 1 :
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

        
METHOD 2:
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>e193v8zxjwhb7w1su9dumdbyx1pu3lk</sha1>
    </revision>
    <revision>
      <id>1271</id>
      <parentid>1179</parentid>
      <timestamp>2019-03-01T18:27:55Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Easier way to get the magic square for odd order by avoiding Rule 1 and 2 */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22031">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;

=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== PROGRAM FOR DOBBLE GAME: ==
&lt;pre&gt;

METHOD 1 :
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

        
METHOD 2:
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>h55g1ykcstohjmjfbug3th7xfpjwelj</sha1>
    </revision>
    <revision>
      <id>1272</id>
      <parentid>1271</parentid>
      <timestamp>2019-03-01T18:28:29Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Easier way to get the magic square for odd order by avoiding Rule 1 and 2 */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22037">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== PROGRAM FOR DOBBLE GAME: ==
&lt;pre&gt;

METHOD 1 :
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

        
METHOD 2:
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>tf25jpf54vskyinn3a7780ptdza20fu</sha1>
    </revision>
    <revision>
      <id>1273</id>
      <parentid>1272</parentid>
      <timestamp>2019-03-01T18:28:49Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* A brute force approach */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22042">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;
&lt;hr&gt;
Another way to generate a magic square of odd order:-
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== PROGRAM FOR DOBBLE GAME: ==
&lt;pre&gt;

METHOD 1 :
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

        
METHOD 2:
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>a3qdeqmvq6yteesjv4qpzxygeul9ex4</sha1>
    </revision>
    <revision>
      <id>1274</id>
      <parentid>1273</parentid>
      <timestamp>2019-03-01T18:30:19Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Magic Square */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22061">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
&lt;hr&gt;


----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== PROGRAM FOR DOBBLE GAME: ==
&lt;pre&gt;

METHOD 1 :
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

        
METHOD 2:
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>92ae1wzvma4ga7efzfaqz4r5btuzw5z</sha1>
    </revision>
    <revision>
      <id>1275</id>
      <parentid>1274</parentid>
      <timestamp>2019-03-01T18:30:56Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Magic Square */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22057">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;



----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== PROGRAM FOR DOBBLE GAME: ==
&lt;pre&gt;

METHOD 1 :
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

        
METHOD 2:
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>9cmej77ll3rfjcv21swy5hluiu0ceod</sha1>
    </revision>
    <revision>
      <id>1276</id>
      <parentid>1275</parentid>
      <timestamp>2019-03-01T18:32:57Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* PROGRAM FOR DOBBLE GAME: */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22089">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;



----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>1yr44yzdi6ar2fiws4hg4q365lekbqv</sha1>
    </revision>
    <revision>
      <id>1277</id>
      <parentid>1276</parentid>
      <timestamp>2019-03-01T18:33:29Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* METHOD 2: */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22094">==Magic Square==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;



----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>bz9mw0rxlw1tdikhwnev7hypdke0ulh</sha1>
    </revision>
    <revision>
      <id>1278</id>
      <parentid>1277</parentid>
      <timestamp>2019-03-01T18:35:47Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Magic Square */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22100">=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;



----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.


== Birthday paradox ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

== Complete Program for Birthday paradox ==
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;</text>
      <sha1>sw9yywb7ytiyn4rruzngl6fabp1lqdj</sha1>
    </revision>
    <revision>
      <id>1279</id>
      <parentid>1278</parentid>
      <timestamp>2019-03-01T18:39:25Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22172">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;



----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;


= '''Notes''' =
----
== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

&gt;&gt;&gt;import random

&gt;&gt;&gt;for i in range(5):
        print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

'''&gt;&gt;&gt;from math import pi
'''
'''&gt;&gt;&gt;print(pi)
'''

Use a comma separated list to import multiple objects.

'''&gt;&gt;&gt;from math import pi, sqrt
'''

The asterisk (*) imports all objects from a module.

&gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

&gt;&gt;&gt;from math import sqrt as square_root

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.</text>
      <sha1>0rhnbycyj65dcunupw0dvvtdvbe8qz8</sha1>
    </revision>
    <revision>
      <id>1280</id>
      <parentid>1279</parentid>
      <timestamp>2019-03-01T18:42:37Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Notes */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22182">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;



----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;


= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt;import random

: &gt;&gt;&gt;for i in range(5):
:         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt;from math import pi'''
: '''&gt;&gt;&gt;print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt;from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt;from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt;from math import sqrt as square_root


== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120</text>
      <sha1>kf97w2jo35lyharg8glp3e404d4484v</sha1>
    </revision>
    <revision>
      <id>1281</id>
      <parentid>1280</parentid>
      <timestamp>2019-03-01T18:43:17Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Modules */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22189">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;



----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;


= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.


A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120</text>
      <sha1>2w4guzsl12c48oggvp41cvifl3fdp9r</sha1>
    </revision>
    <revision>
      <id>1282</id>
      <parentid>1281</parentid>
      <timestamp>2019-03-01T18:43:45Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Major 3rd-Party Libraries */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22188">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;



----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;


= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root

== Major 3rd-Party Libraries ==
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120</text>
      <sha1>i0o5hi82ly81l5ycylvapvkxch3e85l</sha1>
    </revision>
    <revision>
      <id>1283</id>
      <parentid>1282</parentid>
      <timestamp>2019-03-01T18:45:24Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Major 3rd-Party Libraries */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22190">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;



----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;


= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120</text>
      <sha1>cdqs4t3endnltarp0oqiqnbuxzco6rp</sha1>
    </revision>
    <revision>
      <id>1284</id>
      <parentid>1283</parentid>
      <timestamp>2019-03-01T18:48:34Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Magic Square */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22207">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;


= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120</text>
      <sha1>s2xwc251ic6njvuehb5m1nuowjuwiox</sha1>
    </revision>
    <revision>
      <id>1285</id>
      <parentid>1284</parentid>
      <timestamp>2019-03-01T18:49:04Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* PROGRAM FOR DOBBLE GAME: */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22217">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;


= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120</text>
      <sha1>exyrebtjjim9in5u9vtpgcf5776p3es</sha1>
    </revision>
    <revision>
      <id>1286</id>
      <parentid>1285</parentid>
      <timestamp>2019-03-01T18:49:25Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Birthday paradox */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22226">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120</text>
      <sha1>mibap0d9yexdhty4nrtb1hrm5zg0els</sha1>
    </revision>
    <revision>
      <id>1287</id>
      <parentid>1286</parentid>
      <timestamp>2019-03-01T18:49:44Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Recursion */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22236">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


&gt;&gt;&gt;print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

--&gt; Output: hello, world


&gt;&gt;&gt;print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

--&gt; Output: hello world


&gt;&gt;&gt;print(&quot;This world&quot;.startswith(&quot;This&quot;))

--&gt; Output: True


&gt;&gt;&gt;print(&quot;hello&quot;.upper())

--&gt; Output: HELLO


&gt;&gt;&gt;print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

--&gt; Output: ['spam', 'hello', 'world']


== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

[[#Top]]</text>
      <sha1>olsm7r19wjxf3yko3nhup46te5it19v</sha1>
    </revision>
    <revision>
      <id>1288</id>
      <parentid>1287</parentid>
      <timestamp>2019-03-01T18:50:45Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Useful String Functions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22275">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.

== The Standard Library &amp; pip ==
There are three main types of modules in python:

--&gt;Those you write yourself

--&gt;Those you install from external sources

--&gt;Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

[[#Top]]</text>
      <sha1>ripi6y3n1qpogon9rhthww2gsxp1ypr</sha1>
    </revision>
    <revision>
      <id>1289</id>
      <parentid>1288</parentid>
      <timestamp>2019-03-01T18:54:19Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Notes */  Text Formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22275">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).


=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

[[#Top]]</text>
      <sha1>7eov6lcgpc18j6eg11i4ef1qo2l3vi2</sha1>
    </revision>
    <revision>
      <id>1290</id>
      <parentid>1289</parentid>
      <timestamp>2019-03-01T18:54:44Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* The Standard Library &amp; pip */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22281">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

[[#Top]]</text>
      <sha1>jjcn3f7psdbk81n9kpckyiy2gs3ytpk</sha1>
    </revision>
    <revision>
      <id>1304</id>
      <parentid>1290</parentid>
      <timestamp>2019-03-02T13:10:50Z</timestamp>
      <contributor>
        <username>HardcodeCoder</username>
        <id>3264</id>
      </contributor>
      <comment>/* Recursion */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23181">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;pre&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/pre&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----
=== Another way to generate a magic square of odd order ===
&lt;pre&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/pre&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;pre&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/pre&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;pre&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/pre&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>10e3vqi4l62lph4t66l604o2b1ftphl</sha1>
    </revision>
    <revision>
      <id>1474</id>
      <parentid>1304</parentid>
      <timestamp>2019-03-05T05:17:47Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Magic Square */  Code Text Formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23381">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----
=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>33yp3ed7q68qllb1ylv7quctzk96hs3</sha1>
    </revision>
    <revision>
      <id>1475</id>
      <parentid>1474</parentid>
      <timestamp>2019-03-05T05:18:49Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Magic Square */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23404">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
==== CODE: ====
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----
=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>7qntpntphj1sfgd3c1no6kpuxqdcu1r</sha1>
    </revision>
    <revision>
      <id>1476</id>
      <parentid>1475</parentid>
      <timestamp>2019-03-05T05:19:21Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Magic Square */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23401">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----
=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>ic1ccgdyoj17w2d2zuc74nzjhcor2oz</sha1>
    </revision>
    <revision>
      <id>1477</id>
      <parentid>1476</parentid>
      <timestamp>2019-03-05T05:20:05Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* CODE */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23409">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;br /&gt;
&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----

=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;



Complete program is 

&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----
=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>ocxprp31zw65maa0wg0mfp6gl7jgnvq</sha1>
    </revision>
    <revision>
      <id>1478</id>
      <parentid>1477</parentid>
      <timestamp>2019-03-05T05:21:21Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Easier way to get the magic square for odd order by avoiding Rule 1 and 2 */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23424">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;br /&gt;
&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----

=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;


&lt;br /&gt;
==== Complete program is ====
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----

=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;pre&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/pre&gt;&lt;br /&gt;


----
=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>buqmlp6zutp4uol519memq02dmoy2bm</sha1>
    </revision>
    <revision>
      <id>1479</id>
      <parentid>1478</parentid>
      <timestamp>2019-03-05T05:22:33Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* METHOD 1: */  Code Text Formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23475">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;br /&gt;
&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----

=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;


&lt;br /&gt;
==== Complete program is ====
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----

=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/syntaxhighlight&gt;&lt;br /&gt;


----

=== METHOD 2: ===
&lt;pre&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/pre&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>15v2a8ohnmp73oe5cjdg5qtbmbof55i</sha1>
    </revision>
    <revision>
      <id>1480</id>
      <parentid>1479</parentid>
      <timestamp>2019-03-05T05:23:09Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* METHOD 2: */  Code Text formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23525">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;br /&gt;
&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----

=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;


&lt;br /&gt;
==== Complete program is ====
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----

=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/syntaxhighlight&gt;&lt;br /&gt;


----

=== METHOD 2: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/syntaxhighlight&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;pre&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/pre&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>cuavh5n58s2t6d31divdq9jsqfc6m9z</sha1>
    </revision>
    <revision>
      <id>1481</id>
      <parentid>1480</parentid>
      <timestamp>2019-03-05T05:24:22Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Birthday paradox */  Code text formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23575">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;br /&gt;
&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----

=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;


&lt;br /&gt;
==== Complete program is ====
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;
&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----

=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/syntaxhighlight&gt;&lt;br /&gt;


----

=== METHOD 2: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/syntaxhighlight&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/syntaxhighlight&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>8w62ok3visskz38x7gegr95r6o8dwit</sha1>
    </revision>
    <revision>
      <id>1482</id>
      <parentid>1481</parentid>
      <timestamp>2019-03-05T05:25:15Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Complete program is */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23582">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;br /&gt;
&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----

=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;


&lt;br /&gt;
==== Complete program is ====
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;

&lt;br /&gt;&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----

=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/syntaxhighlight&gt;&lt;br /&gt;


----

=== METHOD 2: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/syntaxhighlight&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/syntaxhighlight&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello, world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: ['spam', 'hello', 'world']

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>ja4jwhcx8sxyvkgdzm93j1u4kavo10l</sha1>
    </revision>
    <revision>
      <id>2927</id>
      <parentid>1482</parentid>
      <timestamp>2019-04-19T14:03:44Z</timestamp>
      <contributor>
        <username>Dharmesh.enc</username>
        <id>475</id>
      </contributor>
      <minor/>
      <comment>/* Useful String Functions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23571">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n/2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;br /&gt;
&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----

=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;


&lt;br /&gt;
==== Complete program is ====
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;

&lt;br /&gt;&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----

=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/syntaxhighlight&gt;&lt;br /&gt;


----

=== METHOD 2: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/syntaxhighlight&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/syntaxhighlight&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello.world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: spam hello world

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>4it024loyftyt5oikwp4cbni7brjbox</sha1>
    </revision>
    <revision>
      <id>2938</id>
      <parentid>2927</parentid>
      <timestamp>2019-04-21T13:09:25Z</timestamp>
      <contributor>
        <username>Divesh kumar</username>
        <id>1591</id>
      </contributor>
      <minor/>
      <comment>/* CODE */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23572">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*n+1)/2)
     
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;br /&gt;
&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----

=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;


&lt;br /&gt;
==== Complete program is ====
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;

&lt;br /&gt;&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----

=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/syntaxhighlight&gt;&lt;br /&gt;


----

=== METHOD 2: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/syntaxhighlight&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/syntaxhighlight&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello.world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: spam hello world

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>gwkme8hmlyplg2j240rnv4vzzp5stf8</sha1>
    </revision>
    <revision>
      <id>2980</id>
      <parentid>2938</parentid>
      <timestamp>2019-04-25T06:36:02Z</timestamp>
      <contributor>
        <username>V. Vaishnavi</username>
        <id>3635</id>
      </contributor>
      <comment>/* CODE */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23566">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*2+1)/2)
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;br /&gt;
&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----

=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;


&lt;br /&gt;
==== Complete program is ====
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;

&lt;br /&gt;&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----

=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/syntaxhighlight&gt;&lt;br /&gt;


----

=== METHOD 2: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/syntaxhighlight&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/syntaxhighlight&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate value sin the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello.world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: spam hello world

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>3s9e1o3lvr0om17pifygw1oo0ckfm3j</sha1>
    </revision>
    <revision>
      <id>2983</id>
      <parentid>2980</parentid>
      <timestamp>2019-04-25T15:01:58Z</timestamp>
      <contributor>
        <username>Adiga</username>
        <id>3793</id>
      </contributor>
      <comment>/* List Slices */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23566">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*2+1)/2)
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;br /&gt;
&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----

=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;


&lt;br /&gt;
==== Complete program is ====
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;

&lt;br /&gt;&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----

=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/syntaxhighlight&gt;&lt;br /&gt;


----

=== METHOD 2: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/syntaxhighlight&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/syntaxhighlight&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate values in the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello.world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: spam hello world

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>0girsl7edfgg38kj3ln6m065sx6pdff</sha1>
    </revision>
    <revision>
      <id>3043</id>
      <parentid>2983</parentid>
      <timestamp>2019-04-27T17:56:49Z</timestamp>
      <contributor>
        <username>Debasmita</username>
        <id>896</id>
      </contributor>
      <minor/>
      <comment>/* PROGRAM FOR DOBBLE GAME: */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23566">= '''Week-04 Programs and codes''' =
=='''Magic Square'''==
A magic square is a square which is divided into smaller squares which enclose numbers. In that larger square '''the sum of numbers in each row, column and diagonal is the same. The number starts from 1 and can go upto 's' where s is the number of small squares.
----

'''Magic Square Hit and Trial 1'''

In this section , we shall deal with a square divided into smaller squares, each containing a number, such that the figures in each vertical, horizontal, and diagonal row add up to the same value .

Normally a magic square of 2*2 is not possible, which is the only exception. 

What about a square containing only 1s at each cell?

So to start with, if we assume a 3x3 square then the sum of the elements must be equal to 15 in any direction - either in the vertical direction, horizontal direction or even diagonally . Generally for a n*n square , the value to which the sum should be equal to is called Magic Constant and is given by M = n.(n²+1)/2 .

Here for n = 3 , M =3.(9+1)/2
which is equal to 15 .

Some ways of arranging the elements in a 3*3 square to get a sum of 15 :
---------------
 8  1  6       6  1  8       2  7  6
 3  5  7       7  5  3       9  5  1
 4  9  2       2  9  4       4  3  8

----------------

To solve these squares , there are few facts one must know :

&lt;ul&gt;&lt;li&gt;In any magic square 1 is located at the position: (n/2,n-1).&lt;/li&gt;

&lt;li&gt;If position of 1 is now taken as(p,q) then the position of 2 is at (p-1,q+1).&lt;/li&gt; 

&lt;ol&gt;&lt;li&gt;If the calculated row position becomes equal to -1 then make it n-1 and  if column position becomes n then make it 0.&lt;/li&gt;
 
&lt;li&gt;If the calculated position already contains a number, then decrease the column by 2 and increase the row by 1 .&lt;/li&gt;

&lt;li&gt;If anytime row position becomes-1 and column becomes n, switch to (0,n-2).&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;

So first lets solve a 3 x 3 square using the facts mentioned.

Assume a 3 x 3 square as shown :
   
     E         E        E
    (0,0)    (0,1)    (0,2)


     E         E        E
    (1,0)    (1,1)    (1,2)


     E         E        E
    (2,0)    (2,1)    (2,2)


Where &quot;E&quot; denotes  the elements of the square and (a,b) represents the element's position.

Now a 3 x 3 magic square is shown :
   
     2         7        6
    (0,0)    (0,1)    (0,2)


     9         5        1
    (1,0)    (1,1)    (1,2)


     4         3        8
    (2,0)    (2,1)    (2,2)


'''Steps:'''
&lt;ol&gt; &lt;li&gt;Position of number 1 = (3/2, 3-1) = (1, 2)&lt;/li&gt;
&lt;li&gt;Position of number 2 = (1-1,2+1) = (0,3) = (0, 0)&lt;/li&gt;
   &lt;i&gt;Since the column value becomes n(i.e. 3) here,
   According to condition 1, make this column value equal to 0.&lt;/i&gt;
&lt;li&gt;Position of number 3 = (0-1, 0+1) = (-1,1) = (3-1, 1) = (2, 1)&lt;/li&gt;
   &lt;i&gt;Since the row value becomes -1 here,
   According to condition 1, make it equal to n-1 (i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 4 = (2-1, 1+1) = (1, 2)&lt;/li&gt;
   &lt;i&gt;Since, at this position, 1 is there. So, apply condition 2.
   Incrementing the row by 1 and decrementing the column by 2, we get
   New position = (1+1,2-2)=(2,0)&lt;/i&gt;
&lt;li&gt;Position of number 5=(2-1,0+1)=(1,1)&lt;/li&gt;
&lt;li&gt;Position of number 6=(1-1,1+1)=(0,2)&lt;/li&gt;
&lt;li&gt;Position of number 7 = (0-1, 2+1) = (-1,3) &lt;/li&gt;
   &lt;i&gt;Since, the row value becomes -1 and column value becomes n(i.e 3) here,
   According to condition 3, switching row value to 0 and column value to n-2(i.e. 3-2), we get 
   New position = (0, 3-2) = (0,1)&lt;/i&gt;
&lt;li&gt;Position of number 8=(0-1,1+1)=(-1,2)=(2,2) &lt;/li&gt;
   &lt;i&gt;Since, row value becomes -1 here,
   According to condition 1, make it equal to n-1(i.e. 3-1)&lt;/i&gt;
&lt;li&gt;Position of number 9=(2-1,2+1)=(1,3)=(1,0) &lt;/li&gt;
   &lt;i&gt;Since, column value becomes n (i.e 3) here,
   According to condition 1, make it equal to 0.&lt;/i&gt;

We see that this method consumes a lot of time. As someone once said:&quot;First solve the problem, then write the code&quot;. So, we shall see if a piece of code employing the facts can make us solve this puzzle faster.

We shall write two codes - One for generating an odd sized magic square and the other for printing the magic square :

&lt;br /&gt;
=== CODE ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#generating magic square
def generateSquare(n):
 
    # 2-D array with all slots set to 0
    magicSquare = [[0 for x in range(n)]for y in range(n)]
 
    # initialize position of 1
    i = n//2
    j = n-1
     
    # Fill the magic square by placing values
    num = 1
    while num &lt;= (n*n):
        if i == -1 and j == n: # third condition
            j = n-2
            i = 0 #can use multiple assignment i,j = 0,n-2
        else:
            # next number goes out of right side of square 
            if j == n:
                j = 0
            # next number goes out of upper side
            if i &lt; 0:
                i = n-1
                 
        if magicSquare[i][j]: # 2nd condition
            j = j-2
            i = i+1
            continue
        else:
            magicSquare[i][j] = num
            num = num+1
                 
        j = j+1
        i = i-1 #1st 

# Printing magic square
     
    print (&quot;Magic Squre for n = &quot;,n)
    print (&quot;Sum of each row or column&quot;,n*(n*2+1)/2)
    for i in range(0,n):
        for j in range(0,n):
     
            print (magicSquare[i][j],end=&quot; &quot;)
        print()
# Works only when n is odd
n = 7
generateSquare(n)     
&lt;/syntaxhighlight&gt;

&lt;br /&gt;
&lt;pre&gt;
Output: One should change the value of n defined in the program to get magic square of
 that particular order.

The Magic Square for n=7:
Sum of each row or column 175:

 20  12   4  45  37  29  28
 11   3  44  36  35  27  19
  2  43  42  34  26  18  10
 49  41  33  25  17   9   1
 40  32  24  16   8   7  48
 31  23  15  14   6  47  39
 22  21  13   5  46  38  30
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]


----

=== Another way to generate a magic square of odd order ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy as np

def magic_square(n):
    arr=np.zeros((n,n))
    p=n//2
    q=n-1
    a=1
    arr[p][q]=a
    for i in range(n**2-1):
        p=p-1
        q=q+1
        a=a+1
        if (p!=-1) and (q!=n):
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif (q==n):
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1):
            p=n-1
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
        elif(p==-1) and (q==n):
            p=n-1
            q=0
            if (arr[p][q]==0):
                arr[p][q]=a
            else:
                p=p+1
                q=q-2
                arr[p][q]=a
    return arr
n=input(&quot;enter the value of n \a&quot;);n=int(n)
a=magic_square(n)
print(a)
&lt;/syntaxhighlight&gt;

[[#Top]]
----
=== Easier way to get the magic square for odd order by avoiding Rule 1 and 2 ===
This is a modification to above program(Magic square for odd order) to '''AVOID Rule 1 and 2'''

First notice the important property of magic squares: &quot;A magic square remains a magic square if it are rotated&quot;. This is intuitively obvious.

So if we rotate left 90 deg (n//2,n-1) becomes (0,n//2) which is 1's position

Now the rule to construct magic square is from current position just go UP then RIGHT,
&lt;pre&gt;
i=i-1

j=j+1
 &lt;/pre&gt;
To avoid -1 or n which is out of index error in list, we use this TRICK (Rule 1 and 2 avoided):
&lt;pre&gt;
i=(i-1+n)%n

j=(j+1+n)%n
&lt;/pre&gt;
this always puts i,j in proper range for list index

actually +n can be avoided for calculating j since j+1 is always positive

Then put the next number there if it does not contain any other value (==0) , 

if this new position is already occupied put the next value below the previous position (i=i_previous+1)
Now there are 2 approaches
          1) use a temp. variable to store previous values of i and j
          2) Use the same trick again to revert with a small change
&lt;pre&gt;
                     i=(i+1+n)%n                  # +n can be avoided since i+1 is always positive
          
                     j=(j-1+n)%n
&lt;/pre&gt;
now increase i
&lt;pre&gt;
i=i+1  # going DOWN
then put next value
&lt;/pre&gt;


&lt;br /&gt;
==== Complete program is ====
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

def printarr(A):
    print(&quot;\n&quot;)
    for i in range(0,n):
       for j in range(0,n):
               print (A[i][j],end=&quot; &quot;)
       print()
    print(&quot;\n&quot;)


n=int(input(&quot;Enter order of magic square &quot;))
magicSquare=[[0 for x in range(n)]for y in range(n)]
i=0
j=n//2
num=1

while num&lt;=n*n:
    if magicSquare[i][j]==0:        #if unfilled
        magicSquare[i][j]=num
        
    else:                       #if filled
        i=(i+1+n)%n             #revert             
        j=(j-1+n)%n
        i=(i+1)%n                   #go down
        magicSquare[i][j]=num       #update next value

    i=(i-1+n)%n                 #go UP
    j=(j+1+n)%n                 #go DOWN
    num+=1

printarr(magicSquare)
print(&quot;Sum of each row, column and diagonals = &quot;,n*(n*n+1)//2) 
&lt;/syntaxhighlight&gt;

&lt;br /&gt;&lt;pre&gt;
Output:
Enter order of magic square 7


30 39 48  1 10 19 28 
38 47  7  9 18 27 29 
46  6  8 17 26 35 37 
 5 14 16 25 34 36 45 
13 15 24 33 42 44  4 
21 23 32 41 43  3 12 
22 31 40 49  2 11 20 

Sum of each row, column and diagonals =  175
&lt;/pre&gt;&lt;br /&gt;
[[#Top]]

----

=== A brute force approach ===

'''CODE:'''
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import random
a=[1,2,3,4,5,6,7,8,9]
while(1):
    random.shuffle(a)
    if((a[0]+a[1]+a[2])==15 and (a[3]+a[4]+a[5])==15 and 
       (a[6]+a[7]+a[8])==15 and (a[0]+a[3]+a[6])==15 and 
       (a[1]+a[4]+a[7])==15 and (a[2]+a[5]+a[8])==15 and 
       (a[0]+a[4]+a[8])==15 and (a[2]+a[4]+a[6])==15): 
        break 
for i in range(9): 
    print(a[i],end=&quot; &quot;) 
    if(i%3==2): 
        print(&quot;&quot;)&lt;/syntaxhighlight&gt;
[[#Top]]&lt;br /&gt;

== '''PROGRAM FOR DOBBLE GAME:''' ==
=== METHOD 1: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;

import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,4)
pos2 = random.randint(0,4)
samesymbol  = random.choice(symbol)
symbol.remove(samesymbol)
card1[pos1]=samesymbol
card2[pos2]=samesymbol
if pos1 == pos2 :
    card1[pos1] = samesymbol
    card2[pos1] = samesymbol
else:
    card1[pos1] = samesymbol
    card2[pos2] = samesymbol
    card1[pos2] = random.choice(symbol)
    symbol.remove(card1[pos2])
    card2[pos1] = random.choice(symbol)
    symbol.remove(card2[pos1])
for i in range(5):
    if i != pos1 and i != pos2 :
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == samesymbol:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)
&lt;/syntaxhighlight&gt;&lt;br /&gt;


----

=== METHOD 2: ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;import string
import random
symbol = list(string.ascii_letters)
card1 = [0]*5
card2 = [0]*5
pos1 = random.randrange(0,5)
pos2 = random.randint(0,4)
ss  = random.choice(symbol)
symbol.remove(ss)
card1[pos1]=ss
card2[pos2]=ss
for i in range(5):
    if i != pos1:
        card1[i]=random.choice(symbol)
        symbol.remove(card1[i])
for i in range(5):
    if i != pos2:
        card2[i]=random.choice(symbol)
        symbol.remove(card2[i])

print(card1,card2)

ans = input('Guess the common symbol')
if ans == ss:
    print(&quot;Hurrah!&quot;)
else:
    print(&quot;OOPS&quot;)

&lt;/syntaxhighlight&gt;

[[#Top]]

== '''Birthday paradox''' ==
===Chances of two person among 'n' persons have same birthday(using ''import'' math)===
Let the probability that two people in a room with 'n' number of people have same birthday be P(same).

Let the probability that two people in a room with 'n' number of people have different birthday be P(different)

P(same) = 1 – P(different)

P(different) can be written as 1 x (364/365) x (363/365) x (362/365) x …. x (1 – (n-1)/365)                     ...............................(1)

The n’th person should have a birthday which is not same as any of the earlier considered (n-1) persons.

To find the generalized formula, I'm using Taylor's series. (''there could be other ways also'')

The Approximation expression (1):-
 e^x = 1 + x + (x^2/2!) + ....
first-order approximation for e^x for x&lt;&lt;1:
 e^x ~ 1 + x
now, x = -a/365
 e^(-a/365) ~ 1 - a/365
The above expression derived for p(different) can be written as
1 x (1 – 1/365) x (1 – 2/365) x (1 – 3/365) x …. x (1 – (n-1)/365)

By putting the value of 1 – a/365 as e^(-a/365), we get following.
 ~ 1 x e^(-1/365) x e^(-2/365)... x e^(-n+1/365)
 ~ 1 x e^((-(n(n-1))/2)/365)
Therefore,

p(same) = 1 - p(different)
  p(same) ~ 1 - e^((-n^2)/(2x365))


'''Code''':- 
 import math 
   
 def find( n ):
     return ((1-math.exp(-n**2/(2*365)))*100)
 
 n=int(input(&quot;Enter the total number of people\n&quot;))
 if n&lt;2:
     print(&quot;No chance&quot;)
 else:
     print(find(n),&quot;% chance&quot;)
.

=== Complete Program for Birthday paradox ===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import random
birthlist = []
for i in range(30):
    year = random.randint(1993,2018)
    ly = 0
    if (year%100 !=0 and year%4 == 0 or year%400==0):
        ly = 1
    month = random.randint(1,12)
    if (ly == 1 and month == 2):
        date = random.randint(1,29)
    if (ly == 0 and month == 2):
        date = random.randint(1,28)
    elif (month % 2 == 0 and month&lt;7):
        date = random.randint(1,30)
    elif (month % 2 == 0 and month&gt;7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&lt;=7):
        date = random.randint(1,31)
    elif (month % 2 != 0 and month&gt;7):
        date = random.randint(1,30)
    dd = (date,month) #Tuples
    birthlist.append(dd) #List of tuples

print(birthlist)
#Checking the number of matches i.e people having same birthday
match = []
for i in birthlist:
    j = 0
    while i in birthlist:
        birthlist.remove(i)
        j += 1
    match.append(j)
count = 0
for i in match:
    if i &gt; 1:
        count += 1
print('Number of matches are',count)
&lt;/syntaxhighlight&gt;&lt;br /&gt;

[[#Top]]

= '''Notes''' =

== Modules ==
Modules are pieces of code that others have written to fulfill common tasks, such as generating random numbers, performing mathematical operations etc.

The basic way to use a module is to add &quot;'''import module_name'''&quot; at the top of your code &amp; then use &quot;'''module_name.var'''&quot; to access functions &amp; values with the name &quot;var&quot; in the module.

: &gt;&gt;&gt; import random

: &gt;&gt;&gt; for i in range(5):
::         print(random.randint(1,6))


The above code uses &quot;randint&quot; function defined in the random module to print 5 random numbers in the range 1 to 6 (including both 1 and 6).

There is another kind of import that can be used if you only need certain functions from a module. These take the form &quot;'''from module_name import var'''&quot; &amp; then var can be used as if it were defined normally on your code.

: '''&gt;&gt;&gt; from math import pi'''
: '''&gt;&gt;&gt; print(pi)'''

Use a comma separated list to import multiple objects.

: '''&gt;&gt;&gt; from math import pi, sqrt'''

The asterisk (*) imports all objects from a module.

: &gt;&gt;&gt; from math import *

Trying to import a module that isn't available causes an &quot;'''ImportError'''&quot;

You can import a module or object under a different name using the &quot;as&quot; keyword. This is mainly used when a module or object has a long/confusing name.

: &gt;&gt;&gt; from math import sqrt as square_root


=== The Standard Library &amp; pip ===
There are three main types of modules in python:

# Those you write yourself
# Those you install from external sources
# Those that are pre-installed with python
&lt;br /&gt;

The last type is called the standard library and contains many useful modules.

Some of the standard library's useful modules include -- string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest and many more.

Tasks that can be done by the standard library include string parsing, data serialization testing, debugging &amp; manipulating dates, emails, command line arguments &amp; much more !!

Some of the modules in the standard library are written in python and some are written in C. (please visit www.python.org for more information).

=== Major 3rd-Party Libraries ===
The python standard library alone contains extensive functionality. However, some tasks require the use of third-party libraries.

Django: The most frequently used web framework written in python, Django powers websites that include Instagram and Disqus. It has many useful features, and whatever features it lacks are covered by extension packages.

CherryPy &amp; Flask are also popular web frameworks.

For scraping data from websites, the library '''BeautifulSoup''' is very useful, and leads to better results than building your own scrapper with regular expressions.

While Python does offer modules for programmatically accessing websites, such as &quot;urllib&quot;, they are quite cumbersome to use. Third-party library requests make it much easier to use HTTP requests.

A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.

The module '''matplotlib''' allows you to create graphs based on data in Python.

The module '''NumPy''' allows for the use of multidimensional arrays that are much faster than the native python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.

The library '''SciPy''' contains numerous extensions to th functionality of NumPy.

Python can also be used for '''game development'''. Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

== Boolean Logic ==
Two Boolean values: True &amp; False

Can be compared using the equal to operator == (Comparison Operator), not equal operator (!=), &lt; or &gt;, &gt;= or &lt;=

Greater than &amp; smaller than operators can also be used to compare strings lexicographically (The alphabetical order of words is based on the alphabetical order of their component letters).

Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.

Python's Boolean operators are &quot;'''and'''&quot;, &quot;'''or'''&quot; &amp; &quot;'''not'''&quot;. Python '''uses words''' for its Boolean operators.

== Break ==
To end a loop pre-maturely, the break statement can be used. When encountered in a loop, the break statement causes the loop to finish immediately.

Using the break statement OUTSIDE THE LOOP CAUSES AN ERROR.

== Continue ==
Unlike break, continue jumps back to the top of the loop, rather than stopping it.

Basically, the continue statement stops the current iteration &amp; continues with the next one. 

Using the continue statement OUTSIDE THE LOOP CAUSES AN ERROR.


== List Slices ==
List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves '''indexing a list  with two colon separated integers'''. This '''returns a new list''' containing all the values in the old list between the specified indices.

&gt;&gt;&gt;squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt;print(squares[2:6])

Output: [4, 9, 16, 25] 

Like the arguments to range, the first index provided in a slice is included in the result but the second isn't. If the first number in a slice is omitted, it is taken to be the start of list. If the second number is omitted, it is taken to be the end of the list.

Slicing can also be done on tuples.

List slices can also have a third argument, representing the step, to include only alternate values in the slice.

Negative values can be used in list slicing as well as normal indexing. When negative values are used for the first &amp; second values in a slice, they count from the end of the list.

If the negative value is used for the step, the slice is done backwards. using [::-1] is common &amp; idiomatic way to REVERSE a list.

== List Comprehensions ==
List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.

'''&gt;&gt;&gt;cubes = [i**3 for i in range(5)]

'''

'''&gt;&gt;&gt;print(cubes)
'''

List comprehensions are '''inspired by set-builder notation''' in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

'''&gt;&gt;&gt;evens = [i**2 for i in range(10) if i**2 % 2 == 0]

'''

'''&gt;&gt;&gt;print(evens)
'''

'''Output: [0, 4, 16, 36, 64]
'''

Trying to create a list in a very extensive range will result in a MemoryError. This issue is solved by &quot;generators&quot;.

== Map ==
The built-in function map is a very useful higher order function that operates on lists (or similar objects called iterables)

The function map takes a function &amp; an iterable as arguments, and returns a new iterable with a function applied to each argument.

&gt;&gt;&gt;def add(x):
     return(x+5)


&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]

&gt;&gt;&gt;result = list(map(add, nums))

&gt;&gt;&gt;print(result)

Output: [16, 27, 38, 49, 60]

== Useful String Functions ==
'''join''' -- Joins a list of strings with another string as a separation.

'''replace''' -- Replaces one substring in a string with another.

'''startswith''' &amp; '''endswith''' -- Determines if there is a substring at the start and end of a string respectively.

To change the case of a string we use '''lower()''' &amp; '''upper()'''

The method &quot;split&quot; is the opposite of join, turning a string with a certain separator into a list.


: &gt;&gt;&gt; print(&quot;.&quot;.join([&quot;hello&quot;,&quot;world&quot;]))

:: --&gt; Output: hello.world


: &gt;&gt;&gt; print(&quot;hello me&quot;.replace(&quot;me&quot;, &quot;world&quot;))

:: --&gt; Output: hello world


: &gt;&gt;&gt; print(&quot;This world&quot;.startswith(&quot;This&quot;))

:: --&gt; Output: True


: &gt;&gt;&gt; print(&quot;hello&quot;.upper())

:: --&gt; Output: HELLO


: &gt;&gt;&gt; print(&quot;spam&quot;, &quot;hello&quot;, &quot;world&quot;)

:: --&gt; Output: spam hello world

[[#Top]]

== Recursion ==
The fundamental part of recursion is self reference -- functions calling itself.

The base case acts as the exit condition of the recursion.

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second and so on... This can occur with any number of functions.

&gt;&gt;&gt;def is_even(x):
       if x == 0:
             return(True)
       else:
             return(is_odd(x-1))

&gt;&gt;&gt;def is_odd(x):
       return(not is_even(x))


&gt;&gt;&gt;print(is_odd(17))  --&gt; True

&gt;&gt;&gt;print(is_even(23)) --&gt; False


To find the factorial of a number, recursion technique is used extensively

&gt;&gt;&gt;def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)


&gt;&gt;&gt;print (factorial(5))  --&gt; 120

== Uses of sep/end in print function ==

The print() function prints the specified message to the screen, or other standard output device.
The message can be a string, or any other object, the object will be converted into a string before written to the screen.

The function &quot;sep&quot; stands for separation. It is used to 'separate' multiple values of print statement with the provided argument

1.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you?&quot;, sep = &quot;,&quot;)

&gt;&gt;&gt; Output : Hello, how are you?

2.Example:
&gt;&gt;&gt; x = &quot;apple&quot;

&gt;&gt;&gt; y = &quot;banana&quot;

&gt;&gt;&gt; z = &quot;cherry&quot;

&gt;&gt;&gt; print(x,y,z, sep = &quot;, &quot;)

&gt;&gt;&gt; Output : apple, banana, cherry


The function &quot;end&quot; specifies what to print at the end. By default a new line is inserted at the end.

1.Example:

&gt;&gt;&gt; print(&quot;Python is fun&quot;, end = &quot;.&quot;)

&gt;&gt;&gt; Output : Python is fun.

2.Example:

&gt;&gt;&gt; print(&quot;Hello&quot;, &quot;how are you&quot;, sep = &quot;, &quot;,end = &quot;?&quot;)

&gt;&gt;&gt;Output: Hello, how are you?

[[#Top]]</text>
      <sha1>802no3xmfrj5tjx4yk1644oc43ntetm</sha1>
    </revision>
  </page>
</mediawiki>
