<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>JOCWiki</sitename>
    <dbname>Jocwiki_second</dbname>
    <base>http://sccilabs.org/jocwiki2/index.php/Main_Page</base>
    <generator>MediaWiki 1.30.0</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">JOCWiki</namespace>
      <namespace key="5" case="first-letter">JOCWiki talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
      <namespace key="2600" case="first-letter">Topic</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Lecture Notes:Week 6</title>
    <ns>0</ns>
    <id>623</id>
    <revision>
      <id>1391</id>
      <timestamp>2019-03-04T07:48:46Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <comment>Created page with &quot;'''Cryptography''' Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries. '''Ciphers	''' In cryptog...&quot;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="315">'''Cryptography'''
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.
'''Ciphers	'''
In cryptography, a cipher is an algorithm for performing encryption or decryptionâ€”a series of well-defined steps that can be followed as a procedure</text>
      <sha1>slx8gvzhjw0g7duma2wac8tzcn9moyi</sha1>
    </revision>
    <revision>
      <id>1392</id>
      <parentid>1391</parentid>
      <timestamp>2019-03-04T07:50:09Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="247">'''Cryptography'''
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.
'''Ciphers	'''
In cryptography, a cipher is an algorithm for performing encryption or decryption.</text>
      <sha1>bunnw7o5rr6tsf8nrj1ohqwvwr3kie4</sha1>
    </revision>
    <revision>
      <id>1397</id>
      <parentid>1392</parentid>
      <timestamp>2019-03-04T09:36:26Z</timestamp>
      <contributor>
        <username>Abhilash</username>
        <id>520</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="246">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers'''

In cryptography, a cipher is an algorithm for performing encryption or decryption.</text>
      <sha1>hjcd6b78bhkq8i6snwyqpfopxhtqbe4</sha1>
    </revision>
    <revision>
      <id>1398</id>
      <parentid>1397</parentid>
      <timestamp>2019-03-04T09:46:10Z</timestamp>
      <contributor>
        <username>Abhilash</username>
        <id>520</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="526">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.
'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.
'''Decryption''': Decryption is the process of converting back the cipher text to readable message.</text>
      <sha1>delhq0enkis18ex1tyaznhcmsm509br</sha1>
    </revision>
    <revision>
      <id>1399</id>
      <parentid>1398</parentid>
      <timestamp>2019-03-04T09:46:21Z</timestamp>
      <contributor>
        <username>Abhilash</username>
        <id>520</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="528">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.</text>
      <sha1>78xjv69jlh4msf5k1ez4dkomuy0pt4g</sha1>
    </revision>
    <revision>
      <id>1401</id>
      <parentid>1399</parentid>
      <timestamp>2019-03-04T09:57:22Z</timestamp>
      <contributor>
        <username>Abhilash</username>
        <id>520</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="890">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces each letter in the message by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH</text>
      <sha1>90cukxb9wdqprknpikrpgqfxjhwy98b</sha1>
    </revision>
    <revision>
      <id>1402</id>
      <parentid>1401</parentid>
      <timestamp>2019-03-04T09:59:21Z</timestamp>
      <contributor>
        <username>Abhilash</username>
        <id>520</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="933">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH</text>
      <sha1>pn7o9tzo99c1kop3tcvpm8784mtek49</sha1>
    </revision>
    <revision>
      <id>1404</id>
      <parentid>1402</parentid>
      <timestamp>2019-03-04T10:33:13Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1346">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH
'''String''':
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
syntax: import string
*Note that a string is nothing but a list of characters which ma include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.</text>
      <sha1>s5f4xcvzhautbr0yk4nev8svp5lnw3x</sha1>
    </revision>
    <revision>
      <id>1405</id>
      <parentid>1404</parentid>
      <timestamp>2019-03-04T10:34:11Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1347">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH
'''String''':
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.</text>
      <sha1>smr1hq6kngzjicylklzzzms6akgrh7v</sha1>
    </revision>
    <revision>
      <id>1408</id>
      <parentid>1405</parentid>
      <timestamp>2019-03-04T11:30:23Z</timestamp>
      <contributor>
        <username>Abhilash</username>
        <id>520</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1354">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.</text>
      <sha1>k5imcna15atjq3htxh3y7oh615gwhop</sha1>
    </revision>
    <revision>
      <id>1410</id>
      <parentid>1408</parentid>
      <timestamp>2019-03-04T11:42:42Z</timestamp>
      <contributor>
        <username>Abhilash</username>
        <id>520</id>
      </contributor>
      <comment>/* String in Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1371">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.

[[File:i1.PNG]]</text>
      <sha1>oknv6dubeg3sg2vys261roxr0g5sery</sha1>
    </revision>
    <revision>
      <id>1411</id>
      <parentid>1410</parentid>
      <timestamp>2019-03-04T12:21:28Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1560">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.
==Substitution Cipher==
 
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ




[[File:i1.PNG]]</text>
      <sha1>swoqh2dcixv0js03gv25fp5dj4914ol</sha1>
    </revision>
    <revision>
      <id>1412</id>
      <parentid>1411</parentid>
      <timestamp>2019-03-04T12:22:13Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <comment>/* Substitution Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1558">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.




[[File:i1.PNG]]
==Substitution Cipher==
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</text>
      <sha1>r997654uoek254qpwuo7a586p6ltmca</sha1>
    </revision>
    <revision>
      <id>1413</id>
      <parentid>1412</parentid>
      <timestamp>2019-03-04T12:22:58Z</timestamp>
      <contributor>
        <username>Pramitha sr</username>
        <id>1144</id>
      </contributor>
      <comment>/* Substitution Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1561">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.




[[File:i1.PNG]]
==Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</text>
      <sha1>9bkb96tcqtqk2dokqhw5cdh2guf9zhz</sha1>
    </revision>
    <revision>
      <id>1414</id>
      <parentid>1413</parentid>
      <timestamp>2019-03-04T13:24:38Z</timestamp>
      <contributor>
        <username>Abhilash</username>
        <id>520</id>
      </contributor>
      <minor/>
      <comment>/* String in Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1560">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</text>
      <sha1>h57i4ai9m59lm0ipb6dlprn2w31wuxj</sha1>
    </revision>
    <revision>
      <id>1415</id>
      <parentid>1414</parentid>
      <timestamp>2019-03-04T13:25:56Z</timestamp>
      <contributor>
        <username>Abhilash</username>
        <id>520</id>
      </contributor>
      <minor/>
      <comment>/* Substitution Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1572">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</text>
      <sha1>sxl6ydv38njk0vc8kyymuibgm0kj3b0</sha1>
    </revision>
    <revision>
      <id>1418</id>
      <parentid>1415</parentid>
      <timestamp>2019-03-04T15:37:35Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* String in Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1575">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
      Message: MEET ME 
      Cipher Text: PHHW PH
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</text>
      <sha1>2v6g4w6aa68mj5z304g3vss4u3dkhwv</sha1>
    </revision>
    <revision>
      <id>1419</id>
      <parentid>1418</parentid>
      <timestamp>2019-03-04T15:38:26Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Substitution Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1594">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</text>
      <sha1>hfd8skyqgr4yl73vrcamt5mkyhc8rr5</sha1>
    </revision>
    <revision>
      <id>1420</id>
      <parentid>1419</parentid>
      <timestamp>2019-03-04T15:38:42Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Substitution Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1603">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;


&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</text>
      <sha1>odnvmuq54qo2oct91gexl9xu6mtyzhh</sha1>
    </revision>
    <revision>
      <id>1421</id>
      <parentid>1420</parentid>
      <timestamp>2019-03-04T15:38:51Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Substitution Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1602">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</text>
      <sha1>356y89z2rk8cnjp4bncfpzui447fvme</sha1>
    </revision>
    <revision>
      <id>1501</id>
      <parentid>1421</parentid>
      <timestamp>2019-03-05T16:32:32Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2150">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.</text>
      <sha1>5zebuj3cc9n11ydl6bxturo7ux5dzo8</sha1>
    </revision>
    <revision>
      <id>1502</id>
      <parentid>1501</parentid>
      <timestamp>2019-03-05T16:40:50Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2892">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.</text>
      <sha1>g48djzfo7s1t3n4jvbrcplf7tsm66zr</sha1>
    </revision>
    <revision>
      <id>1503</id>
      <parentid>1502</parentid>
      <timestamp>2019-03-05T16:46:47Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3254">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.</text>
      <sha1>ht8n46ba8d65k9xg5loa113h1b0cpbd</sha1>
    </revision>
    <revision>
      <id>1506</id>
      <parentid>1503</parentid>
      <timestamp>2019-03-05T17:39:30Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Functional Programming */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4265">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.</text>
      <sha1>0xfmir6arb20g7029wvfb9t7owl0qxm</sha1>
    </revision>
    <revision>
      <id>1562</id>
      <parentid>1506</parentid>
      <timestamp>2019-03-07T16:48:16Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Substitution Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5930">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.</text>
      <sha1>jfz1um9e9wbqz127mynj54ydyyndzxd</sha1>
    </revision>
    <revision>
      <id>1564</id>
      <parentid>1562</parentid>
      <timestamp>2019-03-07T16:52:41Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5972">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;
[[File:Anaconda_&amp;_Files.png|400px|thumb|left|Where to save files.]]

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.</text>
      <sha1>nhfsvpigfmcwf4ddyz933qdlvppwckh</sha1>
    </revision>
    <revision>
      <id>1565</id>
      <parentid>1564</parentid>
      <timestamp>2019-03-07T16:53:16Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5980">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;
[[File:Anaconda_&amp;_Files.png|600px|thumb|left|Where to save files.]]

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.</text>
      <sha1>t54qptfujvty1n0gam9o60dza4f2n9h</sha1>
    </revision>
    <revision>
      <id>1568</id>
      <parentid>1565</parentid>
      <timestamp>2019-03-07T16:53:46Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5941">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;
[[File:Anaconda_&amp;_Files.png]]
&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.</text>
      <sha1>en4xicugx5t80lajnzg9ah0vj944b4u</sha1>
    </revision>
    <revision>
      <id>1569</id>
      <parentid>1568</parentid>
      <timestamp>2019-03-07T17:05:10Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6631">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;
[[File:Anaconda_&amp;_Files.png]]
&lt;br /&gt;
'''&quot;Plain_text.txt&quot; Content''' &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.</text>
      <sha1>f1t8hw5zpxyrert0zkiadht8wcfqjwz</sha1>
    </revision>
    <revision>
      <id>1570</id>
      <parentid>1569</parentid>
      <timestamp>2019-03-07T17:05:58Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6639">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;
[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;
&lt;br /&gt;
'''&quot;Plain_text.txt&quot; Content''' &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.</text>
      <sha1>mv1g3jcsqdxrjq7xt3s9my4wkbjxkwe</sha1>
    </revision>
    <revision>
      <id>1571</id>
      <parentid>1570</parentid>
      <timestamp>2019-03-07T17:10:04Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6640">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;
[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;
&lt;br /&gt;
'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.</text>
      <sha1>a3c95rb0nor4rwya4pm75ujpnwbc16h</sha1>
    </revision>
    <revision>
      <id>1572</id>
      <parentid>1571</parentid>
      <timestamp>2019-03-07T17:18:41Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>Tic Tac Toe Code:</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9265">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;
[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;
&lt;br /&gt;
'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.

&lt;br /&gt;
==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        #print('checking in rows')
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        #print('checking in cols')
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    #print('checking in diag')
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(symbol):
    a=[0,1,2]
    #print('in won function ',symbol)
    return check_rows(symbol) or check_cols(symbol) or check_diag(a,a,symbol) or check_diag(a,list(reversed(a)),symbol)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;
== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.</text>
      <sha1>sbbrph2iehte0wyw5v9o4zvj02jnvmj</sha1>
    </revision>
    <revision>
      <id>1573</id>
      <parentid>1572</parentid>
      <timestamp>2019-03-07T17:22:12Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Tic Tac Toe Code: */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9112">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;
[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;
&lt;br /&gt;
'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.

&lt;br /&gt;
==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.</text>
      <sha1>h9mcyqxk9ottb3ag5tz2ujvivq1oort</sha1>
    </revision>
    <revision>
      <id>1574</id>
      <parentid>1573</parentid>
      <timestamp>2019-03-07T17:28:39Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9107">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.</text>
      <sha1>k73s0q57lpmhhrwtwyinnf16m7wyelf</sha1>
    </revision>
    <revision>
      <id>1577</id>
      <parentid>1574</parentid>
      <timestamp>2019-03-07T18:40:02Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10079">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
       s = line.rstrip()

'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.


== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern), s.index(pattern, l, r)'''


== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''</text>
      <sha1>04tkphq0f3657gcbpw39xe60udbaiw6</sha1>
    </revision>
    <revision>
      <id>1578</id>
      <parentid>1577</parentid>
      <timestamp>2019-03-07T18:40:29Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Strip Whitespace */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10077">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern), s.index(pattern, l, r)'''


== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''</text>
      <sha1>ibqgvztr85479a90fvymhri3pd1coks</sha1>
    </revision>
    <revision>
      <id>1579</id>
      <parentid>1578</parentid>
      <timestamp>2019-03-07T18:45:01Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10461">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;
==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern), s.index(pattern, l, r)'''


== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.</text>
      <sha1>n8sq5zecs9aalj428sasb923rzer2ts</sha1>
    </revision>
    <revision>
      <id>1586</id>
      <parentid>1579</parentid>
      <timestamp>2019-03-08T08:27:02Z</timestamp>
      <contributor>
        <username>Snehal</username>
        <id>1971</id>
      </contributor>
      <minor/>
      <comment>/* Program for Substitution Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10476">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern), s.index(pattern, l, r)'''


== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.</text>
      <sha1>99t9femyqnjpkia2z0ize48efr2yh0w</sha1>
    </revision>
    <revision>
      <id>1588</id>
      <parentid>1586</parentid>
      <timestamp>2019-03-08T12:41:16Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Searching for Text */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10481">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.</text>
      <sha1>ovytdj050s6mccgk3vmu7xxmk8astpp</sha1>
    </revision>
    <revision>
      <id>1590</id>
      <parentid>1588</parentid>
      <timestamp>2019-03-09T04:17:13Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11045">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
  Python program to display the Fibonacci sequence upto n-th term using recursive functions

def fib(n):
  #Recursive function to print Fibonacci sequence
   if n &lt;= 0:
       return n
   else:
       return(fib(n-1) + fib(n-2))


n = int(input(&quot;Enter the number of terms: &quot;))
  #check if the number of terms is valid or not
if n &lt; 0:
   print(&quot;Please enter a positive integer&quot;)
else:
   print(&quot;Fibonacci sequence:&quot;)
   for i in range(n):
       print(fib(i))


'''For n = 10''', '''The output will be:'''

'''0 1 1 2 3 5 8 13 21'''</text>
      <sha1>hwylm56nlpub7ug6r5v1scgf4wtee1y</sha1>
    </revision>
    <revision>
      <id>1591</id>
      <parentid>1590</parentid>
      <timestamp>2019-03-09T04:18:22Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Fibonacci Sequence Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11019">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
  Python program to display the Fibonacci sequence upto n-th term using recursive functions

'''def fib(n):'''
  #Recursive function to print Fibonacci sequence
   if n &lt;= 0:
       return n
   else:
       return(fib(n-1) + fib(n-2))


n = int(input(&quot;Enter the number of terms: &quot;))
  #check if the number of terms is valid or not
if n &lt; 0:
   print(&quot;Please enter a positive integer&quot;)
else:
   for i in range(n):
       print(fib(i))


'''For n = 10''', '''The output will be:'''

'''0 1 1 2 3 5 8 13 21'''</text>
      <sha1>f4ru8txjv5lojrbehfidp9oj3bcnjh3</sha1>
    </revision>
    <revision>
      <id>1592</id>
      <parentid>1591</parentid>
      <timestamp>2019-03-09T04:21:22Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Fibonacci Sequence Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10742">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm for performing encryption or decryption to ensure secure data communication.

'''Encryption''': Encryption is the process of converting the plain text message into a form that is unreadable (Cipher Text) to third parties.

'''Decryption''': Decryption is the process of converting back the cipher text to readable message.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)</text>
      <sha1>8s7jnxv1jtblhcq70c2ebtdfzcj8uu9</sha1>
    </revision>
    <revision>
      <id>1600</id>
      <parentid>1592</parentid>
      <timestamp>2019-03-09T14:11:19Z</timestamp>
      <contributor>
        <username>Kapil</username>
        <id>1726</id>
      </contributor>
      <comment>/* Cryptography */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10901">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)</text>
      <sha1>r55ije6lxpx31nrjwsvh4r7hcsnaean</sha1>
    </revision>
    <revision>
      <id>1605</id>
      <parentid>1600</parentid>
      <timestamp>2019-03-09T16:58:00Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11812">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)
print fibm</text>
      <sha1>hb17yx5ldq1cbr5wwr6kpeyv8ooq0l5</sha1>
    </revision>
    <revision>
      <id>1606</id>
      <parentid>1605</parentid>
      <timestamp>2019-03-09T16:58:26Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* 4 Different Ways of Fibonacci in Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11814">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm</text>
      <sha1>klftfmii0nkmz66rxcf80o59xf13wfb</sha1>
    </revision>
    <revision>
      <id>1608</id>
      <parentid>1606</parentid>
      <timestamp>2019-03-09T17:14:42Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13216">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.</text>
      <sha1>cctm155sjhd1hwk9l2r2r38g12odgeu</sha1>
    </revision>
    <revision>
      <id>1609</id>
      <parentid>1608</parentid>
      <timestamp>2019-03-09T17:19:18Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13323">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.</text>
      <sha1>gzgbopt9p0mijjca30osuybgcksqe2p</sha1>
    </revision>
    <revision>
      <id>1610</id>
      <parentid>1609</parentid>
      <timestamp>2019-03-09T17:31:33Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14381">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.</text>
      <sha1>jk1lt3go54pbn35jsg68vxgycuglobl</sha1>
    </revision>
    <revision>
      <id>1611</id>
      <parentid>1610</parentid>
      <timestamp>2019-03-09T17:44:23Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14732">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.</text>
      <sha1>5ygygygz8sttdti17142tzzjvlj8ygu</sha1>
    </revision>
    <revision>
      <id>1612</id>
      <parentid>1611</parentid>
      <timestamp>2019-03-09T18:06:36Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15621">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor
&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)

'''A single function can have multiple decorators.'''</text>
      <sha1>adazp7hv0kt6bxlwrjlcxc6bvpq6lio</sha1>
    </revision>
    <revision>
      <id>1613</id>
      <parentid>1612</parentid>
      <timestamp>2019-03-09T18:07:12Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Decorators */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15623">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
*String is used to represent text in python.String comprises of spaces,numbers,characters and alphabets.
*To use string in a program we have to import a library called string.
:: syntax: import string
*Note that a string is nothing but a list of characters which may include space and special characters.
*A string should always be initialized within double quotes.
*List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;
=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>445ulgg7f1cb1ttao9st929odb312vp</sha1>
    </revision>
    <revision>
      <id>1616</id>
      <parentid>1613</parentid>
      <timestamp>2019-03-10T03:50:13Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* String in Python */  Correction</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15631">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

==Substitution Cipher==
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>ldw369ed5yp5s3qnz17v7flnkjmn4ir</sha1>
    </revision>
    <revision>
      <id>1617</id>
      <parentid>1616</parentid>
      <timestamp>2019-03-10T03:51:31Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Substitution Cipher */  Formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15633">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

===Substitution Cipher===
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;
=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>rrtlw2dh4zi22ck3vmku6o59x68zi4v</sha1>
    </revision>
    <revision>
      <id>1618</id>
      <parentid>1617</parentid>
      <timestamp>2019-03-10T03:51:50Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Substitution Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15639">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

==Program for Substitution Cipher==
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>nkiicoi9h8aq6p5b3vqv90jtnnt26xb</sha1>
    </revision>
    <revision>
      <id>1619</id>
      <parentid>1618</parentid>
      <timestamp>2019-03-10T03:52:31Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Program for Substitution Cipher */  Formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15641">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>6l5ogirl60mw7y5iuoo0bqzsc976mjh</sha1>
    </revision>
    <revision>
      <id>1620</id>
      <parentid>1619</parentid>
      <timestamp>2019-03-10T03:52:45Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Program for Substitution Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15646">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

==String in Python==
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>rtr06rlwr741db6fpusi0bb6b260cpr</sha1>
    </revision>
    <revision>
      <id>1621</id>
      <parentid>1620</parentid>
      <timestamp>2019-03-10T03:53:21Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* String in Python */  Formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15648">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>ez1e89j32cfzh9asxhob68xdahnd14a</sha1>
    </revision>
    <revision>
      <id>1622</id>
      <parentid>1621</parentid>
      <timestamp>2019-03-10T03:53:33Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* String in Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15653">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return check_rows(sym) or check_cols(sym) or check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym)

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>of6j1mf75ojrlj3zxg7ssp53hakqj5y</sha1>
    </revision>
    <revision>
      <id>1623</id>
      <parentid>1622</parentid>
      <timestamp>2019-03-10T03:54:52Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Tic Tac Toe Code: */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15668">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== Recursion ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion


== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>bg4t7m6n1zwvazvo84sgxc04be2zmjv</sha1>
    </revision>
    <revision>
      <id>1624</id>
      <parentid>1623</parentid>
      <timestamp>2019-03-10T04:08:30Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17341">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

=== Binary Search Code: with small correction ===
'''Recursion Part 05'''
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in elif part in the function, '''indexMid&gt;0'''. 
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)

#for this program, I intentionally used different variable names for functions (above) and the program (below). So that students can understand that we can use different variable names too.

n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, ' was found at position ', result+1)
&lt;/syntaxhighlight&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>ob172acjluhtc12l8yyk3pa29qrfu3b</sha1>
    </revision>
    <revision>
      <id>1625</id>
      <parentid>1624</parentid>
      <timestamp>2019-03-10T04:09:45Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Binary Search Code: with small correction */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17360">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
'''Recursion Part 05'''
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in elif part in the function, '''indexMid&gt;0'''. 
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, ' was found at position ', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>qv36x9ditwbjhcxvlw9w13s39rd883v</sha1>
    </revision>
    <revision>
      <id>1626</id>
      <parentid>1625</parentid>
      <timestamp>2019-03-10T04:10:36Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Binary Search Code: with small correction */  formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17386">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
'''Recursion Part 05'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in elif part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, ' was found at position ', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>8r7onruvqk10u9o9rn7j34t5fb6xqsg</sha1>
    </revision>
    <revision>
      <id>1627</id>
      <parentid>1626</parentid>
      <timestamp>2019-03-10T04:20:45Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17833">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
'''Recursion Part 05'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in elif part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, ' was found at position ', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>sk4d6mk93yck674s4fw416lyjv3w16x</sha1>
    </revision>
    <revision>
      <id>1628</id>
      <parentid>1627</parentid>
      <timestamp>2019-03-10T04:25:42Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Cryptography */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18061">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    #We are generating a Dictonary 'dict'
    #Below logic will wrap around the contents of string.ascii_letters
    #We know that we have positive and negative indexes for lists and strings.
    #Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    #string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    #string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
'''Recursion Part 05'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in elif part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, ' was found at position ', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>2tsedx2p8o0lqlzquvmjcm3y7qh83x0</sha1>
    </revision>
    <revision>
      <id>1629</id>
      <parentid>1628</parentid>
      <timestamp>2019-03-10T04:26:52Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18071">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)

#We are opening below file and reading, to convert its text.
#Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
#files are in same folder.
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
#If c is not in the dict, then it will be copied as it is to data.
#This applies to anything other than Alphabets. Numbers, special chars etc.
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
'''Recursion Part 05'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in elif part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, ' was found at position ', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>sbg89ozvckgjimwn1qzx9hna9bboy5z</sha1>
    </revision>
    <revision>
      <id>1630</id>
      <parentid>1629</parentid>
      <timestamp>2019-03-10T04:29:18Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18081">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
'''Recursion Part 05'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in elif part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, ' was found at position ', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>c4bskbay1vcnvewo8gy7rab18mwbl8y</sha1>
    </revision>
    <revision>
      <id>1631</id>
      <parentid>1630</parentid>
      <timestamp>2019-03-10T04:32:05Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Cryptography */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18087">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;
===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
'''Recursion Part 05'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in elif part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, ' was found at position ', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>kqzxy1wk8pldza6zks8gwymviab0mw8</sha1>
    </revision>
    <revision>
      <id>1632</id>
      <parentid>1631</parentid>
      <timestamp>2019-03-10T04:32:47Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Binary Search Code: with small correction */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18092">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;
===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in elif part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, ' was found at position ', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>kpjry7elm182c3qnnnq9k073bltzf8a</sha1>
    </revision>
    <revision>
      <id>1633</id>
      <parentid>1632</parentid>
      <timestamp>2019-03-10T04:33:18Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Binary Search Code: with small correction */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18098">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;
===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, ' was found at position ', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>29fvk80foyn1a9co1mbr3kqfmhajkh2</sha1>
    </revision>
    <revision>
      <id>1634</id>
      <parentid>1633</parentid>
      <timestamp>2019-03-10T04:35:45Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18712">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;


== Terminologies of Cryptography ==
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.



===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, ' was found at position ', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>tqtacwh7wbi6w2zz8hloio1xqss4nqo</sha1>
    </revision>
    <revision>
      <id>1635</id>
      <parentid>1634</parentid>
      <timestamp>2019-03-10T04:35:54Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Binary Search Code: with small correction */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18717">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;


== Terminologies of Cryptography ==
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.



===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>5yjmifc46mdju7d6yg98wgjr7y1h99s</sha1>
    </revision>
    <revision>
      <id>1636</id>
      <parentid>1635</parentid>
      <timestamp>2019-03-10T04:36:43Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="18717">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;


== Terminologies of Cryptography ==
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>dhuvu6f4m12cxjpzdo2mey21td36gn1</sha1>
    </revision>
    <revision>
      <id>1637</id>
      <parentid>1636</parentid>
      <timestamp>2019-03-10T04:37:52Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19019">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;


== Terminologies of Cryptography ==
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>dpfmbxxpxfr5b5ouijxjgigwv1bllh3</sha1>
    </revision>
    <revision>
      <id>1638</id>
      <parentid>1637</parentid>
      <timestamp>2019-03-10T04:47:38Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Binary Search Code: with small correction */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19029">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
*import string
print(string.ascii_letters)
The concatenation of the ascii_lowercase and ascii_uppercase constants. 
*Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

&lt;br /&gt;

===String in Python===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.


[[File:i1.PNG]]


&lt;br /&gt;

=='''Tic Tac Toe Code:'''==
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;
&lt;br /&gt;


== Terminologies of Cryptography ==
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


== String Formatting ==
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

== NumPy ==
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

--A powerful N-dimensional array object.

--Sophisticated (broadcasting) functions.

--Tools for integrating C/C++ &amp; Fortran code.

--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>1r5846zvb4kyjesy8w05ya7ndydkw85</sha1>
    </revision>
    <revision>
      <id>1639</id>
      <parentid>1638</parentid>
      <timestamp>2019-03-10T05:01:08Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>Page maintenance - merging duplicate topics.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19095">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

&gt;&gt;&gt;nums = [4, 5, 6]

&gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

&gt;&gt;&gt;print(msg)

Output: '''Numbers: 4 5 6'''

Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

String formatting can also be done with named arguments.

&lt;br /&gt;

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== String Processing ==
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


== Strip Whitespace ==
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

== Searching for Text ==
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

== Joining Strings ==
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

== Converting Case ==
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>8zwzkmjlu4q25kqmpod2hpr7he6rxu9</sha1>
    </revision>
    <revision>
      <id>1640</id>
      <parentid>1639</parentid>
      <timestamp>2019-03-10T05:09:48Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>Page maintenance - merging duplicate topics.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19247">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.



=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;


== Fibonacci Sequence Code ==
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

== 4 Different Ways of Fibonacci in Python ==
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''

== Fibonacci Sequence using Memoization as a Decorator ==

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]


@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)</text>
      <sha1>b2yymppbz44hgakjgh7e8powm4c2sef</sha1>
    </revision>
    <revision>
      <id>1641</id>
      <parentid>1640</parentid>
      <timestamp>2019-03-10T05:14:24Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>Page maintenance - merging duplicate topics.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19252">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.



=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;


=== Fibonacci Sequence Code ===
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

=== Fibonacci Sequence using Memoization as a Decorator ===

class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a


print fib(5)

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>0jlun0lnp97q2s3eksa5k8u3eitg89n</sha1>
    </revision>
    <revision>
      <id>1642</id>
      <parentid>1641</parentid>
      <timestamp>2019-03-10T05:16:58Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Fibonacci Sequence using Memoization as a Decorator */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19263">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.



=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;


=== Fibonacci Sequence Code ===
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)


'''2. Using Recursion'''

def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)


'''3. Using generators'''

a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()

'''4. Using memoization'''

def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]


def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a


fibm = memoize(fib,5)

print fibm

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>2u6r4noaq6845ktpz5de1kgcp36qij8</sha1>
    </revision>
    <revision>
      <id>1643</id>
      <parentid>1642</parentid>
      <timestamp>2019-03-10T05:19:04Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* 4 Different Ways of Fibonacci in Python */  Formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19305">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.



=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;


=== Fibonacci Sequence Code ===
'''def Fibonacci(n):'''
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))


n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>15qit2aktuxn20ml6oewlnmdon7t7at</sha1>
    </revision>
    <revision>
      <id>1644</id>
      <parentid>1643</parentid>
      <timestamp>2019-03-10T05:19:47Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Fibonacci Sequence Code */  formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19309">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.



=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;


=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>o8beqbqgugxas8gkt35z7sj09owrt7v</sha1>
    </revision>
    <revision>
      <id>1645</id>
      <parentid>1644</parentid>
      <timestamp>2019-03-10T05:20:26Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Fibonacci Sequence using Memoization as a Decorator */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19317">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.



=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;


=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>hmlqfm2cvkhpy470hvyilaght9hs3fx</sha1>
    </revision>
    <revision>
      <id>1646</id>
      <parentid>1645</parentid>
      <timestamp>2019-03-10T05:20:46Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* 4 Different Ways of Fibonacci in Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19325">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.



=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;


=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>o5kfgrzve3zfr2xwpjsvytazusf7yop</sha1>
    </revision>
    <revision>
      <id>1647</id>
      <parentid>1646</parentid>
      <timestamp>2019-03-10T05:21:13Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Fibonacci Sequence Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19333">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.



=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;


=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>7m43734g7jd0agfnyq7ke3p7s52fops</sha1>
    </revision>
    <revision>
      <id>1648</id>
      <parentid>1647</parentid>
      <timestamp>2019-03-10T05:21:30Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Binary Search Code: with small correction */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19332">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.



=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.


== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== Generators ==
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

== Lambdas ==
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

== Filter ==
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


== Decorators ==
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>pd6vtmf9th6p03vdts3nzrjq6eb94gq</sha1>
    </revision>
    <revision>
      <id>1649</id>
      <parentid>1648</parentid>
      <timestamp>2019-03-10T05:24:23Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>Page maintenance - merging duplicate topics.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19346">==Cryptography==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.



=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>bqjxrmey3e16q5qaowr5fa2efxgye8m</sha1>
    </revision>
    <revision>
      <id>1650</id>
      <parentid>1649</parentid>
      <timestamp>2019-03-10T05:24:46Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Cryptography */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19350">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== Functional Programming ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>azb6zkev1lf96y9rnwwiuqg7i0fmr3w</sha1>
    </revision>
    <revision>
      <id>1651</id>
      <parentid>1650</parentid>
      <timestamp>2019-03-10T05:25:01Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Functional Programming */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19356">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.
&lt;br /&gt;

'''Characteristics of Modern Cryptography'''

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.


===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

* Strings are Easy to read &amp; write text files.
* String processing functions make it easy to analyse &amp; transform contents.
&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>1imvxf7nepgiftpcsvgbdyhq3kumrxw</sha1>
    </revision>
    <revision>
      <id>1652</id>
      <parentid>1651</parentid>
      <timestamp>2019-03-10T05:28:53Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Cryptography */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19246">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

==='''Characteristics of Modern Cryptography'''===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>l2vvsbr757qfd7b9yd2zzt4gy6owp56</sha1>
    </revision>
    <revision>
      <id>1653</id>
      <parentid>1652</parentid>
      <timestamp>2019-03-10T05:29:16Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Characteristics of Modern Cryptography */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19254">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

==='''Characteristics of Modern Cryptography'''===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
===Substitution Cipher===
----
It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>mnk9nj947943ve4rl78lh47hcjixb98</sha1>
    </revision>
    <revision>
      <id>1654</id>
      <parentid>1653</parentid>
      <timestamp>2019-03-10T05:30:11Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Substitution Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19256">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

==='''Characteristics of Modern Cryptography'''===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>fv6i55h9h1dpqtlcsu6pcv8zupctix1</sha1>
    </revision>
    <revision>
      <id>1655</id>
      <parentid>1654</parentid>
      <timestamp>2019-03-10T05:31:06Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Characteristics of Modern Cryptography */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19250">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== '''Code with Explanation''' ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>20cew3i6q0fpaj5aabw0cyrfgsi2huy</sha1>
    </revision>
    <revision>
      <id>1656</id>
      <parentid>1655</parentid>
      <timestamp>2019-03-10T05:31:29Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19244">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>ssmpjtj1sti7fiw5anwpr3f9fqfd6nn</sha1>
    </revision>
    <revision>
      <id>1657</id>
      <parentid>1656</parentid>
      <timestamp>2019-03-10T09:49:32Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19569">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>kquw5ms0l9tckg294xb9yt01f36aux1</sha1>
    </revision>
    <revision>
      <id>1658</id>
      <parentid>1657</parentid>
      <timestamp>2019-03-10T09:57:09Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="20508">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>m072r45a72kk24rxnp2yjbbixczqh59</sha1>
    </revision>
    <revision>
      <id>1659</id>
      <parentid>1658</parentid>
      <timestamp>2019-03-10T10:03:37Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="21133">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>dqial0qhjl1t8xsaee31dcnnuv9gsoj</sha1>
    </revision>
    <revision>
      <id>1661</id>
      <parentid>1659</parentid>
      <timestamp>2019-03-10T10:06:05Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Algorithm for Caesar Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="21244">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.jpeg]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>nnfh0kz5421e8eyq7i6fcmak50655h7</sha1>
    </revision>
    <revision>
      <id>1662</id>
      <parentid>1661</parentid>
      <timestamp>2019-03-10T10:07:26Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Algorithm for Caesar Cipher */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="21243">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>h4ke0poze76f3btadqb0tb8hevhph35</sha1>
    </revision>
    <revision>
      <id>1663</id>
      <parentid>1662</parentid>
      <timestamp>2019-03-10T11:17:12Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Tic Tac Toe Code: */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22650">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we &lt;u&gt;use dictionary&lt;/u&gt; for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.
# Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;
# We need to change in &lt;code&gt;play()&lt;/code&gt; too. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;syntaxhighlight&gt;
&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>qvts6nll72b5v6gc5h2plrt26nxzuio</sha1>
    </revision>
    <revision>
      <id>1664</id>
      <parentid>1663</parentid>
      <timestamp>2019-03-10T11:17:47Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Can we use dictionary for &quot;Tic Tac Toe&quot;? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22651">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we &lt;u&gt;use dictionary&lt;/u&gt; for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.
# Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;
# We need to change in &lt;code&gt;play()&lt;/code&gt; too. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>ryoand7b3pdwja00sbrjdxh23biu62p</sha1>
    </revision>
    <revision>
      <id>1665</id>
      <parentid>1664</parentid>
      <timestamp>2019-03-10T11:18:48Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Can we use dictionary for &quot;Tic Tac Toe&quot;? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22659">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we &lt;u&gt;use dictionary&lt;/u&gt; for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.
# Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;
# We need to change in &lt;code&gt;play()&lt;/code&gt; too. We will do as below.

&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>o6m0s8con7s9k81lpstnk4semp690ts</sha1>
    </revision>
    <revision>
      <id>1666</id>
      <parentid>1665</parentid>
      <timestamp>2019-03-10T11:23:10Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Can we use dictionary for &quot;Tic Tac Toe&quot;? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22653">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''Can we &lt;u&gt;use dictionary&lt;/u&gt; for ''&quot;Tic Tac Toe&quot;''?'''
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.
# Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;
# We need to change in &lt;code&gt;play()&lt;/code&gt; too. We will do as below.

&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>qhnubal02t9n6drle1ipz4c1rq72opm</sha1>
    </revision>
    <revision>
      <id>1667</id>
      <parentid>1666</parentid>
      <timestamp>2019-03-10T11:31:26Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Tic Tac Toe Code: */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22954">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''Can we &lt;u&gt;use dictionary&lt;/u&gt; for ''&quot;Tic Tac Toe&quot;''?'''
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.
* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>sn3s3k7wfv9knfx1o5az3h406ehneuc</sha1>
    </revision>
    <revision>
      <id>1668</id>
      <parentid>1667</parentid>
      <timestamp>2019-03-10T11:37:57Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Tic Tac Toe Code: */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="22953">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.
* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>clmx95l5bipvyixarhq9bnb31x9mlcq</sha1>
    </revision>
    <revision>
      <id>1669</id>
      <parentid>1668</parentid>
      <timestamp>2019-03-10T11:55:06Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <comment>/* Can we use dictionary for &quot;Tic Tac Toe&quot;? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23072">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>4ig46qsali58y3r3i2fosu8swqeltk6</sha1>
    </revision>
    <revision>
      <id>1671</id>
      <parentid>1669</parentid>
      <timestamp>2019-03-10T12:05:11Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Can we use dictionary for &quot;Tic Tac Toe&quot;? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23067">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>m442n5idcy6gcnbiurlfibch44ert9j</sha1>
    </revision>
    <revision>
      <id>1672</id>
      <parentid>1671</parentid>
      <timestamp>2019-03-10T12:08:18Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Can we use dictionary for &quot;Tic Tac Toe&quot;? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23073">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']='''won(player1['symbol'])'''&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>dqz8yqwlaxguezhvwarprhnbmzzpge6</sha1>
    </revision>
    <revision>
      <id>1673</id>
      <parentid>1672</parentid>
      <timestamp>2019-03-10T12:09:06Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Can we use dictionary for &quot;Tic Tac Toe&quot;? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23067">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;

=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>m442n5idcy6gcnbiurlfibch44ert9j</sha1>
    </revision>
    <revision>
      <id>1684</id>
      <parentid>1673</parentid>
      <timestamp>2019-03-10T17:37:46Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23697">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.


=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.

===Tic Tac Toe '''Code:'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>d98pggba073eizxhdhzadw2g7cs9tw8</sha1>
    </revision>
    <revision>
      <id>1685</id>
      <parentid>1684</parentid>
      <timestamp>2019-03-10T17:42:30Z</timestamp>
      <contributor>
        <username>Raghav</username>
        <id>1067</id>
      </contributor>
      <comment>/* Tic Tac Toe */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25594">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.


=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;
===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>ji9v432owebvqozznaahjsswtce43lu</sha1>
    </revision>
    <revision>
      <id>1686</id>
      <parentid>1685</parentid>
      <timestamp>2019-03-10T17:44:37Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26736">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;
===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>hqzf96w07xyrxp4k97taqb7rvj3nvkt</sha1>
    </revision>
    <revision>
      <id>1688</id>
      <parentid>1686</parentid>
      <timestamp>2019-03-10T17:46:34Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Explanation of ROT13 algorithm */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26786">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;
===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>i9g7s86u9afz46bhdmmmfchb92tpe9v</sha1>
    </revision>
    <revision>
      <id>1689</id>
      <parentid>1688</parentid>
      <timestamp>2019-03-10T17:47:20Z</timestamp>
      <contributor>
        <username>Hardev k</username>
        <id>1650</id>
      </contributor>
      <comment>/* Explanation of ROT13 algorithm */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26788">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT13.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;
===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>gc2av3uuu0es3bnoqm4zr9fl0o0u04n</sha1>
    </revision>
    <revision>
      <id>1700</id>
      <parentid>1689</parentid>
      <timestamp>2019-03-11T16:49:42Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26876">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

#If you want to see the dictionary used for conversion, uncomment below print comment.
#print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as it is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT13.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;
===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>28gctf3bagudz4905gby4dgtktu98aq</sha1>
    </revision>
    <revision>
      <id>1701</id>
      <parentid>1700</parentid>
      <timestamp>2019-03-11T16:52:20Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26876">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

#If you want to see the dictionary used for conversion, uncomment below print comment.
#print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
&quot;&quot;&quot;
If c is not in the dict, then it will be copied as-it-is to data.
This applies to anything other than Alphabets. Numbers, special chars etc.
&quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT13.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;
===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>ifwixcaab80g6icwofah3zfxm6puaw8</sha1>
    </revision>
    <revision>
      <id>1705</id>
      <parentid>1701</parentid>
      <timestamp>2019-03-12T04:25:35Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26916">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

#If you want to see the dictionary used for conversion, uncomment below print comment.
#print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
        &quot;&quot;&quot;
        If c is not in the dict, then it will be copied as-it-is to
        data. This applies to anything other than Alphabets. Numbers,
        special chars etc.
        &quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT13.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;
===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>8d1qmtvmfpak62fqinukb1jny7g36eu</sha1>
    </revision>
    <revision>
      <id>1706</id>
      <parentid>1705</parentid>
      <timestamp>2019-03-12T04:26:33Z</timestamp>
      <contributor>
        <username>Arunkumar</username>
        <id>2448</id>
      </contributor>
      <minor/>
      <comment>/* Code with Explanation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26931">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

#If you want to see the dictionary used for conversion, uncomment below print comment.
#print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
        &quot;&quot;&quot;
        If c is not in the dict, then it will be copied as-it-is to
        data. This applies to anything other than Alphabets.
        For example... Numbers, special chars etc.
        &quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT13.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;
===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>1lfs2f8vtgebphoy1pluuxhu3hrfgpv</sha1>
    </revision>
    <revision>
      <id>2965</id>
      <parentid>1706</parentid>
      <timestamp>2019-04-24T00:47:58Z</timestamp>
      <contributor>
        <username>Divesh kumar</username>
        <id>1591</id>
      </contributor>
      <minor/>
      <comment>/* Tic Tac Toe Code as per the video lecture: */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26932">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

#If you want to see the dictionary used for conversion, uncomment below print comment.
#print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
        &quot;&quot;&quot;
        If c is not in the dict, then it will be copied as-it-is to
        data. This applies to anything other than Alphabets.
        For example... Numbers, special chars etc.
        &quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT13.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][0] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;

===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'X','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>jq1ckzoospno0y9smkztaunlrdr8wex</sha1>
    </revision>
    <revision>
      <id>2966</id>
      <parentid>2965</parentid>
      <timestamp>2019-04-24T00:53:49Z</timestamp>
      <contributor>
        <username>Divesh kumar</username>
        <id>1591</id>
      </contributor>
      <minor/>
      <comment>/* Can we use dictionary for &quot;Tic Tac Toe&quot;? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26932">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

#If you want to see the dictionary used for conversion, uncomment below print comment.
#print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
        &quot;&quot;&quot;
        If c is not in the dict, then it will be copied as-it-is to
        data. This applies to anything other than Alphabets.
        For example... Numbers, special chars etc.
        &quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT13.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][0] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;

===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'0','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>qxscifnjpjxin7hjhatu6vf2qan6sq5</sha1>
    </revision>
    <revision>
      <id>2967</id>
      <parentid>2966</parentid>
      <timestamp>2019-04-24T01:09:25Z</timestamp>
      <contributor>
        <username>Divesh kumar</username>
        <id>1591</id>
      </contributor>
      <minor/>
      <comment>/* Fibonacci Sequence Code */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26933">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

#If you want to see the dictionary used for conversion, uncomment below print comment.
#print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
        &quot;&quot;&quot;
        If c is not in the dict, then it will be copied as-it-is to
        data. This applies to anything other than Alphabets.
        For example... Numbers, special chars etc.
        &quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT13.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][0] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;

===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'0','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(Fibonacci(n-1) + Fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print(Fibonacci(i))
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print fib(5)&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>hd4kjs886pc9xy468j7aur9ob1uknxy</sha1>
    </revision>
    <revision>
      <id>2968</id>
      <parentid>2967</parentid>
      <timestamp>2019-04-24T01:12:18Z</timestamp>
      <contributor>
        <username>Divesh kumar</username>
        <id>1591</id>
      </contributor>
      <minor/>
      <comment>/* 4 Different Ways of Fibonacci in Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26934">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

#If you want to see the dictionary used for conversion, uncomment below print comment.
#print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
        &quot;&quot;&quot;
        If c is not in the dict, then it will be copied as-it-is to
        data. This applies to anything other than Alphabets.
        For example... Numbers, special chars etc.
        &quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT13.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][0] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;

===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'0','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(Fibonacci(n-1) + Fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print(Fibonacci(i))
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

print(fib(5))&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
       a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>7qkubhcx38dlz6wwsnacwncey10kfef</sha1>
    </revision>
    <revision>
      <id>2973</id>
      <parentid>2968</parentid>
      <timestamp>2019-04-24T15:26:02Z</timestamp>
      <contributor>
        <username>GhayathriJ</username>
        <id>1480</id>
      </contributor>
      <minor/>
      <comment>/* 4 Different Ways of Fibonacci in Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26940">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

#If you want to see the dictionary used for conversion, uncomment below print comment.
#print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
        &quot;&quot;&quot;
        If c is not in the dict, then it will be copied as-it-is to
        data. This applies to anything other than Alphabets.
        For example... Numbers, special chars etc.
        &quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT13.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][0] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;

===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'0','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(Fibonacci(n-1) + Fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print(Fibonacci(i))
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
         a,b = b,a+b
       return a

print(fib(5))&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
           a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>j79x9qiz2ycqlh9ct7eu3qudhq6umkz</sha1>
    </revision>
    <revision>
      <id>2974</id>
      <parentid>2973</parentid>
      <timestamp>2019-04-24T15:37:23Z</timestamp>
      <contributor>
        <username>GhayathriJ</username>
        <id>1480</id>
      </contributor>
      <minor/>
      <comment>/* 4 Different Ways of Fibonacci in Python */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="27136">=='''Cryptography'''==
Cryptography is the practice and study of techniques for secure communication in the presence of third parties called adversaries.

'''Ciphers''': In cryptography, a cipher is an algorithm(or technique) used for performing encryption or decryption to ensure secure data communication.It is a method used to hide words(or text) by replacing original letters with other letters or symbols.

'''Encryption''': Encryption is the process of converting information or data into a secret(or unreadable) code to prevent unauthorized users.

'''Decryption''': Decryption is the reverse process of encryption.It is used to convert(or decode) the encrypted data into readable form.

Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.

&lt;br /&gt;

===Characteristics of Modern Cryptography===

The basic characteristics of modern cryptography are as follows âˆ’

-- It operates on bit sequences.

-- It uses mathematical algorithms for securing the information.

-- It requires parties interested in secure communication channel to achieve privacy.

&lt;br /&gt;

=== Terminologies of Cryptography ===
The frequently used terms in cryptography are as follows:

'''Plain Text'''

The plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.

'''Cipher Text'''

Cipher text is the message obtained after applying cryptography on plain text.

'''Encryption'''

The process of converting plain text to cipher text is called encryption. It is also called as encoding.

'''Decryption'''

The process of converting cipher text to plain text is called decryption. It is also termed as decoding.

&lt;br /&gt;
==='''Substitution Cipher'''===

It involves replacement of letters of the plaintext message by other letters or symbols.

'''Caesar Cipher''': It is the earliest known substitution cipher used for sending secret messages by Julius Caesar. It replaces or shifts each letter in the message by certain number of places, say by the next 3rd letter. 

For example, 
 &lt;nowiki&gt;      Message: MEET ME 
      Cipher Text: PHHW PH&lt;/nowiki&gt;

&lt;br /&gt;


=== Code with Explanation ===
----
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import string
dict ={}
data=&quot;&quot;

#This file, &quot;Messed_text.txt&quot;, will be created by this code itself.
messed=open(&quot;Messed_text.txt&quot;,&quot;w&quot;)

for i in range(len(string.ascii_letters)):
    &quot;&quot;&quot;
    We are generating a Dictonary 'dict'
    Below logic will wrap around the contents of string.ascii_letters
    We know that we have positive and negative indexes for lists and strings.
    Index Shifting happens like this because of [i-13], 0-13=-13 and 52-13=39
    string.ascii_letters[i] is Generating &quot;Keys&quot; and,
    string.ascii_letters[i-13] is Generating &quot;Values&quot; after shifting.
    &quot;&quot;&quot;
    dict[string.ascii_letters[i]]=string.ascii_letters[i-13]

#If you want to see the dictionary used for conversion, uncomment below print comment.
#print(dict)
&quot;&quot;&quot;
We are opening below file and reading, to convert its text.
Make sure both, &quot;Substitution_Cipher.py&quot; and &quot;Plain_text.txt&quot;,
files are in same folder.
&quot;&quot;&quot;
with open(&quot;Plain_text.txt&quot;) as f:
    while True:
        c=f.read(1)
        #If End Of File (EOF), is reached, program should Stop.
        if not c:
            print(&quot;Reached EOF.&quot;)
            break
        #Below condition is checking if c is in dict or not.
        if c in dict:
            data=dict[c]
        else:
        &quot;&quot;&quot;
        If c is not in the dict, then it will be copied as-it-is to
        data. This applies to anything other than Alphabets.
        For example... Numbers, special chars etc.
        &quot;&quot;&quot;
            data=c
        messed.write(data)
messed.close()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

'''&quot;Plain_text.txt&quot;''' Content: &lt;br /&gt;
: Once upon a time, in a jungle there lived a jackal by the name of Gomaya. One day, he was very hungry and was wandering in search of food. While wandering, he came across a battle field. There he saw a big drum lying under a tree. When the wind blew, a tender branch grown at the root of the tree struck the drum producing sound of a drum beat. The jackal examined the drum from all sides and then beat the drum with his front paws. The drum made a sound. Now the jackal thought that there might be some other small animal inside the drum and that would make a very tasty meal for him. But he found the top of the drum too tough to tear off.
&lt;br /&gt;

[[File:Anaconda_&amp;_Files.png]]

&lt;br /&gt;

===Program for Substitution Cipher===
----
* String is used to represent text in python.String comprises of spaces, numbers, characters and alphabets.
* To use string in a program we have to import a library called string.
:: syntax: import string
* Note that a string is nothing but a list of characters which may include space and special characters.
* A string should always be initialized within double quotes.
* List indexing always begins from 0.
* import string
:: print(string.ascii_letters)
* The concatenation of the ascii_lowercase and ascii_uppercase constants. 
:: Prints abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

[[File:i1.PNG]]

&lt;br /&gt;

=== String Formatting ===
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's '''format''' method to substitute a number of arguments in the string.

:: &gt;&gt;&gt;nums = [4, 5, 6]

:: &gt;&gt;&gt;msg = &quot;Numbers: {0} {1} {2}&quot;.format(nums[0], nums[1], nums[2])

:: &gt;&gt;&gt;print(msg)

::: Output: '''Numbers: 4 5 6'''

* Each argument of the format function is placed in the string at the corresponding position, which is determined by using the curly braces {}.

* String formatting can also be done with named arguments.

&lt;br /&gt;
=== String Processing ===
Easy to read &amp; write text files.

String processing functions make it easy to analyse &amp; transform contents.


=== Strip Whitespace ===
'''s.rstrip()''' removes trailing whitespaces.

&gt;&gt;&gt;for line in contents:
     s = line.rstrip()


'''s.lstrip()''' removes leading whitespaces.

'''s.strip()''' removes leading and trailing whitespaces.

=== Searching for Text ===
'''s.find(pattern)''' returns first position in '''s''' where '''pattern''' occurs, '''-1''' if no occurrence of pattern.

'''s.find(patten, start, end)'''

--------------------------------------------------

Search for '''pattern''' in slice '''s[start: end]'''

'''s.index(pattern)'''

'''s.index(pattern, l, r)'''

=== Joining Strings ===
Recombine a list of strings using a separator.

'''columns = s.split(&quot;,&quot;)'''

'''joinstring = &quot;,&quot;'''

'''csvline = joinstring.join(columns)'''

'''date = &quot;16&quot;'''

'''month = &quot;08&quot;'''

'''year = &quot;2021&quot;'''

'''today = &quot;-&quot;.join([date, month, year])'''

=== Converting Case ===
'''s.captalize()''' -- returns a new string with first letter Uppercase, rest lower.

'''s.lower()''' -- Converts all uppercase letters to lowercase.

'''s.uppercase()''' -- Converts all lowercase letters to uppercase.

'''s.swapcase()''' -- The swapcase() method returns a copy of the string in which all the case-based characters have had their case swapped.

=== Double Strength Encryption ===
Double strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different pattern/algorithm.

The other names for double strength encryption include cascade encryption or cascade ciphering.


=== Cryptography Packages ===
Python includes a package called cryptography which provides cryptographic recipes and primitives. There are various packages with both high level recipes &amp; low level interfaces to common cryptographic algorithms such as '''symmetric ciphers''', '''message digests''' &amp; '''key derivation function'''.

=== '''Algorithm for Reverse Cipher''' ===
The algorithm for reverse cipher holds the following features -- 

* Reverse cipher uses a pattern of reversing the string of plain text to convert as cipher text.

* The process of encryption and decryption is same.

* To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.

'''Drawback'''

The major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel.


=== '''Algorithm for Caesar Cipher''' ===
The algorithm for Caesar Cipher holds the following features -- 

* Caesar Cipher technique is simple &amp; easy method of encryption technique.

* It is simple type of substitution cipher.

* Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.

The following diagram depicts the working of Caesar cipher algorithm implementation âˆ’

[[File:Caesar.JPG]]

'''Hacking of Caesar Cipher Algorithm'''

The cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.


=== '''Hybrid Cryptography''' ===
Hybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.

Due to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.

=== '''Explanation of ROT13 algorithm''' ===
ROT13 cipher refers to the abbreviated form '''Rotate by 13 places'''. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.

'''Pictorial Representation'''

[[File:ROT13.JPG]]


Program code for ROT13 algorithm:
&lt;pre&gt;
from string import maketrans

rot13trans = maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 
   'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')

# Function to translate plain text
def rot13(text):
   return text.translate(rot13trans)
def main():
   txt = &quot;ROT13 Algorithm&quot;
   print rot13(txt)
	
if __name__ == &quot;__main__&quot;:
   main()

&lt;/pre&gt;

'''Drawback'''

The ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.

'''Analysis of ROT13 Algorithm'''

ROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.

=='''Tic Tac Toe'''==
Through this program we will see how arrays can be used.

=== NumPy ===
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, &amp; tools for working with these arrays.

It is the fundamental package for scientific computing with Python. It contains various features including:

:-- A powerful N-dimensional array object.
:--Sophisticated (broadcasting) functions.
:--Tools for integrating C/C++ &amp; Fortran code.
:--Useful linear algebra, Fourier transform, &amp; random number capabilities.

Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data.

Arbitrary data-types can be defined using NumPy which allows NumPy to seamlessly &amp; speedily integrate with a wide variety of databases.
===Tic Tac Toe '''Code as per the video lecture:'''===
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
import numpy
board = numpy.array([['-','-','-'],['-','-','-'],['-','-','-']])                 
p1s='X'
p2s='O'

def check_rows(symbol):
    for r in range(3):
        count=0
        for c in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False
def check_cols(symbol):
    for c in range(3):
        count=0
        for r in range(3):
            if board[r][c]==symbol:
                count=count+1
        if count==3:
            print(symbol,&quot;won&quot;)
            return True
    return False  

def check_diagonals(symbol):
    if board[0][2] == board[1][1] and board[1][1] == board[2][0] and board[1][1]==symbol:
        print(symbol, 'won')
    if  board[0][0] == board[1][1] and board[1][1] == board[2][2] and board[1][1]==symbol: 
         print(symbol, 'won')
         return True
    return False
   
def won(symbol):
    return check_rows(symbol) or check_cols(symbol) or check_diagonals(symbol)

def place(symbol):
    print(numpy.matrix(board))
    while(1):
        row = int(input(&quot;Enter row - 1 2 3:&quot;))
        column = int(input(&quot;Enter column - 1 2 3:&quot;))
        if row&gt;0 and row&lt;4 and column&gt;0 and column&lt;4 and board[row-1][column-1]=='-':
            break
        else:
            print('Invalid input, Please enter again')

    board[row-1][column-1]=symbol     

def play():
    for turn in range(9):
        if turn%2==0:
            print('X turn')
            place(p1s)
            if won(p1s):
                break
        else:
            print('O turn')
            place(p2s)
            if won(p2s):
                break
            
    if not(won(p1s)) and not(won(p2s)):
        print(&quot;Draw&quot;)
                 
play() 
&lt;/syntaxhighlight&gt;&lt;br /&gt;

===Tic Tac Toe '''Code :'''===
&lt;code&gt;Posted By: [[User:Arunkumar|Arunkumar]] | [http://sccilabs.org/jocwiki/index.php/Talk:Lecture_Notes:Week_6 Doubts on this topic?]&lt;/code&gt;&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#We Use arrays for this game, for that we need to import numpy
import numpy
Nboard=numpy.array([['11','12','13'],
                    ['21','22','23'],
                    ['31','32','33']])

Gboard=numpy.array([['_','_','_'],
                    ['_','_','_'],
                    ['_','_','_']])
playerSymbol1='X'
playerSymbol2='O'

def check_rows(symbol):
    for r in range(3):
        repeated=0
        for c in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_cols(symbol):
    for c in range(3):
        repeated=0
        for r in range(3):
            if Gboard[r][c]==symbol:
                repeated += 1
        if repeated==3:
            return True
    return False

def check_diag(a,b,symbol):
    repeated=0
    for r,c in zip(a,b):
        if Gboard[r][c]==symbol:
            repeated += 1
        if repeated==3:
            return True
    return False

def won(sym):
    a=[0,1,2]
    return (check_rows(sym) or check_cols(sym) or 
            check_diag(a,a,sym) or check_diag(a,list(reversed(a)),sym))

def place(symbol):
    print('{0: ^17}'.format(&quot;Place numbers&quot;))
    print(numpy.matrix(Nboard),&quot;\n==================\n&quot;)
    print(numpy.matrix(Gboard))
    while(1):
        row=int(input('Enter Row - 1 or 2 or 3: '))
        col=int(input('Enter Column - 1 or 2 or 3: '))
        if row&gt;0 and row&lt;4 and col&gt;0 and col&lt;4 and Gboard[row-1][col-1]=='_':
            break
        else:
            print('Invalid input. Please enter again.')
    Gboard[row-1][col-1]=symbol

def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(playerSymbol1)
            if won(playerSymbol1):
                print(playerSymbol1,' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(playerSymbol2)
            if won(playerSymbol2):
                print(playerSymbol2,' Won!')
                break
    if not(won(playerSymbol1)) and not(won(playerSymbol2)):
        print('This game is a Draw!')
            
play()
&lt;/syntaxhighlight&gt;&lt;br /&gt;

==='''Can we use dictionary for ''&quot;Tic Tac Toe&quot;''?'''===
----
Let's explore/experiment...&lt;br /&gt;
We are, kind of, over using the &lt;code&gt;won()&lt;/code&gt; function. Can't we use it once for every change and store another variable?
For that we need two &lt;code&gt;won&lt;/code&gt; variables for both players. This is where, using Dictionary, makes sense. Lets replace few variables in the above program.

* Instead of &lt;code&gt;''playerSymbol1''&lt;/code&gt; and &lt;code&gt;''playerSymbol2''&lt;/code&gt; (line 12, 13), lets use &lt;code&gt;'''player1={'symbol':'X','won':False}'''&lt;/code&gt; and &lt;code&gt;'''player2={'symbol':'X','won':False}'''&lt;/code&gt;

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;12&quot;&gt;
player1={'symbol':'X','won':False}
player2={'symbol':'0','won':False}
&lt;/syntaxhighlight&gt;

* &lt;code&gt;print('{0: ^17}'.format(&quot;O\'s turn&quot;))&lt;/code&gt; is centre aligning '''&quot;O's turn&quot;''' in 17 characters space.
* We need to change in &lt;code&gt;play()&lt;/code&gt; too. Observe '''&lt;code&gt;player1['won']=won(player1['symbol'])&lt;/code&gt;''', we are calling &lt;code&gt;won()&lt;/code&gt; function and saving the state into a ''dictionary variable''. We will do as below.

&lt;syntaxhighlight lang=&quot;Python&quot; line='line' start=&quot;62&quot;&gt;
def play():
    for turn in range(9):
        if turn%2==0:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;X\'s turn&quot;))
            place(player1['symbol'])
            player1['won']=won(player1['symbol'])
            if player1['won']:
                print(player1['symbol'],' Won!')
                break
        else:
            print(&quot;\n&quot;,'{0: ^17}'.format(&quot;O\'s turn&quot;))
            place(player2['symbol'])
            player2['won']=won(player2['symbol'])
            if player2['won']:
                print(player2['symbol'],' Won!')
                break
    if not(player1['won']) and not(player2['won']):
        print('This game is a Draw!')
&lt;/syntaxhighlight&gt;

&lt;br /&gt;

== '''Recursion''' ==
Please visit here: http://sccilabs.org/jocwiki/index.php/Lecture_Notes:Week_4#Recursion

&lt;br /&gt;
=== Binary Search Code: with small correction ===
----
'''Recursion Part 05 video.'''&lt;br /&gt;
There was a problem in the code from the video. One of the checks is missing. When search value is less than all the numbers in the list, program gets stuck with mid=0. Hence it is failing with that error, '''&quot;RecursionError: maximum recursion depth exceeded in comparison&quot;'''. So, we just need to add another condition in '''elif''' part (line 15) in the function, '''&lt;code&gt;indexMid&gt;0&lt;/code&gt;'''. 
&lt;br /&gt;
&lt;syntaxhighlight lang=&quot;Python&quot; line='line'&gt;
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def binary_search(searchList, searchFor, indexStart, indexEnd):
    # Base Case : if 1 element is left in the list.
    if indexStart==indexEnd:
        if searchList[indexStart]==searchFor:
            return indexStart
        else:
            return -1
    else:
        #we will divide the list into half and search
        indexMid=int((indexStart+indexEnd)/2)
        if searchList[indexMid]==searchFor:
            return indexMid
        elif searchList[indexMid]&gt;searchFor and indexMid&gt;0:
            #Left Half
            return binary_search(searchList, searchFor, indexStart, indexMid-1)
        else:
            #Right Half
            return binary_search(searchList, searchFor, indexMid+1, indexEnd)
&quot;&quot;&quot;
For this program, I intentionally used different variable names for functions
(above) and the program (below). So that students can understand that we can
use different variable names too.
&quot;&quot;&quot;
n=[20,60,81,34,76]
n.sort()
s=int(input('Enter Search number: '))
result=binary_search(n, s, 0, len(n)-1)
if result==-1:
    print(s, 'not found!')
else:
    print(s, 'was found at position', result+1)
&lt;/syntaxhighlight&gt;
&lt;br /&gt;

=== Fibonacci Sequence Code ===
&lt;pre&gt;def Fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(Fibonacci(n-1) + Fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))
print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print(Fibonacci(i))
&lt;/pre&gt;

&lt;br /&gt;

=== 4 Different Ways of Fibonacci in Python ===
'''1. Using looping technique'''

&lt;pre&gt;def fib(n):
       a,b = 1,1
       for i in range(n-1):
         a,b = b,a+b
       return a

print(fib(5))&lt;/pre&gt;


'''2. Using Recursion'''

&lt;pre&gt;def fibonacci(n):
    if(n &lt;= 1):
        return n
    else:
        return(fibonacci(n-1) + fibonacci(n-2))

n = int(input(&quot;Enter number of terms:&quot;))

print(&quot;Fibonacci sequence:&quot;)
for i in range(n):
    print fibonacci(i)&lt;/pre&gt;


'''3. Using generators'''

&lt;pre&gt;a,b = 0,1
def fibI():
      global a,b
      while True:
      a,b = b, a+b
      yield a
      f=fibI()
      f.next()
      f.next()
      f.next()
      f.next()

print f.next()&lt;/pre&gt;

'''In python 3.7 the following code can be used
a,b=1,1
def fibI():
    global a,b   
    while True:
        a,b = b, a+b
        yield a
f=fibI()
next(f)
next(f)
next(f)
next(f)
print(next(f))

'''4. Using memoization'''

&lt;pre&gt;def memoize(fn, arg):
    memo = {}
    if arg not in memo:
    memo[arg] = fn(arg)
    return memo[arg]

def fib(n):
       a,b = 1,1
       for i in range(n-1):
           a,b = b,a+b
       return a

fibm = memoize(fib,5)

print(fibm)&lt;/pre&gt;

&lt;br /&gt;

=== Fibonacci Sequence using Memoization as a Decorator ===
&lt;pre&gt;
class Memoize:
      def __init__(self, fn):
                   self.fn = fn
                   self.memo = {}
       
       def __call__(self, arg):
             if arg not in self.memo:
                    self.memo[arg] = self.fn(arg)
       return self.memo[arg]

@Memoize
def fib(n):
    a,b = 1,1
    for i in range(n-1):
          a,b = b,a+b 
          return a

print fib(5)
&lt;/pre&gt;

&lt;br /&gt;

== '''Functional Programming''' ==
A function is a block of organised, reusable code that is used to perform a single, related action. Functions provide better modularity for your program &amp; a high degree of code reusing.

Functional programming is a style of programming that is based around functions. A key part of functional programming is higher order functions.

'''Pure Functions:'''

Pure functions have no side effects &amp; return a value that depends on their arguments.

#Pure_function

&gt;&gt;&gt;def pure(x, y):
       temp = x + 2 * y
       return temp / (2 * x + y)

Pure functions are: 

-- Easier to reason about &amp; test.

-- More efficient. Once the function has been evaluated for an input, the result can be stored &amp; referred to the next time the function of that inout is needed, reducing the number of times the function is called. This is called '''memoization'''

{In computing, '''memoization''' is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. }

-- Easier to run in parallel.

The main advantage of using only pure functions is that they majorly complicate the otherwise simple task of input/output (I/O), since this appears to inherently require side effects. They can also be more difficult to write in some functions.

&lt;br /&gt;
=== Generators ===
Generators are a type of iterable, like lists or tuples.

Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated with for loops.

They can be created using functions &amp; the &quot;'''yield'''&quot; statement.

&gt;&gt;&gt;def count():
    i = 5
       while(i&gt;0):
             yield i
             i-=1 


&gt;&gt;&gt;for i in count():
         print(i)


'''Output'''

5

4

3

2

1


The '''yield''' statement is used to define a generator, replacing the return of a function to provide a result to its caller WITHOUT destroying local variables.

'''Iterable''' -- a container object capable of returning its members, one at a time.

'''yield''' -- returns a value from a generator function.

'''generator''' -- a function which returns an iterator.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of the lists. In fact, they can be infinite. In short, generators allow us to declare a function that behaves like an iterator, i.e., it can be used in a for loop.

Finite generators can be converted into lists by passing them as arguments to the list function.

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all elements have been generated before we start to use them.

=== Lambdas ===
Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects such as strings &amp; integers -- which can be created on the fly, without assigning them to a variable.

The same is possible with functions, provided that they are created using '''lambda''' syntax. Functions created this way are known as '''anonymous'''.

This approach is most commonly used when passing a simple function as an argument to another function.

&gt;&gt;&gt;def my_func(f, arg):
          return f(arg)

&gt;&gt;&gt;my_func(lambda x:2 * x * x, 5)

'''Lambda''' -- a short hand to create anonymous functions.

Lambda functions get their name from lambda calculus, which is a model of computation invented by '''Alonzo Church'''.

Lambda functions aren't as powerful as named functions. They can only do things that require a single expression -- usually equivalent to a single line of code.

'''&gt;&gt;&gt;print((lambda x: x**2 + 5*x +4)(-4))'''

Lambda functions can be assigned to variables &amp; used like normal functions.

=== Filter ===
The function '''filter''' filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

&gt;&gt;&gt;nums = [11, 22, 33, 44, 55]
   res = list(filter(lambda x: x % 2 == 0, nums))
   print(res)

'''Output: [22, 44]'''

Like map, the result has to be explicitly converted to a list if we want to print it.


=== Decorators ===
Decorators provide a way to modify functions using other functions. This is ideal when we need to extend the functionality of functions that we don't want to modify.

'''Decorator''' -- a function that modifies another function or method.

'''Parameter''' -- a named entity in a function (or method) definition that specifies an argument that the function can accept.

We decorate our function by replacing the variable containing the function with a wrapped version.

&gt;&gt;&gt;def print_text():
       print(&quot;Hello world!&quot;)

'''print_text = dÃ©cor(print_text)'''

This pattern can be used at any time, to wrap any function. Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name &amp; the '''@''' symbol.

&gt;&gt;&gt;@decor

&gt;&gt;&gt;def print_text():
       print(&quot;Hello!&quot;)


'''A single function can have multiple decorators.'''</text>
      <sha1>o9f6azi6o2nq1ez0fw0xp9jxrfa9jsj</sha1>
    </revision>
  </page>
</mediawiki>
